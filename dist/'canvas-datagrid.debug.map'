{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap acd5205ce909ea8087c2","webpack:///./lib/defaults.js","webpack:///./lib/main.js","webpack:///./lib/component.js","webpack:///./lib/draw.js","webpack:///./lib/events.js","webpack:///./lib/touch.js","webpack:///./lib/intf.js","webpack:///./lib/contextMenu.js","webpack:///./lib/dom.js","webpack:///./lib/publicMethods.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,KAAK;QACL;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;QAEA;QACA;;;;;;;;;;;;AC7DA;AACA;AACA,iCAAO,EAAE,mCAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,MAAM,MAAM;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACpTF;AACA;AACA,iCAAO;AACP,IAAI,yCAAa;AACjB,IAAI,wCAAY;AAChB,IAAI,oCAAQ;AACZ,IAAI,sCAAU;AACd,IAAI,qCAAS;AACb,IAAI,oCAAQ;AACZ,IAAI,2CAAe;AACnB,IAAI,mCAAO;AACX,IAAI,6CAAiB;AACrB,CAAC,mCAAE;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,sDAAsD,aAAa;AACnE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,uBAAuB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA,0EAA0E,QAAQ;AAClF;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AClHF;AACA;AACA,iCAAO,CAAC,wCAAY,CAAC,mCAAE;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,mDAAmD,mBAAmB,EAAE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD,oDAAoD,4CAA4C,eAAe;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,oCAAoC,wEAAwE;AAC5G;AACA,sCAAsC,wEAAwE;AAC9G,aAAa;AACb;AACA;AACA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AC1MF;AACA;AACA,iCAAO,EAAE,mCAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,gFAAgF,UAAU;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU,oBAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA,sFAAsF,OAAO;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,8EAA8E,SAAS,gCAAgC,EAAE;AACzH;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,IAAI,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,QAAQ;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,QAAQ;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,WAAW;AAC7C;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,OAAO;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA,uDAAuD,oEAAoE,eAAe,EAAE,EAAE;AAC9I,oDAAoD,iEAAiE,eAAe,EAAE,EAAE;AACxI,+CAA+C,kDAAkD;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,mDAAmD;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kEAAkE,eAAe,kDAAkD,YAAY;AAC/I,kEAAkE,eAAe,kDAAkD,YAAY;AAC/I;AACA;AACA;AACA;AACA;AACA,6DAA6D,KAAK,yCAAyC,KAAK;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,IAAI,QAAQ;AAC9D;AACA;AACA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACv0CF;AACA;AACA,iCAAO,EAAE,mCAAE;AACX;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+DAA+D;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oCAAoC;AAC1D;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,qBAAqB;AACtE;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,uCAAuC,IAAI,QAAQ;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,4CAA4C,IAAI,cAAc;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uCAAuC,IAAI,QAAQ;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,uCAAuC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,uCAAuC,IAAI,QAAQ;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,uCAAuC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,uCAAuC,IAAI,QAAQ;AACpG;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,uCAAuC,IAAI,QAAQ;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,eAAe,IAAI,QAAQ;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,uCAAuC,IAAI,QAAQ;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,uCAAuC,IAAI,QAAQ;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,kCAAkC;AACxF;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,uCAAuC,IAAI,QAAQ;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uCAAuC,IAAI,QAAQ;AACnG;AACA;AACA,gDAAgD,uCAAuC,IAAI,QAAQ;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,eAAe;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,4CAA4C,eAAe,IAAI,QAAQ;AACvE,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,4CAA4C,sBAAsB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACrzCF;AACA;AACA,iCAAO,EAAE,mCAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU,EAAE;AAC9C,sCAAsC,cAAc,EAAE;AACtD,uCAAuC,oBAAoB,EAAE;AAC7D,yCAAyC,mDAAmD,EAAE;AAC9F,uCAAuC,kBAAkB,EAAE;AAC3D,wCAAwC,0BAA0B,EAAE;AACpE,0CAA0C,0EAA0E,EAAE;AACtH,uCAAuC,sBAAsB,EAAE;AAC/D,wCAAwC,8BAA8B,EAAE;AACxE,0CAA0C,kEAAkE,EAAE;AAC9G,uCAAuC,0BAA0B,EAAE;AACnE,wCAAwC,mCAAmC,EAAE;AAC7E,0CAA0C,0EAA0E;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,sDAAsD;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,wCAAwC,IAAI,QAAQ;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA,gFAAgF,QAAQ;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,eAAe,IAAI,QAAQ;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,uCAAuC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,eAAe;AAC3F;AACA;AACA;AACA;AACA,gDAAgD,uCAAuC,IAAI,QAAQ;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,uCAAuC,IAAI,QAAQ;AACtG;AACA;AACA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AClYF;AACA;AACA,iCAAO,EAAE,mCAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,oBAAoB;AACpB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,2BAA2B,QAAQ;AACnC,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA,iEAAiE,QAAQ;AACzE;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA,2EAA2E,QAAQ;AACnF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B,EAAE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,kEAAkE;AAClE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wBAAwB,EAAE;AACjE;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,4BAA4B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,gBAAgB,UAAU,EAAE,IAAI;AAC7G,qFAAqF,gBAAgB,UAAU,EAAE,IAAI;AACrH;AACA;AACA,aAAa;AACb;AACA,6CAA6C,yCAAyC,EAAE;AACxF,6CAA6C,wCAAwC,EAAE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,wDAAwD,kCAAkC;AAC1F;AACA,aAAa;AACb,4DAA4D,WAAW;AACvE;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,6BAA6B;AAC7F;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mBAAmB,EAAE;AACxE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qDAAqD,oBAAoB;AACzE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA,yDAAyD,wBAAwB;AACjF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,gBAAgB;AACvE;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACrvCF;AACA;AACA,iCAAO,EAAE,mCAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,wCAAwC,wDAAwD;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,QAAQ;AAC7E,4FAA4F,QAAQ;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4CAA4C;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4CAA4C;AAC5E,gCAAgC,4CAA4C;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,wCAAwC,+BAA+B;AACvE,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,QAAQ;AAC3G;AACA;AACA,gFAAgF,QAAQ,gBAAgB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,uEAAuE,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,sCAAsC;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,mBAAmB,EAAE;AACzE;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,kCAAkC;AAC9F,yDAAyD,kCAAkC;AAC3F;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACrjBF;AACA;AACA,iCAAO,EAAE,mCAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD,iCAAiC,gBAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,IAAI,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA,uDAAuD,qCAAqC,IAAI,cAAc;AAC9G;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,uDAAuD,WAAW;AAClE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6CAA6C,oBAAoB;AACjE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wDAAwD,6BAA6B,I;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,6CAA6C,8BAA8B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AC3iBF;AACA;AACA,iCAAO,EAAE,mCAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,6DAA6D,iDAAiD;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,sDAAsD,+CAA+C;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA,wBAAwB,OAAO;AAC/B,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yCAAyC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,6CAA6C,8BAA8B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B,mBAAmB,KAAK,oEAAoE,yCAAyC;AACrI;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B,mBAAmB,KAAK;AACxB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,wDAAwD,uCAAuC,IAAI,QAAQ;AAC3G;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uCAAuC;AACrF;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C,4CAA4C,uBAAuB;AACnE;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD,yCAAyC,oBAAoB;AAC7D;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,KAAK;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,KAAK;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,QAAQ;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,KAAK;AAC1B;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,KAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kCAAkC;AAChF;AACA,mDAAmD,iCAAiC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,UAAU;AACjE;AACA;AACA,mDAAmD,UAAU;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA,oGAAC","file":"canvas-datagrid.debug.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"canvasDatagrid\"] = factory();\n\telse\n\t\troot[\"canvasDatagrid\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap acd5205ce909ea8087c2","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        self.defaults = {\r\n            attributes: [\r\n                ['allowColumnReordering', true],\r\n                ['allowColumnResize', true],\r\n                ['allowColumnResizeFromCell', false],\r\n                ['allowFreezingRows', false],\r\n                ['allowFreezingColumns', false],\r\n                ['allowMovingSelection', true],\r\n                ['allowRowHeaderResize', true],\r\n                ['allowRowReordering', false],\r\n                ['allowRowResize', true],\r\n                ['allowRowResizeFromCell', false],\r\n                ['allowSorting', true],\r\n                ['autoGenerateSchema', false],\r\n                ['autoResizeColumns', false],\r\n                ['borderDragBehavior', 'none'],\r\n                ['borderResizeZone', 10],\r\n                ['clearSettingsOptionText', 'Clear saved settings'],\r\n                ['columnHeaderClickBehavior', 'sort'],\r\n                ['columnSelectorHiddenText', '&nbsp;&nbsp;&nbsp;'],\r\n                ['columnSelectorText', 'Add/Remove columns'],\r\n                ['columnSelectorVisibleText', '\\u2713'],\r\n                ['contextHoverScrollAmount', 2],\r\n                ['contextHoverScrollRateMs', 5],\r\n                ['copyHeadersOnSelectAll', true],\r\n                ['copyText', 'Copy'],\r\n                ['debug', false],\r\n                ['editable', true],\r\n                ['ellipsisText', '...'],\r\n                ['filterOptionText', 'Filter %s'],\r\n                ['filterTextPrefix', '(filtered) '],\r\n                ['globalRowResize', false],\r\n                ['hideColumnText', 'Hide %s'],\r\n                ['maxAutoCompleteItems', 200],\r\n                ['multiLine', false],\r\n                ['name', ''],\r\n                ['pageUpDownOverlap', 1],\r\n                ['pasteText', 'Paste'],\r\n                ['persistantSelectionMode', false],\r\n                ['removeFilterOptionText', 'Remove filter on %s'],\r\n                ['reorderDeadZone', 3],\r\n                ['resizeScrollZone', 20],\r\n                ['rowGrabZoneSize', 5],\r\n                ['saveAppearance', true],\r\n                ['scrollAnimationPPSThreshold', 0.75],\r\n                ['scrollPointerLock', false],\r\n                ['scrollRepeatRate', 75],\r\n                ['selectionFollowsActiveCell', false],\r\n                ['selectionHandleBehavior', 'none'],\r\n                ['selectionMode', 'cell'],\r\n                ['selectionScrollIncrement', 20],\r\n                ['selectionScrollZone', 20],\r\n                ['showClearSettingsOption', true],\r\n                ['showColumnHeaders', true],\r\n                ['showColumnSelector', true],\r\n                ['showCopy', false],\r\n                ['showFilter', true],\r\n                ['showNewRow', false],\r\n                ['showOrderByOption', true],\r\n                ['showOrderByOptionTextAsc', 'Order by %s ascending'],\r\n                ['showOrderByOptionTextDesc', 'Order by %s descending'],\r\n                ['showPaste', false],\r\n                ['showPerformance', false],\r\n                ['showRowHeaders', true],\r\n                ['showRowNumbers', true],\r\n                ['snapToRow', false],\r\n                ['touchContextMenuTimeMs', 800],\r\n                ['touchDeadZone', 3],\r\n                ['touchEasingMethod', 'easeOutQuad'],\r\n                ['touchReleaseAcceleration', 1000],\r\n                ['touchReleaseAnimationDurationMs', 2000],\r\n                ['touchScrollZone', 20],\r\n                ['touchSelectHandleZone', 20],\r\n                ['touchZoomSensitivity', 0.005],\r\n                ['touchZoomMin', 0.5],\r\n                ['touchZoomMax', 1.75],\r\n                ['maxPixelRatio', 2],\r\n                ['tree', false],\r\n                ['treeHorizontalScroll', false]\r\n            ],\r\n            styles: [\r\n                ['activeCellBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n                ['activeCellBorderColor', 'rgba(110, 168, 255, 1)'],\r\n                ['activeCellBorderWidth', 1],\r\n                ['activeCellColor', 'rgba(0, 0, 0, 1)'],\r\n                ['activeCellFont', '16px sans-serif'],\r\n                ['activeCellHoverBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n                ['activeCellHorizontalAlignment', 'left'],\r\n                ['activeCellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n                ['activeCellOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\r\n                ['activeCellOverlayBorderWidth', 1],\r\n                ['activeCellPaddingBottom', 5],\r\n                ['activeCellPaddingLeft', 5],\r\n                ['activeCellPaddingRight', 5],\r\n                ['activeCellPaddingTop', 5],\r\n                ['activeCellSelectedBackgroundColor', 'rgba(236, 243, 255, 1)'],\r\n                ['activeCellSelectedColor', 'rgba(0, 0, 0, 1)'],\r\n                ['activeCellVerticalAlignment', 'center'],\r\n                ['activeColumnHeaderCellBackgroundColor', 'rgba(225, 225, 225, 1)'],\r\n                ['activeColumnHeaderCellColor', 'rgba(0, 0, 0, 1)'],\r\n                ['activeRowHeaderCellBackgroundColor', 'rgba(225, 225, 225, 1)'],\r\n                ['activeRowHeaderCellColor', 'rgba(0, 0, 0, 1)'],\r\n                ['autocompleteBottomMargin', 60],\r\n                ['autosizeHeaderCellPadding', 8],\r\n                ['autosizePadding', 5],\r\n                ['cellAutoResizePadding', 13],\r\n                ['cellBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n                ['cellBorderColor', 'rgba(195, 199, 202, 1)'],\r\n                ['cellBorderWidth', 1],\r\n                ['cellColor', 'rgba(0, 0, 0, 1)'],\r\n                ['cellFont', '16px sans-serif'],\r\n                ['cellGridHeight', 250],\r\n                ['cellHeight', 24],\r\n                ['cellHeightWithChildGrid', 150],\r\n                ['cellHorizontalAlignment', 'left'],\r\n                ['cellHoverBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n                ['cellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n                ['cellPaddingBottom', 5],\r\n                ['cellPaddingLeft', 5],\r\n                ['cellPaddingRight', 5],\r\n                ['cellPaddingTop', 5],\r\n                ['cellSelectedBackgroundColor', 'rgba(236, 243, 255, 1)'],\r\n                ['cellSelectedColor', 'rgba(0, 0, 0, 1)'],\r\n                ['cellVerticalAlignment', 'center'],\r\n                ['cellWidth', 250],\r\n                ['cellWidthWithChildGrid', 250],\r\n                ['cellWhiteSpace', 'nowrap'],\r\n                ['cellLineHeight', 1],\r\n                ['cellLineSpacing', 3],\r\n                ['childContextMenuArrowColor', 'rgba(43, 48, 43, 1)'],\r\n                ['childContextMenuArrowHTML', '&#x25BA;'],\r\n                ['childContextMenuMarginLeft', -11],\r\n                ['childContextMenuMarginTop', -6],\r\n                ['columnHeaderCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['columnHeaderCellBorderColor', 'rgba(172, 172, 172, 1)'],\r\n                ['columnHeaderCellBorderWidth', 1],\r\n                ['columnHeaderCellCapBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['columnHeaderCellCapBorderColor', 'rgba(172, 172, 172, 1)'],\r\n                ['columnHeaderCellCapBorderWidth', 1],\r\n                ['columnHeaderCellColor', 'rgba(50, 50, 50, 1)'],\r\n                ['columnHeaderCellFont', '16px sans-serif'],\r\n                ['columnHeaderCellHeight', 25],\r\n                ['columnHeaderCellHorizontalAlignment', 'left'],\r\n                ['columnHeaderCellHoverBackgroundColor', 'rgba(235, 235, 235, 1)'],\r\n                ['columnHeaderCellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n                ['columnHeaderCellPaddingBottom', 5],\r\n                ['columnHeaderCellPaddingLeft', 5],\r\n                ['columnHeaderCellPaddingRight', 5],\r\n                ['columnHeaderCellPaddingTop', 5],\r\n                ['columnHeaderCellVerticalAlignment', 'center'],\r\n                ['columnHeaderOrderByArrowBorderColor', 'rgba(195, 199, 202, 1)'],\r\n                ['columnHeaderOrderByArrowBorderWidth', 1],\r\n                ['columnHeaderOrderByArrowColor', 'rgba(155, 155, 155, 1)'],\r\n                ['columnHeaderOrderByArrowHeight', 8],\r\n                ['columnHeaderOrderByArrowMarginLeft', 0],\r\n                ['columnHeaderOrderByArrowMarginRight', 5],\r\n                ['columnHeaderOrderByArrowMarginTop', 6],\r\n                ['columnHeaderOrderByArrowWidth', 13],\r\n                ['contextFilterButtonBorder', 'solid 1px rgba(158, 163, 169, 1)'],\r\n                ['contextFilterButtonBorderRadius', '3px'],\r\n                ['contextFilterButtonHTML', '&#x25BC;'],\r\n                ['contextFilterInputBackground', 'rgba(255,255,255,1)'],\r\n                ['contextFilterInputBorder', 'solid 1px rgba(158, 163, 169, 1)'],\r\n                ['contextFilterInputBorderRadius', '0'],\r\n                ['contextFilterInputColor', 'rgba(0,0,0,1)'],\r\n                ['contextFilterInputFontFamily', 'sans-serif'],\r\n                ['contextFilterInputFontSize', '14px'],\r\n                ['contextFilterInvalidRegExpBackground', 'rgba(180, 6, 1, 1)'],\r\n                ['contextFilterInvalidRegExpColor', 'rgba(255, 255, 255, 1)'],\r\n                ['contextMenuArrowColor', 'rgba(43, 48, 43, 1)'],\r\n                ['contextMenuArrowDownHTML', '&#x25BC;'],\r\n                ['contextMenuArrowUpHTML', '&#x25B2;'],\r\n                ['contextMenuBackground', 'rgba(240, 240, 240, 1)'],\r\n                ['contextMenuBorder', 'solid 1px rgba(158, 163, 169, 1)'],\r\n                ['contextMenuBorderRadius', '3px'],\r\n                ['contextMenuChildArrowFontSize', '12px'],\r\n                ['contextMenuColor', 'rgba(43, 48, 43, 1)'],\r\n                ['contextMenuCursor', 'default'],\r\n                ['contextMenuFilterButtonFontFamily', 'sans-serif'],\r\n                ['contextMenuFilterButtonFontSize', '10px'],\r\n                ['contextMenuFilterInvalidExpresion', 'rgba(237, 155, 156, 1)'],\r\n                ['contextMenuFontFamily', 'sans-serif'],\r\n                ['contextMenuFontSize', '16px'],\r\n                ['contextMenuHoverBackground', 'rgba(182, 205, 250, 1)'],\r\n                ['contextMenuHoverColor', 'rgba(43, 48, 153, 1)'],\r\n                ['contextMenuItemBorderRadius', '3px'],\r\n                ['contextMenuItemMargin', '2px'],\r\n                ['contextMenuLabelDisplay', 'inline-block'],\r\n                ['contextMenuLabelMargin', '0 3px 0 0'],\r\n                ['contextMenuLabelMaxWidth', '700px'],\r\n                ['contextMenuLabelMinWidth', '75px'],\r\n                ['contextMenuMarginLeft', 3],\r\n                ['contextMenuMarginTop', -3],\r\n                ['contextMenuOpacity', '0.98'],\r\n                ['contextMenuPadding', '2px'],\r\n                ['contextMenuWindowMargin', 30],\r\n                ['contextMenuZIndex', 10000],\r\n                ['cornerCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['cornerCellBorderColor', 'rgba(202, 202, 202, 1)'],\r\n                ['debugBackgroundColor', 'rgba(0, 0, 0, .0)'],\r\n                ['debugColor', 'rgba(255, 15, 24, 1)'],\r\n                ['debugEntitiesColor', 'rgba(76, 231, 239, 1.00)'],\r\n                ['debugFont', '11px sans-serif'],\r\n                ['debugPerfChartBackground', 'rgba(29, 25, 26, 1.00)'],\r\n                ['debugPerfChartTextColor', 'rgba(255, 255, 255, 0.8)'],\r\n                ['debugPerformanceColor', 'rgba(252, 255, 37, 1.00)'],\r\n                ['debugScrollHeightColor', 'rgba(248, 33, 103, 1.00)'],\r\n                ['debugScrollWidthColor', 'rgba(66, 255, 27, 1.00)'],\r\n                ['debugTouchPPSXColor', 'rgba(246, 102, 24, 1.00)'],\r\n                ['debugTouchPPSYColor', 'rgba(186, 0, 255, 1.00)'],\r\n                ['display', 'inline-block'],\r\n                ['editCellBackgroundColor', 'white'],\r\n                ['editCellBorder', 'solid 1px rgba(110, 168, 255, 1)'],\r\n                ['editCellBoxShadow', '0 2px 5px rgba(0,0,0,0.4)'],\r\n                ['editCellColor', 'black'],\r\n                ['editCellFontFamily', 'sans-serif'],\r\n                ['editCellFontSize', '16px'],\r\n                ['editCellPaddingLeft', 4],\r\n                ['editCellZIndex', 10000],\r\n                ['frozenMarkerHoverColor', 'rgba(236, 243, 255, 1)'],\r\n                ['frozenMarkerHoverBorderColor', 'rgba(110, 168, 255, 1)'],\r\n                ['frozenMarkerActiveColor', 'rgba(236, 243, 255, 1)'],\r\n                ['frozenMarkerActiveBorderColor', 'rgba(110, 168, 255, 1)'],\r\n                ['frozenMarkerColor', 'rgba(222, 222, 222, 1)'],\r\n                ['frozenMarkerBorderColor', 'rgba(168, 168, 168, 1)'],\r\n                ['frozenMarkerBorderWidth', 1],\r\n                ['frozenMarkerWidth', 2],\r\n                ['gridBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['gridBorderCollapse', 'collapse'],\r\n                ['gridBorderColor', 'rgba(202, 202, 202, 1)'],\r\n                ['gridBorderWidth', 1],\r\n                ['height', 'auto'],\r\n                ['maxHeight', 'inherit'],\r\n                ['maxWidth', 'inherit'],\r\n                ['minColumnWidth', 45],\r\n                ['minHeight', 'inherit'],\r\n                ['minRowHeight', 24],\r\n                ['minWidth', 'inherit'],\r\n                ['mobileContextMenuMargin', 10],\r\n                ['mobileEditInputHeight', 30],\r\n                ['mobileEditFontFamily', 'sans-serif'],\r\n                ['mobileEditFontSize', '16px'],\r\n                ['moveOverlayBorderWidth', 1],\r\n                ['moveOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\r\n                ['moveOverlayBorderSegments', '12, 7'],\r\n                ['name', 'default'],\r\n                ['overflowY', 'auto'],\r\n                ['overflowX', 'auto'],\r\n                ['reorderMarkerBackgroundColor', 'rgba(0, 0, 0, 0.1)'],\r\n                ['reorderMarkerBorderColor', 'rgba(0, 0, 0, 0.2)'],\r\n                ['reorderMarkerBorderWidth', 1.25],\r\n                ['reorderMarkerIndexBorderColor', 'rgba(66, 133, 244, 1)'],\r\n                ['reorderMarkerIndexBorderWidth', 2.75],\r\n                ['rowHeaderCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['rowHeaderCellBorderColor', 'rgba(200, 200, 200, 1)'],\r\n                ['rowHeaderCellBorderWidth', 1],\r\n                ['rowHeaderCellColor', 'rgba(50, 50, 50, 1)'],\r\n                ['rowHeaderCellFont', '16px sans-serif'],\r\n                ['rowHeaderCellHeight', 25],\r\n                ['rowHeaderCellHorizontalAlignment', 'left'],\r\n                ['rowHeaderCellHoverBackgroundColor', 'rgba(235, 235, 235, 1)'],\r\n                ['rowHeaderCellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n                ['rowHeaderCellPaddingBottom', 5],\r\n                ['rowHeaderCellPaddingLeft', 5],\r\n                ['rowHeaderCellPaddingRight', 5],\r\n                ['rowHeaderCellPaddingTop', 5],\r\n                ['rowHeaderCellSelectedBackgroundColor', 'rgba(217, 217, 217, 1)'],\r\n                ['rowHeaderCellSelectedColor', 'rgba(50, 50, 50, 1)'],\r\n                ['rowHeaderCellVerticalAlignment', 'center'],\r\n                ['rowHeaderCellWidth', 57],\r\n                ['scrollBarActiveColor', 'rgba(125, 125, 125, 1)'],\r\n                ['scrollBarBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['scrollBarBorderColor', 'rgba(202, 202, 202, 1)'],\r\n                ['scrollBarBorderWidth', 0.5],\r\n                ['scrollBarBoxBorderRadius', 4.125],\r\n                ['scrollBarBoxColor', 'rgba(192, 192, 192, 1)'],\r\n                ['scrollBarBoxMargin', 2],\r\n                ['scrollBarBoxMinSize', 15],\r\n                ['scrollBarBoxWidth', 8],\r\n                ['scrollBarCornerBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['scrollBarCornerBorderColor', 'rgba(202, 202, 202, 1)'],\r\n                ['scrollBarWidth', 11],\r\n                ['selectionHandleBorderColor', 'rgba(255, 255, 255, 1)'],\r\n                ['selectionHandleBorderWidth', 1.5],\r\n                ['selectionHandleColor', 'rgba(66, 133, 244, 1)'],\r\n                ['selectionHandleSize', 8],\r\n                ['selectionHandleType', 'square'],\r\n                ['selectionOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\r\n                ['selectionOverlayBorderWidth', 1],\r\n                ['treeArrowBorderColor', 'rgba(195, 199, 202, 1)'],\r\n                ['treeArrowBorderWidth', 1],\r\n                ['treeArrowClickRadius', 5],\r\n                ['treeArrowColor', 'rgba(155, 155, 155, 1)'],\r\n                ['treeArrowHeight', 8],\r\n                ['treeArrowMarginLeft', 0],\r\n                ['treeArrowMarginRight', 5],\r\n                ['treeArrowMarginTop', 6],\r\n                ['treeArrowWidth', 13],\r\n                ['treeGridHeight', 250],\r\n                ['width', 'auto']\r\n            ]\r\n        };\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/defaults.js\n// module id = 0\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true, evil: true*/\r\n/*globals Reflect: false, HTMLElement: true, define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([\r\n    './component',\r\n    './defaults',\r\n    './draw',\r\n    './events',\r\n    './touch',\r\n    './intf',\r\n    './contextMenu',\r\n    './dom',\r\n    './publicMethods'\r\n], function context(component) {\r\n    'use strict';\r\n    component = component();\r\n    var modules = Array.prototype.slice.call(arguments);\r\n    function Grid(args) {\r\n        args = args || {};\r\n        var self = {};\r\n        self.isComponent = args.component === undefined;\r\n        self.isChildGrid = args.parentNode && /canvas-datagrid-(cell|tree)/.test(args.parentNode.nodeType);\r\n        if (self.isChildGrid) {\r\n            self.intf = {};\r\n        } else {\r\n            self.intf = self.isComponent ? eval('Reflect.construct(HTMLElement, [], new.target)')\r\n                : document.createElement('canvas');\r\n        }\r\n        self.args = args;\r\n        self.intf.args = args;\r\n        self.applyComponentStyle = component.applyComponentStyle;\r\n        self.hyphenateProperty = component.hyphenateProperty;\r\n        self.dehyphenateProperty = component.dehyphenateProperty;\r\n        self.createGrid = function grid(args) {\r\n            args.component = false;\r\n            return new Grid(args);\r\n        };\r\n        modules.forEach(function (module) {\r\n            module(self);\r\n        });\r\n        if (self.isChildGrid) {\r\n            self.shadowRoot = args.parentNode.shadowRoot;\r\n            self.parentNode = args.parentNode;\r\n        } else if (self.intf.createShadowRoot) {\r\n            self.shadowRoot = self.intf.attachShadow({mode: 'open'});\r\n            self.parentNode = self.shadowRoot;\r\n        } else {\r\n            self.parentNode = self.intf;\r\n        }\r\n        self.init();\r\n        return self.intf;\r\n    }\r\n    if (window.HTMLElement) {\r\n        Grid.prototype = Object.create(window.HTMLElement.prototype);\r\n    }\r\n    // export web component\r\n    if (window.customElements) {\r\n        Grid.observedAttributes = component.getObservableAttributes();\r\n        Grid.prototype.disconnectedCallback = component.disconnectedCallback;\r\n        Grid.prototype.attributeChangedCallback = component.attributeChangedCallback;\r\n        Grid.prototype.connectedCallback = component.connectedCallback;\r\n        Grid.prototype.adoptedCallback = component.adoptedCallback;\r\n        window.customElements.define('canvas-datagrid', Grid);\r\n    }\r\n    // export global\r\n    if (window && !window.canvasDatagrid && !window.require) {\r\n        window.canvasDatagrid = function (args) { return new Grid(args); };\r\n    }\r\n    // export amd loader\r\n    module.exports = function grid(args) {\r\n        args = args || {};\r\n        var i, tKeys = ['style', 'formatters', 'sorters', 'filters',\r\n                    'treeGridAttributes', 'cellGridAttributes', 'data', 'schema'];\r\n        if (window.customElements && document.body.createShadowRoot) {\r\n            i = document.createElement('canvas-datagrid');\r\n            Object.keys(args).forEach(function (argKey) {\r\n                // set data and parentNode after everything else\r\n                if (argKey === 'data') { return; }\r\n                if (argKey === 'parentNode') { return; }\r\n                // top level keys in args\r\n                if (tKeys.indexOf(argKey) !== -1) {\r\n                    tKeys.forEach(function (tKey) {\r\n                        if (args[tKey] === undefined || tKey !== argKey) { return; }\r\n                        if (['formatters', 'sorters', 'filters'].indexOf(argKey) !== -1) {\r\n                            if (typeof args[tKey] === 'object' && args[tKey] !== null) {\r\n                                Object.keys(args[tKey]).forEach(function (sKey) {\r\n                                    i[tKey][sKey] = args[tKey][sKey];\r\n                                });\r\n                            }\r\n                        } else {\r\n                            i[tKey] = args[tKey];\r\n                        }\r\n                    });\r\n                    return;\r\n                }\r\n                // all others are attribute level keys\r\n                i.attributes[argKey] = args[argKey];\r\n            });\r\n            if (args.data) {\r\n                i.data = args.data;\r\n            }\r\n            // add to the dom very last to avoid redraws\r\n            if (args.parentNode) {\r\n                args.parentNode.appendChild(i);\r\n            }\r\n            return i;\r\n        }\r\n        args.component = false;\r\n        i = new Grid(args);\r\n        if (args.parentNode && args.parentNode.appendChild) {\r\n            args.parentNode.appendChild(i);\r\n        }\r\n        return i;\r\n    };\r\n    return module.exports;\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/main.js\n// module id = 1\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine(['./defaults'], function (defaults) {\r\n    'use strict';\r\n    return function () {\r\n        var typeMap, component = {};\r\n        component.dehyphenateProperty = function hyphenateProperty(prop) {\r\n            prop = prop.replace('--cdg-', '');\r\n            var p = '', nextLetterCap;\r\n            Array.prototype.forEach.call(prop, function (char) {\r\n                if (nextLetterCap) {\r\n                    nextLetterCap = false;\r\n                    p += char.toUpperCase();\r\n                    return;\r\n                }\r\n                if (char === '-') {\r\n                    nextLetterCap = true;\r\n                    return;\r\n                }\r\n                p += char;\r\n            });\r\n            return p;\r\n        };\r\n        component.hyphenateProperty = function hyphenateProperty(prop, cust) {\r\n            var p = '';\r\n            Array.prototype.forEach.call(prop, function (char) {\r\n                if (char === char.toUpperCase()) {\r\n                    p += '-' + char.toLowerCase();\r\n                    return;\r\n                }\r\n                p += char;\r\n            });\r\n            return (cust ? '--cdg-' : '') + p;\r\n        };\r\n        function getDefaultItem(base, item) {\r\n            var i = {},\r\n                r;\r\n            defaults(i);\r\n            r = i.defaults[base].filter(function (i) {\r\n                return i[0].toLowerCase() === item.toLowerCase()\r\n                    || component.hyphenateProperty(i[0]) === item.toLowerCase()\r\n                    || component.hyphenateProperty(i[0], true) === item.toLowerCase();\r\n            })[0];\r\n            return r;\r\n        }\r\n        component.applyComponentStyle = function (supressChangeAndDrawEvents, intf) {\r\n            if (!intf.isComponent) { return; }\r\n            var cStyle = window.getComputedStyle(intf.tagName === 'CANVAS-DATAGRID' ? intf : intf.canvas, null),\r\n                defs = {};\r\n            intf.computedStyle = cStyle;\r\n            defaults(defs);\r\n            defs = defs.defaults.styles;\r\n            defs.forEach(function (def) {\r\n                var val;\r\n                val = cStyle.getPropertyValue(component.hyphenateProperty(def[0], true));\r\n                if (val === \"\") {\r\n                    val = cStyle.getPropertyValue(component.hyphenateProperty(def[0], false));\r\n                }\r\n                if (val !== \"\" && typeof val === 'string') {\r\n                    intf.setStyleProperty(def[0], typeMap[typeof def[1]](val\r\n                        .replace(/^\\s+/, '').replace(/\\s+$/, ''), def[1]), true);\r\n                }\r\n            });\r\n            if (!supressChangeAndDrawEvents && intf.dispatchEvent) {\r\n                requestAnimationFrame(function () { intf.resize(true); });\r\n                intf.dispatchEvent('stylechanged', intf.style);\r\n            }\r\n        };\r\n        typeMap = {\r\n            data: function (strData) {\r\n                try {\r\n                    return JSON.parse(strData);\r\n                } catch (e) {\r\n                    throw new Error('Cannot read JSON data in canvas-datagrid data.');\r\n                }\r\n            },\r\n            schema: function (strSchema) {\r\n                try {\r\n                    return JSON.parse(strSchema);\r\n                } catch (e) {\r\n                    throw new Error('Cannot read JSON data in canvas-datagrid schema attribute.');\r\n                }\r\n            },\r\n            number: function (strNum, def) {\r\n                var n = parseInt(strNum, 10);\r\n                return isNaN(n) ? def : n;\r\n            },\r\n            boolean: function (strBool) {\r\n                return (/true/i).test(strBool);\r\n            },\r\n            string: function (str) {\r\n                return str;\r\n            }\r\n        };\r\n        component.getObservableAttributes = function () {\r\n            var i = {}, attrs = ['data', 'schema', 'style', 'className', 'name'];\r\n            defaults(i);\r\n            i.defaults.attributes.forEach(function (attr) {\r\n                attrs.push(attr[0].toLowerCase());\r\n            });\r\n            return attrs;\r\n        };\r\n        component.disconnectedCallback = function () {\r\n            this.connected = false;\r\n        };\r\n        component.connectedCallback = function () {\r\n            var intf = this;\r\n            intf.parentDOMNode.innerHTML = \"\";\r\n            intf.parentDOMNode.appendChild(intf.canvas);\r\n            intf.connected = true;\r\n            component.observe(intf);\r\n            component.applyComponentStyle(true, intf);\r\n            intf.resize(true);\r\n        };\r\n        component.adoptedCallback = function () {\r\n            this.resize();\r\n        };\r\n        component.attributeChangedCallback = function (attrName, oldVal, newVal) {\r\n            var tfn, intf = this, def;\r\n            if (attrName === 'style') {\r\n                component.applyComponentStyle(false, intf);\r\n                return;\r\n            }\r\n            if (attrName === 'data') {\r\n                if (intf.dataType === 'application/x-canvas-datagrid') {\r\n                    intf.dataType = 'application/json+x-canvas-datagrid';\r\n                }\r\n                intf.args.data = newVal;\r\n                return;\r\n            }\r\n            if (attrName === 'schema') {\r\n                intf.args.schema = typeMap.schema(newVal);\r\n                return;\r\n            }\r\n            if (attrName === 'name') {\r\n                intf.name = newVal;\r\n                return;\r\n            }\r\n            if (attrName === 'class' || attrName === 'className') {\r\n                return;\r\n            }\r\n            def = getDefaultItem('attributes', attrName);\r\n            if (def) {\r\n                tfn = typeMap[typeof def[1]];\r\n                intf.attributes[def[0]] = tfn(newVal);\r\n                return;\r\n            }\r\n            if (/^on/.test(attrName)) {\r\n                intf.addEventListener('on' + attrName, function (e) {\r\n                    eval(newVal);\r\n                });\r\n            }\r\n            return;\r\n        };\r\n        component.observe = function (intf) {\r\n            var observer;\r\n            if (!window.MutationObserver) { return; }\r\n            intf.applyComponentStyle = function () { component.applyComponentStyle(false, intf); intf.resize(); };\r\n            /**\r\n             * Applies the computed css styles to the grid.  In some browsers, changing directives in attached style sheets does not automatically update the styles in this component.  It is necessary to call this method to update in these cases.\r\n             * @memberof canvasDatagrid\r\n             * @name applyComponentStyle\r\n             * @method\r\n             */\r\n            observer = new window.MutationObserver(function (mutations) {\r\n                var checkInnerHTML, checkStyle;\r\n                Array.prototype.forEach.call(mutations, function (mutation) {\r\n                    if (mutation.attributeName === 'class'\r\n                            || mutation.attributeName === 'style') {\r\n                        checkStyle = true;\r\n                        return;\r\n                    }\r\n                    if (mutation.target.nodeName === 'STYLE') {\r\n                        checkStyle = true;\r\n                        return;\r\n                    }\r\n                    if (mutation.target.parentNode\r\n                            && mutation.target.parentNode.nodeName === 'STYLE') {\r\n                        checkStyle = true;\r\n                        return;\r\n                    }\r\n                    if (mutation.target === intf && (mutation.addedNodes.length > 0 || mutation.type === 'characterData')) {\r\n                        checkInnerHTML = true;\r\n                    }\r\n                });\r\n                if (checkStyle) {\r\n                    intf.applyComponentStyle(false, intf);\r\n                }\r\n                if (checkInnerHTML) {\r\n                    if (intf.dataType === 'application/x-canvas-datagrid') {\r\n                        intf.dataType = 'application/json+x-canvas-datagrid';\r\n                    }\r\n                    intf.data = intf.innerHTML;\r\n                }\r\n            });\r\n            observer.observe(intf, { characterData: true, childList: true, attributes: true, subtree: true });\r\n            Array.prototype.forEach.call(document.querySelectorAll('style'), function (el) {\r\n                observer.observe(el, { characterData: true, childList: true, attributes: true, subtree: true });\r\n            });\r\n        };\r\n        return component;\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component.js\n// module id = 2\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals XMLSerializer: false, define: true, Blob: false, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        var perfCounters = [],\r\n            cachedImagesDrawn = false,\r\n            drawCount = 0,\r\n            perfWindowSize = 300,\r\n            entityCount = [],\r\n            hiddenFrozenColumnCount = 0,\r\n            scrollDebugCounters = [],\r\n            touchPPSCounters = [];\r\n        self.htmlImageCache = {};\r\n        // more heavyweight version than fillArray defined in intf.js\r\n        function fillArray(low, high, step, def) {\r\n            step = step || 1;\r\n            var i = [], x;\r\n            for (x = low; x <= high; x += step) {\r\n                i[x] = def === undefined ? x : (typeof def === 'function' ? def(x) : def);\r\n            }\r\n            return i;\r\n        }\r\n        function drawPerfLine(w, h, x, y, perfArr, arrIndex, max, color, useAbs) {\r\n            var i = w / perfArr.length,\r\n                r = h / max;\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.beginPath();\r\n            self.ctx.moveTo(x, y + h);\r\n            perfArr.forEach(function (n) {\r\n                var val = (arrIndex === undefined ? n : n[arrIndex]),\r\n                    cx,\r\n                    cy;\r\n                if (useAbs) {\r\n                    val = Math.abs(val);\r\n                }\r\n                cx = x + i;\r\n                cy = y + h - (val * r);\r\n                self.ctx.lineTo(cx, cy);\r\n                x += i;\r\n            });\r\n            self.ctx.moveTo(x + w, y + h);\r\n            self.ctx.strokeStyle = color;\r\n            self.ctx.stroke();\r\n        }\r\n        function drawOnAllImagesLoaded() {\r\n            var loaded = true;\r\n            Object.keys(self.htmlImageCache).forEach(function (html) {\r\n                if (!self.htmlImageCache[html].complete) {\r\n                    loaded = false;\r\n                }\r\n            });\r\n            if (loaded && !cachedImagesDrawn) {\r\n                cachedImagesDrawn = true;\r\n                self.draw();\r\n            }\r\n        }\r\n        function drawHtml(cell) {\r\n            var img,\r\n                v = cell.innerHTML || cell.formattedValue,\r\n                cacheKey = v.toString() + cell.rowIndex.toString() + cell.columnIndex.toString(), \r\n                x = cell.x + self.canvasOffsetLeft,\r\n                y = cell.y + self.canvasOffsetTop;\r\n            if (self.htmlImageCache[cacheKey]) {\r\n                img = self.htmlImageCache[cacheKey];\r\n                if (img.height !== cell.height || img.width !== cell.width) {\r\n                    // height and width of the cell has changed, invalidate cache\r\n                    self.htmlImageCache[cacheKey] = undefined;\r\n                } else {\r\n                    if (!img.complete) {\r\n                        return;\r\n                    }\r\n                    return self.ctx.drawImage(img, x, y);\r\n                }\r\n            } else {\r\n                cachedImagesDrawn = false;\r\n            }\r\n            img = new Image(cell.width, cell.height);\r\n            self.htmlImageCache[cacheKey] = img;\r\n            img.onload = function () {\r\n                self.ctx.drawImage(img, x, y);\r\n                drawOnAllImagesLoaded();\r\n            };\r\n            img.src = 'data:image/svg+xml;base64,' + btoa(\r\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' + cell.width + '\" height=\"' + cell.height + '\">\\n' +\r\n                    '<foreignObject class=\"node\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">\\n' +\r\n                    '<body xmlns=\"http://www.w3.org/1999/xhtml\" style=\"margin:0;padding:0;\">\\n' +\r\n                    v + '\\n' +\r\n                    '</body>' +\r\n                    '</foreignObject>\\n' +\r\n                    '</svg>\\n'\r\n            );\r\n        }\r\n        function drawOrderByArrow(x, y) {\r\n            var mt = self.style.columnHeaderOrderByArrowMarginTop * self.scale,\r\n                ml = self.style.columnHeaderOrderByArrowMarginLeft * self.scale,\r\n                mr = self.style.columnHeaderOrderByArrowMarginRight * self.scale,\r\n                aw = self.style.columnHeaderOrderByArrowWidth * self.scale,\r\n                ah = self.style.columnHeaderOrderByArrowHeight * self.scale;\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.fillStyle = self.style.columnHeaderOrderByArrowColor;\r\n            self.ctx.strokeStyle = self.style.columnHeaderOrderByArrowBorderColor;\r\n            self.ctx.beginPath();\r\n            x = x + ml;\r\n            y = y + mt;\r\n            if (self.orderDirection === 'asc') {\r\n                self.ctx.moveTo(x, y);\r\n                self.ctx.lineTo(x + aw, y);\r\n                self.ctx.lineTo(x + (aw * 0.5), y + ah);\r\n                self.ctx.moveTo(x, y);\r\n            } else {\r\n                self.ctx.lineTo(x, y + ah);\r\n                self.ctx.lineTo(x + aw, y + ah);\r\n                self.ctx.lineTo(x + (aw * 0.5), y);\r\n                self.ctx.lineTo(x, y + ah);\r\n            }\r\n            self.ctx.stroke();\r\n            self.ctx.fill();\r\n            return ml + aw + mr;\r\n        }\r\n        function drawTreeArrow(cell, x, y) {\r\n            var mt = self.style.treeArrowMarginTop * self.scale,\r\n                mr = self.style.treeArrowMarginRight * self.scale,\r\n                ml = self.style.treeArrowMarginLeft * self.scale,\r\n                aw = self.style.treeArrowWidth * self.scale,\r\n                ah = self.style.treeArrowHeight * self.scale;\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.fillStyle = self.style.treeArrowColor;\r\n            self.ctx.strokeStyle = self.style.treeArrowBorderColor;\r\n            self.ctx.beginPath();\r\n            x = x + ml;\r\n            y = y + mt;\r\n            if (self.openChildren[cell.rowIndex]) {\r\n                self.ctx.moveTo(x, y);\r\n                self.ctx.lineTo(x + aw, y);\r\n                self.ctx.lineTo(x + (aw * 0.5), y + ah);\r\n                self.ctx.moveTo(x, y);\r\n            } else {\r\n                self.ctx.lineTo(x, y);\r\n                self.ctx.lineTo(x + ah, y + (aw * 0.5));\r\n                self.ctx.lineTo(x, y + aw);\r\n                self.ctx.lineTo(x, y);\r\n            }\r\n            self.ctx.stroke();\r\n            self.ctx.fill();\r\n            return ml + aw + mr;\r\n        }\r\n        function radiusRect(x, y, w, h, radius) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            var r = x + w, b = y + h;\r\n            self.ctx.beginPath();\r\n            self.ctx.moveTo(x + radius, y);\r\n            self.ctx.lineTo(r - radius, y);\r\n            self.ctx.quadraticCurveTo(r, y, r, y + radius);\r\n            self.ctx.lineTo(r, y + h - radius);\r\n            self.ctx.quadraticCurveTo(r, b, r - radius, b);\r\n            self.ctx.lineTo(x + radius, b);\r\n            self.ctx.quadraticCurveTo(x, b, x, b - radius);\r\n            self.ctx.lineTo(x, y + radius);\r\n            self.ctx.quadraticCurveTo(x, y, x + radius, y);\r\n        }\r\n        function fillRect(x, y, w, h) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.fillRect(x, y, w, h);\r\n        }\r\n        function strokeRect(x, y, w, h) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.strokeRect(x, y, w, h);\r\n        }\r\n        function fillText(text, x, y) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.fillText(text, x, y);\r\n        }\r\n        function fillCircle(x, y, r) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.beginPath();\r\n            self.ctx.arc(x, y, r, 0, 2 * Math.PI);\r\n            self.ctx.fill();\r\n        }\r\n        function strokeCircle(x, y, r) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.beginPath();\r\n            self.ctx.arc(x, y, r, 0, 2 * Math.PI);\r\n            self.ctx.stroke();\r\n        }\r\n        function clipFrozenArea(mode) {\r\n            // 0 both, 1 rows, 2 cols\r\n            // self.lastFrozenColumnPixel;\r\n            // self.lastFrozenRowPixel;\r\n            self.ctx.beginPath();\r\n            if (mode === 0) {\r\n                self.ctx.moveTo(self.lastFrozenColumnPixel, self.lastFrozenRowPixel);\r\n                self.ctx.lineTo(self.lastFrozenColumnPixel, self.height);\r\n                self.ctx.lineTo(self.width, self.height);\r\n                self.ctx.lineTo(self.width, self.lastFrozenRowPixel);\r\n            }\r\n            if (mode === 1) {\r\n                self.ctx.moveTo(0, self.lastFrozenRowPixel);\r\n                self.ctx.lineTo(0, self.height);\r\n                self.ctx.lineTo(self.width, self.height);\r\n                self.ctx.lineTo(self.width, self.lastFrozenRowPixel);\r\n            }\r\n            if (mode === 2) {\r\n                self.ctx.moveTo(self.lastFrozenColumnPixel, 0);\r\n                self.ctx.lineTo(self.width, 0);\r\n                self.ctx.lineTo(self.width, self.height);\r\n                self.ctx.lineTo(self.lastFrozenColumnPixel, self.height);\r\n            }\r\n            self.ctx.clip();\r\n        }\r\n        function fillHandle(x, y, r) {\r\n            if (self.style.selectionHandleType === 'circle') {\r\n                return fillCircle(x, y, r * 0.5);\r\n            }\r\n            fillRect(x - r * 0.5, y - r * 0.5, r, r);\r\n        }\r\n        function strokeHandle(x, y, r) {\r\n            if (self.style.selectionHandleType === 'circle') {\r\n                return strokeCircle(x, y, r * 0.5);\r\n            }\r\n            strokeRect(x - r * 0.5, y - r * 0.5, r, r);\r\n        }\r\n        function addselectionHandle(c, pos) {\r\n            var hw = self.style.selectionHandleSize,\r\n                p = {\r\n                    tr: function () {\r\n                        fillHandle(c.x + c.width, c.y, hw);\r\n                        strokeHandle(c.x + c.width, c.y, hw);\r\n                    },\r\n                    br: function () {\r\n                        fillHandle(c.x + c.width, c.y + c.height, hw);\r\n                        strokeHandle(c.x + c.width, c.y + c.height, hw);\r\n                    },\r\n                    tl: function () {\r\n                        fillHandle(c.x, c.y, hw);\r\n                        strokeHandle(c.x, c.y, hw);\r\n                    },\r\n                    bl: function () {\r\n                        fillHandle(c.x, c.y + c.height, hw);\r\n                        strokeHandle(c.x, c.y + c.height, hw);\r\n                    }\r\n                };\r\n            p[pos]();\r\n        }\r\n        function addBorderLine(c, pos) {\r\n            self.ctx.beginPath();\r\n            var p = {\r\n                t: function () {\r\n                    self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop);\r\n                    self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop);\r\n                },\r\n                r: function () {\r\n                    self.ctx.moveTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop);\r\n                    self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop + c.height);\r\n                },\r\n                b: function () {\r\n                    self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop + c.height);\r\n                    self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop + c.height);\r\n                },\r\n                l: function () {\r\n                    self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop);\r\n                    self.ctx.lineTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop + c.height);\r\n                }\r\n            };\r\n            p[pos]();\r\n            self.ctx.stroke();\r\n        }\r\n        function addEllipsis(text, width) {\r\n            var c, w = 0;\r\n            if (self.ellipsisCache[text] && self.ellipsisCache[text][width]) {\r\n                return self.ellipsisCache[text][width];\r\n            }\r\n            //TODO Add ellipsis back when there is a fast way to do it\r\n            w = self.ctx.measureText(text).width;\r\n            self.ellipsisCache[text] = self.ellipsisCache[text] || {};\r\n            c = {value: text, width: w};\r\n            self.ellipsisCache[text][width] = c;\r\n            return c;\r\n        }\r\n        function wrapText(cell, splitChar) {\r\n            if (!cell.formattedValue) {\r\n                return { lines: [{width: 0, value: ''}], width: 0, height: cell.calculatedLineHeight };\r\n            }\r\n            var max = 0,\r\n                n = '\\n',\r\n                x,\r\n                word,\r\n                words = cell.formattedValue.split(splitChar),\r\n                textHeight = cell.calculatedLineHeight,\r\n                lines = [],\r\n                out = [],\r\n                wrap = self.style.cellWhiteSpace !== 'nowrap',\r\n                elWidth,\r\n                et = self.attributes.ellipsisText,\r\n                elClipLength,\r\n                plWidth,\r\n                clippedVal,\r\n                ogWordWidth,\r\n                previousLine,\r\n                line = {\r\n                    width: 0,\r\n                    value: ''\r\n                },\r\n                cHeight = wrap ? cell.paddedHeight : cell.calculatedLineHeight;\r\n            lines.push(line);\r\n            elWidth = self.ctx.measureText(' ' + et).width;\r\n            for (x = 0; x < words.length; x += 1) {\r\n                word = words[x];\r\n                var measure = self.ctx.measureText(word + splitChar);\r\n                if (line.width + measure.width + elWidth < cell.paddedWidth) {\r\n                    line.value += word + splitChar;\r\n                    line.width += measure.width;\r\n                    continue;\r\n                }\r\n                // if there is a hyphenated word that is too long\r\n                // split it and add the split set to the array\r\n                // then back up and re-read new split set\r\n                // this behavior seems right, it might not be\r\n                if (/\\w-\\w/.test(word) && cell.paddedWidth < measure.width) {\r\n                    words.splice(x, 1, word.split('-')[0] + '-', word.split('-')[1]);\r\n                    x -= 1;\r\n                    continue;\r\n                }\r\n                line = {\r\n                    width: measure.width,\r\n                    value: word + splitChar\r\n                };\r\n                if (x === 0) {\r\n                    lines = [];\r\n                    lines.push(line);\r\n                }\r\n                textHeight += cell.calculatedLineHeight;\r\n                if (textHeight > cHeight) {\r\n                    if (lines.length === 0) { break; }\r\n                    elClipLength = 1;\r\n                    previousLine = lines[lines.length - 1];\r\n                    if (previousLine.width < cell.paddedWidth && words.length === 1) { break; }\r\n                    clippedVal = previousLine.value + word;\r\n                    plWidth = self.ctx.measureText(clippedVal + et).width;\r\n                    var originText = clippedVal;\r\n                    if (plWidth > cell.paddedWidth) {\r\n                        var stepLength = parseInt(clippedVal.length / 2);\r\n                        var direction = -1;\r\n                        while (stepLength > 0) {\r\n                            clippedVal = originText.substr(0, stepLength * direction + clippedVal.length);\r\n                            plWidth = self.ctx.measureText(clippedVal + et).width;\r\n                            direction = plWidth > cell.paddedWidth ? -1 : 1;\r\n                            stepLength = parseInt(stepLength / 2);\r\n                        }\r\n                    }\r\n                    clippedVal = clippedVal + (originText.length != clippedVal.length ? et : '');\r\n                    previousLine.value = clippedVal;\r\n                    previousLine.width = plWidth;\r\n                    break;\r\n                }\r\n                if (x > 0) {\r\n                    lines.push(line);\r\n                }\r\n            }\r\n            return {\r\n                lines: lines,\r\n                width: max,\r\n                height: cell.calculatedLineHeight * lines.length\r\n            }\r\n        }\r\n        function drawText(cell) {\r\n            var ll = cell.text.lines.length,\r\n                h = (cell.fontHeight * cell.lineHeight),\r\n                x,\r\n                line,\r\n                wrap = self.style.cellWhiteSpace !== 'nowrap',\r\n                textHeight = 0;\r\n            for (x = 0; x < cell.text.lines.length; x += 1) {\r\n                line = cell.text.lines[x];\r\n                var vPos = Math.max((cell.height - (wrap ? cell.text.height : cell.calculatedLineHeight)) * 0.5, 0) + h,\r\n                    hPos = cell.paddingLeft + cell.treeArrowWidth + cell.orderByArrowWidth;\r\n                if (cell.horizontalAlignment === 'right') {\r\n                    hPos = cell.paddingLeft + cell.paddedWidth - line.width;\r\n                } else if (cell.horizontalAlignment === 'center') {\r\n                    hPos = cell.paddingLeft + ((cell.paddedWidth + cell.paddingRight) / 2) - (line.width / 2);\r\n                }\r\n                if (cell.verticalAlignment === 'top') {\r\n                    vPos = cell.calculatedLineHeight;\r\n                } else if (cell.verticalAlignment === 'bottom') {\r\n                    vPos = cell.height - cell.paddingBottom - cell.text.height;\r\n                }\r\n                line.height = h + cell.lineSpacing;\r\n                line.offsetLeft = hPos;\r\n                line.offsetTop = vPos;\r\n                line.x = cell.x + hPos;\r\n                line.y = cell.y + textHeight + vPos;\r\n                textHeight += line.height;\r\n                fillText(line.value, line.x, line.y);\r\n            }\r\n            if (self.attributes.debug && cell.active) {\r\n                requestAnimationFrame(function () {\r\n                    self.ctx.font = self.style.debugFont;\r\n                    self.ctx.fillStyle = self.style.debugColor;\r\n                    fillText(JSON.stringify({\r\n                        x: cell.x,\r\n                        y: cell.y,\r\n                        h: cell.height,\r\n                        w: cell.width,\r\n                        pw: cell.paddedWidth,\r\n                        idx: cell.columnIndex,\r\n                        idx_ord: cell.sortColumnIndex\r\n                    }, null, '\\t'),\r\n                        cell.x + 14, cell.y + 14);\r\n                    fillText(JSON.stringify(cell.text.lines.map(function (l) { return {w: l.width, v: l.value.length }; }), null, '\\t'),\r\n                        cell.x + 14, cell.y + 30);\r\n                });\r\n            }\r\n        }\r\n        function getFrozenColumnsWidth() {\r\n            var w = 0,\r\n                s = self.getSchema(),\r\n                x = 0,\r\n                n = Math.min(self.frozenColumn, s.length),\r\n                column;\r\n            hiddenFrozenColumnCount = 0;\r\n            while (x < n) {\r\n                column = s[x];\r\n                if (column.hidden) {\r\n                    hiddenFrozenColumnCount += 1;\r\n                } else {\r\n                    w += self.getColummnWidth(x);\r\n                }\r\n                x += 1;\r\n            }\r\n            return w;\r\n        }\r\n        /**\r\n         * Redraws the grid. No matter what the change, this is the only method required to refresh everything.\r\n         * @memberof canvasDatagrid\r\n         * @name draw\r\n         * @method\r\n         */\r\n         // r = literal row index\r\n         // rd = row data array\r\n         // i = user order index\r\n         // o = literal data index\r\n         // y = y drawing cursor\r\n         // x = x drawing cursor\r\n         // s = visible schema array\r\n         // cx = current x drawing cursor sub calculation var\r\n         // cy = current y drawing cursor sub calculation var\r\n         // a = static cell (like corner cell)\r\n         // p = perf counter\r\n         // l = data length\r\n         // u = current cell\r\n         // h = current height\r\n         // w = current width\r\n        self.draw = function (internal) {\r\n            if (self.dispatchEvent('beforedraw', {})) { return; }\r\n            if (!self.isChildGrid && (!self.height || !self.width)) {\r\n                return;\r\n            }\r\n            if (self.isChildGrid && internal) {\r\n                requestAnimationFrame(self.parentGrid.draw);\r\n                return;\r\n            }\r\n            if (self.intf.visible === false) {\r\n                return;\r\n            }\r\n            // initial values\r\n            var checkScrollHeight, rowHeaderCell, p, cx, cy, treeGrid, rowOpen,\r\n                rowHeight, cornerCell, y, x, c, h, w, s, r, rd, aCell,\r\n                data = (self.data || []),\r\n                bc = self.style.gridBorderCollapse === 'collapse',\r\n                selectionBorders = [],\r\n                moveBorders = [],\r\n                selectionHandles = [],\r\n                rowHeaders = [],\r\n                l = data.length,\r\n                u = self.currentCell || {},\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n                rowHeaderCellWidth = self.getRowHeaderCellWidth(),\r\n                cellHeight = self.style.cellHeight;\r\n            drawCount += 1;\r\n            p = performance.now();\r\n            self.visibleRowHeights = [];\r\n            // if data length has changed, there is no way to know\r\n            if (data.length > self.orders.rows.length) {\r\n                self.createRowOrders();\r\n            }\r\n            function createHandlesOverlayArray(cell) {\r\n                if (self.attributes.allowMovingSelection || self.mobile) {\r\n                    if (cell.selectionBorderTop && cell.selectionBorderRight && self.mobile) {\r\n                        selectionHandles.push([cell, 'tr']);\r\n                        cell.selectionHandle = 'tr';\r\n                    }\r\n                    if (cell.selectionBorderTop && cell.selectionBorderLeft && self.mobile) {\r\n                        selectionHandles.push([cell, 'tl']);\r\n                        cell.selectionHandle = 'tl';\r\n                    }\r\n                    if (cell.selectionBorderBottom && cell.selectionBorderLeft && self.mobile) {\r\n                        selectionHandles.push([cell, 'bl']);\r\n                        cell.selectionHandle = 'bl';\r\n                    }\r\n                    if (cell.selectionBorderBottom && cell.selectionBorderRight\r\n                            && (self.attributes.selectionHandleBehavior !== 'none' || self.mobile)) {\r\n                        selectionHandles.push([cell, 'br']);\r\n                        cell.selectionHandle = 'br';\r\n                    }\r\n                }\r\n            }\r\n            function createBorderOverlayArray(cell, drawArray, propPrefix, offsetPoint) {\r\n                offsetPoint = offsetPoint || {x: 0, y: 0};\r\n                cell.selectionBorder = '';\r\n                if (!cell.isRowHeader\r\n                        && self.selections[cell.rowIndex + -offsetPoint.y]\r\n                        && self.selections[cell.rowIndex + -offsetPoint.y].indexOf(cell.columnIndex + -offsetPoint.x) !== -1) {\r\n                    if ((!self.selections[cell.rowIndex - 1 + -offsetPoint.y]\r\n                            || self.selections[cell.rowIndex - 1 + -offsetPoint.y].indexOf(cell.columnIndex + -offsetPoint.x) === -1\r\n                            || cell.rowIndex === 0)\r\n                            && !cell.isHeader) {\r\n                        drawArray.push([cell, 't']);\r\n                        cell[propPrefix + 'BorderTop'] = true;\r\n                        cell[propPrefix + 'Border'] += 't';\r\n                    }\r\n                    if (!self.selections[cell.rowIndex + 1 + -offsetPoint.y]\r\n                            || self.selections[cell.rowIndex + 1 + -offsetPoint.y].indexOf(cell.columnIndex + -offsetPoint.x) === -1) {\r\n                        drawArray.push([cell, 'b']);\r\n                        cell[propPrefix + 'BorderBottom'] = true;\r\n                        cell[propPrefix + 'Border'] += 'b';\r\n                    }\r\n                    if (!self.selections[cell.rowIndex + -offsetPoint.y] || cell.columnIndex === 0\r\n                            || self.selections[cell.rowIndex + -offsetPoint.y].indexOf(cell.columnIndex - 1 + -offsetPoint.x) === -1) {\r\n                        drawArray.push([cell, 'l']);\r\n                        cell[propPrefix + 'BorderLeft'] = true;\r\n                        cell[propPrefix + 'Border'] += 'l';\r\n                    }\r\n                    if (!self.selections[cell.rowIndex + -offsetPoint.y] || cell.columnIndex === s.length\r\n                            || self.selections[cell.rowIndex + -offsetPoint.y].indexOf(cell.columnIndex + 1 + -offsetPoint.x) === -1) {\r\n                        drawArray.push([cell, 'r']);\r\n                        cell[propPrefix + 'BorderRight'] = true;\r\n                        cell[propPrefix + 'Border'] += 'r';\r\n                    }\r\n                }\r\n            }\r\n            function drawCell(d, rowOrderIndex, rowIndex) {\r\n                return function drawEach(header, headerIndex, columnOrderIndex) {\r\n                    if (header.hidden) { return 0; }\r\n                    var cellStyle = header.style || 'cell',\r\n                        cellGridAttributes,\r\n                        cell,\r\n                        isHeader = /HeaderCell/.test(cellStyle),\r\n                        isCorner = /cornerCell/.test(cellStyle),\r\n                        isRowHeader = 'rowHeaderCell' === cellStyle,\r\n                        isColumnHeader = 'columnHeaderCell' === cellStyle,\r\n                        selected = self.selections[rowOrderIndex] && self.selections[rowOrderIndex].indexOf(columnOrderIndex) !== -1,\r\n                        hovered = self.hovers.rowIndex === rowOrderIndex && self.hovers.columnIndex === columnOrderIndex,\r\n                        active = self.activeCell.rowIndex === rowOrderIndex && self.activeCell.columnIndex === columnOrderIndex,\r\n                        isColumnHeaderCellCap = cellStyle === 'columnHeaderCellCap',\r\n                        rawValue = d ? d[header.name] : undefined,\r\n                        isGrid = header.type === 'canvas-datagrid',\r\n                        activeHeader = (self.orders.rows[self.activeCell.rowIndex] === rowOrderIndex\r\n                                || self.orders.columns[self.activeCell.columnIndex] === headerIndex)\r\n                            && (columnOrderIndex === -1 || rowOrderIndex === -1)\r\n                            ? (isRowHeader ? 'activeRowHeaderCell' : 'activeColumnHeaderCell') : false,\r\n                        val,\r\n                        f = self.formatters[header.type || 'string'],\r\n                        orderByArrowSize = 0,\r\n                        treeArrowSize = 0,\r\n                        cellWidth = self.sizes.columns[headerIndex] || header.width,\r\n                        ev = {\r\n                            value: rawValue,\r\n                            row: d,\r\n                            header: header\r\n                        };\r\n                    if (isColumnHeaderCellCap) {\r\n                        cellWidth = w - x;\r\n                    }\r\n                    // if no data or schema are defined, a width is provided to the stub column\r\n                    if (cellWidth === undefined) {\r\n                        cellWidth = self.style.cellWidth;\r\n                    }\r\n                    cellWidth = cellWidth * self.scale;\r\n                    if (x + cellWidth + self.style.cellBorderWidth < 0) {\r\n                        x += cellWidth + self.style.cellBorderWidth;\r\n                    }\r\n                    if (active && cellStyle !== 'cornerCell') {\r\n                        cellStyle = 'activeCell';\r\n                    }\r\n                    if (self.visibleRows.indexOf(rowIndex) === -1 && !isHeader) {\r\n                        self.visibleRows.push(rowIndex);\r\n                    }\r\n                    val = self.dispatchEvent('formatcellvalue', ev);\r\n                    cx = x;\r\n                    cy = y;\r\n                    if (cellStyle === 'cornerCell') {\r\n                        cx = 0;\r\n                        cy = 0;\r\n                    } else if (isRowHeader) {\r\n                        cx = 0;\r\n                    } else if (isHeader) {\r\n                        cy = 0;\r\n                    }\r\n                    cell = {\r\n                        type: isGrid ? 'canvas-datagrid-cell' : header.type,\r\n                        style: cellStyle,\r\n                        nodeType: 'canvas-datagrid-cell',\r\n                        x: cx,\r\n                        y: cy,\r\n                        fontHeight: (self.style[cellStyle + 'FontHeight'] || 0) * self.scale,\r\n                        horizontalAlignment: self.style[cellStyle + 'HorizontalAlignment'],\r\n                        verticalAlignment: self.style[cellStyle + 'VerticalAlignment'],\r\n                        paddingLeft: (self.style[cellStyle + 'PaddingLeft'] || 0) * self.scale,\r\n                        paddingTop: (self.style[cellStyle + 'PaddingTop'] || 0) * self.scale,\r\n                        paddingRight: (self.style[cellStyle + 'PaddingRight'] || 0) * self.scale,\r\n                        paddingBottom: (self.style[cellStyle + 'PaddingBottom'] || 0) * self.scale,\r\n                        whiteSpace: self.style.cellWhiteSpace,\r\n                        lineHeight: self.style.cellLineHeight,\r\n                        lineSpacing: self.style.cellLineSpacing,\r\n                        offsetTop: self.canvasOffsetTop + cy,\r\n                        offsetLeft: self.canvasOffsetLeft + cx,\r\n                        scrollTop: self.scrollBox.scrollTop,\r\n                        scrollLeft: self.scrollBox.scrollLeft,\r\n                        active: active || activeHeader,\r\n                        hovered: hovered,\r\n                        selected: selected,\r\n                        width: cellWidth,\r\n                        height: cellHeight,\r\n                        offsetWidth: cellWidth,\r\n                        offsetHeight: cellHeight,\r\n                        parentNode: self.intf.parentNode,\r\n                        offsetParent: self.intf.parentNode,\r\n                        data: d,\r\n                        isCorner: isCorner,\r\n                        isHeader: isHeader,\r\n                        isColumnHeader: isColumnHeader,\r\n                        isColumnHeaderCellCap: isColumnHeaderCellCap,\r\n                        isRowHeader: isRowHeader,\r\n                        rowOpen: rowOpen,\r\n                        header: header,\r\n                        columnIndex: columnOrderIndex,\r\n                        rowIndex: rowOrderIndex,\r\n                        sortColumnIndex: headerIndex,\r\n                        sortRowIndex: rowIndex,\r\n                        isGrid: isGrid,\r\n                        isNormal: !isGrid && !isCorner && !isHeader,\r\n                        gridId: (self.attributes.name || '') + rowIndex + ':' + headerIndex,\r\n                        parentGrid: self.intf,\r\n                        innerHTML: '',\r\n                        activeHeader: activeHeader,\r\n                        value: isHeader && !isRowHeader ? (header.title || header.name) : rawValue\r\n                    };\r\n                    cell.calculatedLineHeight = (cell.fontHeight * cell.lineHeight) + cell.lineSpacing;\r\n                    cell.paddedWidth = cell.width - cell.paddingRight - cell.paddingLeft;\r\n                    cell.paddedHeight = cell.height - cell.paddingTop - cell.paddingBottom;\r\n                    ev.cell = cell;\r\n                    cell.userHeight = cell.isHeader ? self.sizes.rows[-1] : rowHeight;\r\n                    cell.userWidth = cell.isHeader ? self.sizes.columns.cornerCell : self.sizes.columns[headerIndex];\r\n                    self.visibleCells.unshift(cell);\r\n                    if (self.dispatchEvent('beforerendercell', ev)) { return; }\r\n                    self.ctx.fillStyle = self.style[cellStyle + 'BackgroundColor'];\r\n                    self.ctx.strokeStyle = self.style[cellStyle + 'BorderColor'];\r\n                    self.ctx.lineWidth = self.style[cellStyle + 'BorderWidth'];\r\n                    if (hovered) {\r\n                        self.ctx.fillStyle = self.style[cellStyle + 'HoverBackgroundColor'];\r\n                        self.ctx.strokeStyle = self.style[cellStyle + 'HoverBorderColor'];\r\n                    }\r\n                    if (selected) {\r\n                        self.ctx.fillStyle = self.style[cellStyle + 'SelectedBackgroundColor'];\r\n                        self.ctx.strokeStyle = self.style[cellStyle + 'SelectedBorderColor'];\r\n                    }\r\n                    if (activeHeader) {\r\n                        self.ctx.fillStyle = self.style[activeHeader + 'BackgroundColor'];\r\n                    }\r\n                    self.dispatchEvent('rendercell', ev);\r\n                    if (cell.isGrid) {\r\n                        if (cell.height !== rowHeight) {\r\n                            cell.height = rowHeight || self.style.cellHeightWithChildGrid;\r\n                            checkScrollHeight = true;\r\n                        }\r\n                        cell.width = self.sizes.columns[headerIndex] || self.style.cellWidthWithChildGrid;\r\n                    }\r\n                    if (rowOpen && !cell.isRowHeader) {\r\n                        cell.height = self.sizes.rows[rowIndex] || self.style.cellHeight;\r\n                    }\r\n                    if (!cell.isGrid) {\r\n                        fillRect(cx, cy, cell.width, cell.height);\r\n                        strokeRect(cx, cy, cell.width, cell.height);\r\n                    }\r\n                    self.ctx.save();\r\n                    radiusRect(cell.x, cell.y, cell.width, cell.height, 0);\r\n                    self.ctx.clip();\r\n                    self.dispatchEvent('afterrendercell', ev);\r\n                    if (cell.height !== cellHeight && !(rowOpen && !cell.isRowHeader)) {\r\n                        self.sizes.rows[isHeader ? -1 : rowIndex] = cell.height;\r\n                        checkScrollHeight = true;\r\n                    }\r\n                    if (cell.width !== cellWidth) {\r\n                        self.sizes.columns[headerIndex] = cell.width;\r\n                        checkScrollHeight = true;\r\n                    }\r\n                    if (isRowHeader && self.attributes.tree) {\r\n                        if (!self.dispatchEvent('rendertreearrow', ev)) {\r\n                            treeArrowSize = drawTreeArrow(cell, self.style[cellStyle + 'PaddingLeft'], cy, 0);\r\n                        }\r\n                    }\r\n                    if ((self.attributes.showRowNumbers && isRowHeader)\r\n                            || !isRowHeader) {\r\n                        if (cell.isGrid && !self.dispatchEvent('beforerendercellgrid', ev)) {\r\n                            if (!self.childGrids[cell.gridId]) {\r\n                                // HACK: this only allows setting of the child grids styles if data is set _after_\r\n                                // this is less than desirable.  An interface needs to be made to effect the\r\n                                // style of all cell grids.  One for individual grids already exists.\r\n                                cellGridAttributes = self.cellGridAttributes;\r\n                                cellGridAttributes.name = self.attributes.saveAppearance ? cell.gridId : undefined;\r\n                                cellGridAttributes.component = false;\r\n                                cellGridAttributes.parentNode = cell;\r\n                                cellGridAttributes.data = rawValue;\r\n                                ev.cellGridAttributes = cellGridAttributes;\r\n                                if (self.dispatchEvent('beforecreatecellgrid', ev)) { return; }\r\n                                self.childGrids[cell.gridId] = self.createGrid(cellGridAttributes);\r\n                                self.sizes.rows[rowIndex]\r\n                                    = self.sizes.rows[rowIndex] || self.style.cellGridHeight;\r\n                                checkScrollHeight = true;\r\n                            }\r\n                            cell.grid = self.childGrids[cell.gridId];\r\n                            cell.grid.parentNode = cell;\r\n                            cell.grid.visible = true;\r\n                            cell.grid.draw();\r\n                            self.dispatchEvent('rendercellgrid', ev);\r\n                        } else if (!cell.isGrid) {\r\n                            if (self.childGrids[cell.gridId]) {\r\n                                self.childGrids[cell.gridId].parentNode.offsetHeight = 0;\r\n                            }\r\n                            if (isHeader && self.orderBy === header.name) {\r\n                                if (!self.dispatchEvent('renderorderbyarrow', ev)) {\r\n                                    orderByArrowSize = drawOrderByArrow(cx + self.style[cellStyle + 'PaddingLeft'], 0);\r\n                                }\r\n                            }\r\n                            self.ctx.fillStyle = self.style[cellStyle + 'Color'];\r\n                            if (hovered) {\r\n                                self.ctx.fillStyle = self.style[cellStyle + 'HoverColor'];\r\n                            }\r\n                            if (selected) {\r\n                                self.ctx.fillStyle = self.style[cellStyle + 'SelectedColor'];\r\n                            }\r\n                            if (activeHeader) {\r\n                                self.ctx.fillStyle = self.style[activeHeader + 'Color'];\r\n                            }\r\n                            cell.treeArrowWidth = treeArrowSize;\r\n                            cell.orderByArrowWidth = orderByArrowSize;\r\n                            // create text ref to see if height needs to expand\r\n                            val = val !== undefined ? val : f\r\n                                ? f(ev) : '';\r\n                            if (val === undefined && !f) {\r\n                                val = '';\r\n                                console.warn('canvas-datagrid: Unknown format '\r\n                                    + header.type + ' add a cellFormater');\r\n                            }\r\n                            cell.formattedValue = ((val !== undefined && val !== null) ? val : '').toString();\r\n                            if (self.columnFilters && self.columnFilters[val] !== undefined && isHeader) {\r\n                                cell.formattedValue = self.attributes.filterTextPrefix + val;\r\n                            }\r\n                            self.ctx.font = (self.style[cellStyle + 'FontHeight'] * self.scale) + 'px ' + self.style[cellStyle + 'FontName'];\r\n                            if (!self.dispatchEvent('formattext', ev)) {\r\n                                cell.text = wrapText(cell, ' ');\r\n                            }\r\n                            if (!self.dispatchEvent('rendertext', ev)) {\r\n                                if (cell.innerHTML || header.type === 'html') {\r\n                                    drawHtml(cell);\r\n                                } else {\r\n                                    drawText(cell);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (active) {\r\n                        aCell = cell;\r\n                    }\r\n                    createBorderOverlayArray(cell, selectionBorders, 'selection');\r\n                    // createBorderOverlayArray calculates data for createHandlesOverlayArray so it must go 2nd\r\n                    createHandlesOverlayArray(cell);\r\n                    if (self.movingSelection) {\r\n                        createBorderOverlayArray(cell, moveBorders, 'move', self.moveOffset);\r\n                    }\r\n                    self.ctx.restore();\r\n                    x += cell.width + (bc ? 0 : self.style.cellBorderWidth);\r\n                    return cell.width;\r\n                };\r\n            }\r\n            function drawRowHeader(rowData, index, rowOrderIndex) {\r\n                var a, i;\r\n                if (self.attributes.showRowHeaders) {\r\n                    x = 0;\r\n                    i = index + 1;\r\n                    rowHeaderCell = {'rowHeaderCell': i };\r\n                    a = {\r\n                        name: 'rowHeaderCell',\r\n                        width: self.sizes.columns[-1] || self.style.rowHeaderCellWidth,\r\n                        style: 'rowHeaderCell',\r\n                        type: 'string',\r\n                        data: i,\r\n                        index: -1\r\n                    };\r\n                    rowOpen = self.openChildren[index];\r\n                    drawCell(rowHeaderCell, index, rowOrderIndex)(a, -1, -1);\r\n                }\r\n            }\r\n            function drawHeaders() {\r\n                var d, g = s.length, i, o, columnHeaderCell, header, nonFrozenHeaderWidth;\r\n                function drawHeaderColumnRange(start, end) {\r\n                    end = Math.min(end, g);\r\n                    for (o = start; o < end; o += 1) {\r\n                        i = self.orders.columns[o];\r\n                        header = s[i];\r\n                        if (!header.hidden) {\r\n                            d = {\r\n                                title: header.title,\r\n                                name: header.name,\r\n                                width: header.width || self.style.cellWidth,\r\n                                style: 'columnHeaderCell',\r\n                                type: 'string',\r\n                                index: o,\r\n                                order: i\r\n                            };\r\n                            columnHeaderCell = {'columnHeaderCell': header.title || header.name};\r\n                            x += drawCell(columnHeaderCell, -1, -1)(d, i, o);\r\n                            if (x > self.width + self.scrollBox.scrollLeft) {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                rowHeaders.forEach(function (rArgs, rhIndex) {\r\n                    y = rArgs[3];\r\n                    cellHeight = rArgs[4];\r\n                    if (rhIndex === self.frozenRow) {\r\n                        self.ctx.save();\r\n                        radiusRect(0, self.lastFrozenRowPixel, self.width, self.height - self.lastFrozenRowPixel, 0);\r\n                        self.ctx.clip();\r\n                    }\r\n                    drawRowHeader(rArgs[0], rArgs[1], rArgs[2]);\r\n                });\r\n                self.ctx.restore();\r\n                if (self.attributes.showColumnHeaders) {\r\n                    x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.columnHeaderCellBorderWidth;\r\n                    if (self.attributes.showRowHeaders) {\r\n                        x += rowHeaderCellWidth;\r\n                    }\r\n                    y = 0;\r\n                    // cell height might have changed during drawing\r\n                    cellHeight = self.getColumnHeaderCellHeight();\r\n                    drawHeaderColumnRange(self.scrollIndexLeft, g);\r\n                    nonFrozenHeaderWidth = x;\r\n                    x = self.style.columnHeaderCellBorderWidth;\r\n                    if (self.attributes.showRowHeaders) {\r\n                        x += rowHeaderCellWidth;\r\n                    }\r\n                    drawHeaderColumnRange(0, self.frozenColumn);\r\n                    // fill in the space right of the headers\r\n                    x = nonFrozenHeaderWidth;\r\n                    if (x < w) {\r\n                        c = {\r\n                            name: '',\r\n                            width: self.style.scrollBarWidth,\r\n                            style: 'columnHeaderCellCap',\r\n                            isColumnHeaderCell: true,\r\n                            isColumnHeaderCellCap: true,\r\n                            type: 'string',\r\n                            index: s.length\r\n                        };\r\n                        drawCell({endCap: ''}, -1, -1)(c, -1, -1);\r\n                    }\r\n                    // fill in the space right of the headers\r\n                    if (self.attributes.showRowHeaders) {\r\n                        cornerCell = {'cornerCell': '' };\r\n                        x = 0;\r\n                        c = {\r\n                            name: 'cornerCell',\r\n                            width: self.style.rowHeaderCellWidth,\r\n                            style: 'cornerCell',\r\n                            type: 'string',\r\n                            index: -1\r\n                        };\r\n                        drawCell(cornerCell, -1, -1)(c, -1, -1);\r\n                    }\r\n                }\r\n            }\r\n            function drawRow(r, d) {\r\n                var i, treeHeight, rowSansTreeHeight, o, g = s.length;\r\n                if (y - (cellHeight * 2) > h) {\r\n                    return false;\r\n                }\r\n                rd = data[r];\r\n                rowOpen = self.openChildren[r];\r\n                rowSansTreeHeight = (self.sizes.rows[r] || self.style.cellHeight) * self.scale;\r\n                treeHeight = (rowOpen ? self.sizes.trees[r] : 0) * self.scale;\r\n                rowHeight = (rowSansTreeHeight + treeHeight);\r\n                if (y < -rowHeight) {\r\n                    return false;\r\n                }\r\n                if (self.attributes.showRowHeaders) {\r\n                    x += rowHeaderCellWidth;\r\n                }\r\n                cellHeight = rowHeight;\r\n                //draw normal columns\r\n                for (o = (self.scrollIndexLeft); o < g; o += 1) {\r\n                    i = self.orders.columns[o];\r\n                    x += drawCell(rd, r, d)(s[i], i, o);\r\n                    if (x > self.width) {\r\n                        self.scrollIndexRight = o;\r\n                        self.scrollPixelRight = x;\r\n                        break;\r\n                    }\r\n                }\r\n                //draw frozen columns\r\n                x = 0;\r\n                if (self.attributes.showRowHeaders) {\r\n                    x += rowHeaderCellWidth;\r\n                }\r\n                for (o = 0; o < self.frozenColumn; o += 1) {\r\n                    i = self.orders.columns[o];\r\n                    x += drawCell(rd, r, d)(s[i], i, o);\r\n                    if (x > self.width) {\r\n                        break;\r\n                    }\r\n                }\r\n                self.lastFrozenColumnPixel = x;\r\n                // cell height might have changed during drawing\r\n                cellHeight = rowHeight;\r\n                x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.cellBorderWidth;\r\n                // don't draw a tree for the new row\r\n                treeGrid = self.childGrids[r];\r\n                if (r !== data.length && rowOpen) {\r\n                    treeGrid.visible = true;\r\n                    treeGrid.parentNode = {\r\n                        offsetTop: y + rowSansTreeHeight + self.canvasOffsetTop,\r\n                        offsetLeft: rowHeaderCellWidth - 1 + self.canvasOffsetLeft,\r\n                        offsetHeight: treeHeight,\r\n                        offsetWidth: self.width - rowHeaderCellWidth - self.style.scrollBarWidth - 1,\r\n                        offsetParent: self.intf.parentNode,\r\n                        parentNode: self.intf.parentNode,\r\n                        style: self.style,\r\n                        nodeType: 'canvas-datagrid-tree',\r\n                        scrollTop: self.scrollBox.scrollTop,\r\n                        scrollLeft: self.scrollBox.scrollLeft,\r\n                        rowIndex: r\r\n                    };\r\n                    self.visibleCells.unshift({\r\n                        rowIndex: r,\r\n                        columnIndex: 0,\r\n                        y: treeGrid.parentNode.offsetTop,\r\n                        x: treeGrid.parentNode.offsetLeft,\r\n                        height: treeGrid.height,\r\n                        width: treeGrid.width,\r\n                        style: 'tree-grid',\r\n                        type: treeGrid.parentNode.nodeType\r\n                    });\r\n                    treeGrid.draw();\r\n                } else if (treeGrid) {\r\n                    treeGrid.parentNode.offsetHeight = 0;\r\n                    delete self.sizes.trees[r];\r\n                }\r\n                rowHeaders.push([rd, r, d, y, rowHeight]);\r\n                self.visibleRowHeights[r] = rowHeight;\r\n                y += cellHeight + (bc ? 0 : self.style.cellBorderWidth);\r\n                return true;\r\n            }\r\n            function initDraw() {\r\n                self.visibleRows = [];\r\n                s = self.getSchema();\r\n                self.visibleCells = [];\r\n                self.canvasOffsetTop = self.isChildGrid ? self.parentNode.offsetTop : 0;\r\n                self.canvasOffsetLeft = self.isChildGrid ? self.parentNode.offsetLeft : 0;\r\n                h = self.height;\r\n                w = self.width;\r\n            }\r\n            function drawBackground() {\r\n                radiusRect(0, 0, w, h, 0);\r\n                self.ctx.clip();\r\n                self.ctx.fillStyle = self.style.gridBackgroundColor;\r\n                fillRect(0, 0, w, h);\r\n            }\r\n            function drawFrozenRows() {\r\n                var n, ln = Math.min(data.length, self.frozenRow);\r\n                x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.cellBorderWidth;\r\n                y = columnHeaderCellHeight;\r\n                for (r = 0; r < ln; r += 1) {\r\n                    n = self.orders.rows[r];\r\n                    if (!drawRow(n, r)) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (self.attributes.allowFreezingRows) {\r\n                    // HACK great, another stupid magic number.\r\n                    // Background will appear as a 0.5px artifact behind the row freeze bar without this hack\r\n                    y += self.style.frozenMarkerBorderWidth + self.style.frozenMarkerWidth - 0.4999999999;\r\n                }\r\n                self.lastFrozenRowPixel = y;\r\n            }\r\n            function drawRows() {\r\n                self.ctx.save();\r\n                if (self.frozenRow > 0) {\r\n                    radiusRect(0, self.lastFrozenRowPixel, self.width, self.height - self.lastFrozenRowPixel, 0);\r\n                    self.ctx.clip();\r\n                }\r\n                var o, n, i, g = s.length;\r\n                x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.cellBorderWidth;\r\n                if (!self.attributes.snapToRow) {\r\n                    y += -self.scrollBox.scrollTop + self.scrollPixelTop + self.style.cellBorderWidth;\r\n                }\r\n                for (r = self.frozenRow + self.scrollIndexTop; r < l; r += 1) {\r\n                    n = self.orders.rows[r];\r\n                    self.scrollIndexBottom = r;\r\n                    self.scrollPixelBottom = y;\r\n                    if (!drawRow(n, r)) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (self.attributes.showNewRow) {\r\n                    if (self.attributes.showRowHeaders) {\r\n                        x += rowHeaderCellWidth;\r\n                    }\r\n                    rowHeight = cellHeight = self.style.cellHeight;\r\n                    rowOpen = false;\r\n                    for (o = self.scrollIndexLeft; o < g; o += 1) {\r\n                        i = self.orders.columns[o];\r\n                        x += drawCell(self.newRow, data.length, data.length)(s[i], i, o);\r\n                        if (x > self.width + self.scrollBox.scrollLeft) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    rowHeaders.push([self.newRow, data.length, data.length, y, rowHeight]);\r\n                }\r\n                self.ctx.restore();\r\n            }\r\n            function drawMoveMarkers() {\r\n                if (!self.movingSelection) { return; }\r\n                self.ctx.lineWidth = self.style.moveOverlayBorderWidth;\r\n                self.ctx.strokeStyle = self.style.moveOverlayBorderColor;\r\n                self.ctx.setLineDash(self.style.moveOverlayBorderSegments);\r\n                moveBorders.forEach(function (c) {\r\n                    addBorderLine(c[0], c[1]);\r\n                });\r\n                self.ctx.setLineDash([]);\r\n            }\r\n            function drawReorderMarkers() {\r\n                if (!self.reorderObject) { return; }\r\n                var b = {\r\n                        height: self.reorderObject.height,\r\n                        width: self.reorderObject.width,\r\n                        x: self.reorderObject.x + self.reorderObject.dragOffset.x,\r\n                        y: self.reorderObject.y + self.reorderObject.dragOffset.y\r\n                    },\r\n                    m = {\r\n                        width: w,\r\n                        height: h,\r\n                        x: 0,\r\n                        y: 0\r\n                    };\r\n                self.ctx.fillStyle = self.style.reorderMarkerBackgroundColor;\r\n                self.ctx.lineWidth = self.style.reorderMarkerBorderWidth;\r\n                self.ctx.strokeStyle = self.style.reorderMarkerBorderColor;\r\n                if (self.dragMode === 'row-reorder') {\r\n                    b.width = w;\r\n                    b.x = 0;\r\n                    m.width = w;\r\n                    m.height = self.currentCell.height;\r\n                    m.y = self.currentCell.y;\r\n                    fillRect(b.x, b.y, b.width, b.height);\r\n                    strokeRect(b.x, b.y, b.width, b.height);\r\n                    self.ctx.lineWidth = self.style.reorderMarkerIndexBorderWidth;\r\n                    self.ctx.strokeStyle = self.style.reorderMarkerIndexBorderColor;\r\n                    if (self.currentCell.rowIndex !== self.reorderObject.rowIndex\r\n                            && self.currentCell.rowIndex > -1\r\n                            && self.currentCell.rowIndex < l) {\r\n                        addBorderLine(m, self.reorderTarget.sortRowIndex > self.reorderObject.sortRowIndex ? 'b' : 't');\r\n                    }\r\n                } else if (self.dragMode === 'column-reorder' && self.reorderObject) {\r\n                    b.height = h;\r\n                    b.y = 0;\r\n                    m.height = h;\r\n                    m.width = self.currentCell.width;\r\n                    m.y = 0;\r\n                    m.x = self.currentCell.x;\r\n                    fillRect(b.x, b.y, b.width, b.height);\r\n                    strokeRect(b.x, b.y, b.width, b.height);\r\n                    self.ctx.lineWidth = self.style.reorderMarkerIndexBorderWidth;\r\n                    self.ctx.strokeStyle = self.style.reorderMarkerIndexBorderColor;\r\n                    if (self.currentCell.sortColumnIndex !== self.reorderObject.sortColumnIndex\r\n                            && self.currentCell.sortColumnIndex > -1\r\n                            && self.currentCell.sortColumnIndex < s.length) {\r\n                        addBorderLine(m, self.reorderTarget.columnIndex > self.reorderObject.columnIndex ? 'r' : 'l');\r\n                    }\r\n                }\r\n            }\r\n            function drawBorder() {\r\n                self.ctx.lineWidth = self.style.gridBorderWidth;\r\n                self.ctx.strokeStyle = self.style.gridBorderColor;\r\n                strokeRect(0, 0, self.width, self.height);\r\n            }\r\n            function drawSelectionBorders() {\r\n                self.ctx.lineWidth = self.style.selectionOverlayBorderWidth;\r\n                self.ctx.strokeStyle = self.style.selectionOverlayBorderColor;\r\n                function dsb(c) {\r\n                    addBorderLine(c[0], c[1]);\r\n                }\r\n                selectionBorders.filter(function (c) {\r\n                    return c[0].rowIndex < self.frozenRow && c[0].columnIndex < self.frozenColumn;\r\n                }).forEach(dsb);\r\n                self.ctx.save();\r\n                clipFrozenArea(0);\r\n                selectionBorders.filter(function (c) {\r\n                    return c[0].rowIndex >= self.frozenRow && c[0].columnIndex >= self.frozenColumn;\r\n                }).forEach(dsb);\r\n                self.ctx.restore();\r\n                self.ctx.save();\r\n                clipFrozenArea(1);\r\n                selectionBorders.filter(function (c) {\r\n                    return c[0].rowIndex >= self.frozenRow && c[0].columnIndex < self.frozenColumn;\r\n                }).forEach(dsb);\r\n                self.ctx.restore();\r\n                self.ctx.save();\r\n                clipFrozenArea(2);\r\n                selectionBorders.filter(function (c) {\r\n                    return c[0].rowIndex < self.frozenRow && c[0].columnIndex >= self.frozenColumn;\r\n                }).forEach(dsb);\r\n                self.ctx.restore();\r\n            }\r\n            function drawSelectionHandles() {\r\n                if (self.mobile || self.attributes.allowMovingSelection) {\r\n                    self.ctx.lineWidth = self.style.selectionHandleBorderWidth;\r\n                    self.ctx.strokeStyle = self.style.selectionHandleBorderColor;\r\n                    self.ctx.fillStyle = self.style.selectionHandleColor;\r\n                    selectionHandles.forEach(function (c) {\r\n                        addselectionHandle(c[0], c[1]);\r\n                        var az = self.attributes.touchSelectHandleZone / 2,\r\n                            ax = c[0].x + (c[1] === 'tl' || c[1] === 'bl' ? 0 : c[0].width) - az,\r\n                            ay = c[0].y + (c[1] === 'bl' || c[1] === 'br' ? c[0].height : 0) - az;\r\n                        self.visibleCells.unshift({\r\n                            x: ax,\r\n                            y: ay,\r\n                            height: self.style.selectionHandleSize + az,\r\n                            width: self.style.selectionHandleSize + az,\r\n                            style: 'selection-handle-' + c[1]\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n            function drawActiveCell() {\r\n                if (!aCell) { return; }\r\n                self.ctx.save();\r\n                var cl = self.activeCell.columnIndex + 1 > self.frozenColumn || self.activeCell.rowIndex + 1 > self.frozenRow,\r\n                    acx = cl ? self.lastFrozenColumnPixel : 0,\r\n                    acy = cl ? self.lastFrozenRowPixel : 0,\r\n                    acw = cl ? self.width - self.lastFrozenColumnPixel : self.width,\r\n                    ach = cl ? self.height - self.lastFrozenRowPixel : self.height;\r\n                radiusRect(acx, acy, acw, ach, 0);\r\n                self.ctx.clip();\r\n                if (self.attributes.selectionMode === 'row') {\r\n                    if (self.activeCell && self.activeCell.rowIndex === aCell.rowIndex) {\r\n                        self.ctx.lineWidth = self.style.activeCellOverlayBorderWidth;\r\n                        self.ctx.strokeStyle = self.style.activeCellOverlayBorderColor;\r\n                        strokeRect(0, aCell.y, self.getHeaderWidth() + rowHeaderCellWidth, self.visibleRowHeights[aCell.rowIndex]);\r\n                    }\r\n                } else {\r\n                    self.ctx.lineWidth = self.style.activeCellOverlayBorderWidth;\r\n                    self.ctx.strokeStyle = self.style.activeCellOverlayBorderColor;\r\n                    strokeRect(aCell.x, aCell.y, aCell.width, aCell.height);\r\n                }\r\n                self.ctx.restore();\r\n            }\r\n            function drawFrozenMarkers() {\r\n                var my = self.lastFrozenRowPixel - self.style.frozenMarkerWidth,\r\n                    mx = self.lastFrozenColumnPixel - self.style.frozenMarkerBorderWidth,\r\n                    xHover = self.currentCell && self.currentCell.style === 'frozen-row-marker',\r\n                    yHover = self.currentCell && self.currentCell.style === 'frozen-column-marker';\r\n                self.ctx.lineWidth = self.style.frozenMarkerBorderWidth;\r\n                if (self.attributes.allowFreezingColumns) {\r\n                    self.ctx.fillStyle = yHover ? self.style.frozenMarkerHoverColor : self.style.frozenMarkerColor;\r\n                    self.ctx.strokeStyle = yHover ? self.style.frozenMarkerHoverBorderColor : self.style.frozenMarkerBorderColor;\r\n                    fillRect(mx, 0, self.style.frozenMarkerWidth, self.height);\r\n                    strokeRect(mx, 0, self.style.frozenMarkerWidth, self.height);\r\n                    self.visibleCells.unshift({\r\n                        x: mx,\r\n                        y: 0,\r\n                        height: self.height,\r\n                        width: self.style.frozenMarkerWidth + self.style.frozenMarkerBorderWidth,\r\n                        style: 'frozen-column-marker'\r\n                    });\r\n                }\r\n                if (self.attributes.allowFreezingRows) {\r\n                    self.ctx.fillStyle = xHover ? self.style.frozenMarkerHoverColor : self.style.frozenMarkerColor;\r\n                    self.ctx.strokeStyle = xHover ? self.style.frozenMarkerHoverBorderColor : self.style.frozenMarkerBorderColor;\r\n                    fillRect(0, my, self.width, self.style.frozenMarkerWidth);\r\n                    strokeRect(0, my, self.width, self.style.frozenMarkerWidth);\r\n                    self.visibleCells.unshift({\r\n                        x: 0,\r\n                        y: my,\r\n                        height: self.style.frozenMarkerWidth + self.style.frozenMarkerBorderWidth,\r\n                        width: self.width,\r\n                        style: 'frozen-row-marker'\r\n                    });\r\n                }\r\n                if (self.freezeMarkerPosition) {\r\n                    self.ctx.fillStyle = self.style.frozenMarkerActiveColor;\r\n                    self.ctx.strokeStyle = self.style.frozenMarkerActiveBorderColor;\r\n                    if (self.dragMode === 'frozen-column-marker') {\r\n                        fillRect(self.freezeMarkerPosition.x, 0, self.style.frozenMarkerWidth, self.height);\r\n                        strokeRect(self.freezeMarkerPosition.x, 0, self.style.frozenMarkerWidth, self.height);\r\n                    } else {\r\n                        fillRect(0, self.freezeMarkerPosition.y, self.width, self.style.frozenMarkerWidth);\r\n                        strokeRect(0, self.freezeMarkerPosition.y, self.width, self.style.frozenMarkerWidth);\r\n                    }\r\n                }\r\n            }\r\n            function drawPerfLines() {\r\n                if (!self.attributes.showPerformance) { return; }\r\n                var pw = 250,\r\n                    px = self.width - pw - self.style.scrollBarWidth - (self.style.scrollBarBorderWidth * 2),\r\n                    py = columnHeaderCellHeight,\r\n                    ph = 100;\r\n                if (scrollDebugCounters.length === 0) { scrollDebugCounters = fillArray(0, perfWindowSize, 1, function () { return [0, 0]; }); }\r\n                if (touchPPSCounters.length === 0) { touchPPSCounters = fillArray(0, perfWindowSize, 1, function () { return [0, 0]; }); }\r\n                if (entityCount.length === 0) { entityCount = fillArray(0, perfWindowSize, 1, 0); }\r\n                self.ctx.lineWidth = 0.5;\r\n                function dpl(name, perfArr, arrIndex, max, color, useAbs, rowIndex) {\r\n                    var v;\r\n                    drawPerfLine(pw, ph, px, py, perfArr, arrIndex, max, color, useAbs);\r\n                    self.ctx.fillStyle = color;\r\n                    fillRect(3 + px, py + 9 + (rowIndex * 11), 8, 8);\r\n                    self.ctx.fillStyle = self.style.debugPerfChartTextColor;\r\n                    v = arrIndex !== undefined ? perfArr[0][arrIndex] : perfArr[0];\r\n                    fillText(name + ' ' + (isNaN(v) ? 0 : v).toFixed(3), 14 + px, py + 16 + (rowIndex * 11));\r\n                }\r\n                self.ctx.textAlign = 'left';\r\n                self.ctx.font = self.style.debugFont;\r\n                self.ctx.fillStyle = self.style.debugPerfChartBackground;\r\n                fillRect(px, py, pw, ph);\r\n                [['Scroll Height', scrollDebugCounters, 0, self.scrollBox.scrollHeight, self.style.debugScrollHeightColor, false],\r\n                    ['Scroll Width', scrollDebugCounters, 1, self.scrollBox.scrollWidth, self.style.debugScrollWidthColor, false],\r\n                    ['Performance', perfCounters, undefined, 200, self.style.debugPerformanceColor, false],\r\n                    ['Entities', entityCount, undefined, 1500, self.style.debugEntitiesColor, false],\r\n                    ['TouchPPSX', touchPPSCounters, 0, 1000, self.style.debugTouchPPSXColor, true],\r\n                    ['TouchPPSY', touchPPSCounters, 1, 1000, self.style.debugTouchPPSYColor, true]\r\n                    ].forEach(function (i, index) {\r\n                    i.push(index);\r\n                    dpl.apply(null, i);\r\n                });\r\n                self.ctx.fillStyle = self.style.debugPerfChartBackground;\r\n                entityCount.pop();\r\n                entityCount.unshift(self.visibleCells.length);\r\n                scrollDebugCounters.pop();\r\n                scrollDebugCounters.unshift([self.scrollBox.scrollTop, self.scrollBox.scrollLeft]);\r\n                touchPPSCounters.pop();\r\n                touchPPSCounters.unshift([self.yPPS, self.xPPS]);\r\n            }\r\n            function drawDebug() {\r\n                self.ctx.save();\r\n                var d;\r\n                if (self.attributes.showPerformance || self.attributes.debug) {\r\n                    if (perfCounters.length === 0) { perfCounters = fillArray(0, perfWindowSize, 1, 0); }\r\n                    perfCounters.pop();\r\n                    perfCounters.unshift(performance.now() - p);\r\n                }\r\n                if (!self.attributes.debug) {\r\n                    self.ctx.restore();\r\n                    return;\r\n                }\r\n                self.ctx.font = self.style.debugFont;\r\n                d = {};\r\n                d.perf = (perfCounters.reduce(function (a, b) {\r\n                    return a + b;\r\n                }, 0) / Math.min(drawCount, perfCounters.length)).toFixed(1);\r\n                d.perfDelta = perfCounters[0].toFixed(1);\r\n                d.frozenColumnsWidth = getFrozenColumnsWidth();\r\n                d.htmlImages = Object.keys(self.htmlImageCache).length;\r\n                d.reorderObject = 'x: ' + (self.reorderObject || {columnIndex: 0}).columnIndex + ', y: ' + (self.reorderObject || {rowIndex: 0}).rowIndex;\r\n                d.reorderTarget = 'x: ' + (self.reorderTarget || {columnIndex: 0}).columnIndex + ', y: ' + (self.reorderTarget || {rowIndex: 0}).rowIndex;\r\n                d.scale = self.scale;\r\n                d.startScale = self.startScale;\r\n                d.scaleDelta = self.scaleDelta;\r\n                d.zoomDeltaStart = self.zoomDeltaStart;\r\n                d.touchLength = self.touchLength;\r\n                d.touches = 'y0: ' + (self.touchPosition || {y: 0}).y + ' y1: ' + (self.touchPosition1 || {y: 0}).y;\r\n                d.scrollBox = self.scrollBox.toString();\r\n                d.scrollIndex = 'x: ' + self.scrollIndexLeft + ', y: ' + self.scrollIndexTop;\r\n                d.scrollPixel = 'x: ' + self.scrollPixelLeft + ', y: ' + self.scrollPixelTop;\r\n                d.canvasOffset = 'x: ' + self.canvasOffsetLeft + ', y: ' + self.canvasOffsetTop;\r\n                d.touchDelta = 'x: ' + self.touchDelta.x + ', y: ' + self.touchDelta.y;\r\n                d.touchAnimateTo = 'x: ' + self.touchAnimateTo.x + ', y: ' + self.touchAnimateTo.y;\r\n                d.scrollAnimation = 'x: ' + self.scrollAnimation.x + ', y: ' + self.scrollAnimation.y;\r\n                d.touchPPS = 'x: ' + self.xPPS + ', y: ' + self.yPPS;\r\n                d.touchPPST = 'x: ' + self.xPPST + ', y: ' + self.yPPST;\r\n                d.touchDuration = self.touchDuration;\r\n                d.pointerLockPosition =  self.pointerLockPosition ?\r\n                        self.pointerLockPosition.x + ', ' + self.pointerLockPosition.y : '';\r\n                d.size = 'w: ' + self.width + ', h: ' + self.height;\r\n                d.mouse = 'x: ' + self.mouse.x + ', y: ' + self.mouse.y;\r\n                d.touch = !self.touchStart\r\n                    ? '' : 'x: ' + self.touchStart.x + ', y: ' + self.touchStart.y;\r\n                d.entities = self.visibleCells.length;\r\n                d.hasFocus = self.hasFocus;\r\n                d.dragMode = self.dragMode;\r\n                if (self.currentCell) {\r\n                    d.columnIndex = self.currentCell.columnIndex;\r\n                    d.rowIndex = self.currentCell.rowIndex;\r\n                    d.sortColumnIndex = self.currentCell.sortColumnIndex;\r\n                    d.sortRowIndex = self.currentCell.sortRowIndex;\r\n                    d.context = self.currentCell.context;\r\n                    d.dragContext = self.currentCell.dragContext;\r\n                    d.style = self.currentCell.style;\r\n                    d.type = self.currentCell.type;\r\n                }\r\n                self.ctx.textAlign = 'right';\r\n                self.ctx.fillStyle = self.style.debugBackgroundColor;\r\n                fillRect(0, 0, self.width, self.height);\r\n                Object.keys(d).forEach(function (key, index) {\r\n                    var m = key + ': ' + d[key],\r\n                        lh = 14;\r\n                    self.ctx.fillStyle = self.style.debugColor;\r\n                    fillText(m, w - 20, (self.attributes.showPerformance ? 140 : 24) + (index * lh));\r\n                });\r\n                self.ctx.restore();\r\n            }\r\n            self.ctx.save();\r\n            initDraw();\r\n            drawBackground();\r\n            drawFrozenRows();\r\n            drawRows();\r\n            drawActiveCell();\r\n            drawHeaders();\r\n            drawFrozenMarkers();\r\n            drawSelectionHandles();\r\n            drawReorderMarkers();\r\n            drawMoveMarkers();\r\n            drawBorder();\r\n            drawSelectionBorders();\r\n            if (checkScrollHeight) {\r\n                self.resize(true);\r\n            }\r\n            drawDebug();\r\n            drawPerfLines();\r\n            if (self.dispatchEvent('afterdraw', {})) { return; }\r\n            self.ctx.restore();\r\n        };\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/draw.js\n// module id = 3\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true, plusplus: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        var wheeling;\r\n        self.stopPropagation = function (e) { e.stopPropagation(); };\r\n        /**\r\n         * Adds an event listener to the given event.\r\n         * @memberof canvasDatagrid\r\n         * @name addEventListener\r\n         * @method\r\n         * @param {string} ev The name of the event to subscribe to.\r\n         * @param {function} fn The event procedure to execute when the event is raised.\r\n         */\r\n        self.addEventListener = function (ev, fn) {\r\n            self.events[ev] = self.events[ev] || [];\r\n            self.events[ev].unshift(fn);\r\n        };\r\n        /**\r\n         * Removes the given listener function from the given event.  Must be an actual reference to the function that was bound.\r\n         * @memberof canvasDatagrid\r\n         * @name removeEventListener\r\n         * @method\r\n         * @param {string} ev The name of the event to unsubscribe from.\r\n         * @param {function} fn The event procedure to execute when the event is raised.\r\n         */\r\n        self.removeEventListener = function (ev, fn) {\r\n            (self.events[ev] || []).forEach(function removeEachListener(sfn, idx) {\r\n                if (fn === sfn) {\r\n                    self.events[ev].splice(idx, 1);\r\n                }\r\n            });\r\n        };\r\n        /**\r\n         * Fires the given event, padding an event object to the event subscribers.\r\n         * @memberof canvasDatagrid\r\n         * @name dispatchEvent\r\n         * @method\r\n         * @param {number} ev The name of the event to dispatch.\r\n         * @param {number} e The event object.\r\n         */\r\n        self.dispatchEvent = function (ev, e) {\r\n            e = ev.type ? ev : (e || {});\r\n            ev = ev.type || ev;\r\n            var defaultPrevented;\r\n            function preventDefault() {\r\n                defaultPrevented = true;\r\n            }\r\n            if (!self.events[ev]) { return; }\r\n            self.events[ev].forEach(function dispatchEachEvent(fn) {\r\n                e.ctx = self.ctx;\r\n                e.preventDefault = preventDefault;\r\n                fn.apply(self.intf, [e]);\r\n            });\r\n            return defaultPrevented;\r\n        };\r\n        self.getRatio = function () {\r\n            return Math.min(self.attributes.maxPixelRatio, (window.devicePixelRatio || 1) /\r\n                (self.ctx.webkitBackingStorePixelRatio ||\r\n                    self.ctx.mozBackingStorePixelRatio ||\r\n                    self.ctx.msBackingStorePixelRatio ||\r\n                    self.ctx.oBackingStorePixelRatio ||\r\n                    self.ctx.backingStorePixelRatio || 1));\r\n        };\r\n        self.resize = function (drawAfterResize) {\r\n            if (!self.canvas) { return; }\r\n            var x,\r\n                v = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    height: 0,\r\n                    width: 0,\r\n                    style: 'vertical-scroll-bar'\r\n                },\r\n                n = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    height: 0,\r\n                    width: 0,\r\n                    style: 'horizontal-scroll-bar'\r\n                },\r\n                vb = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    height: 0,\r\n                    width: 0,\r\n                    style: 'vertical-scroll-box'\r\n                },\r\n                nb = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    height: 0,\r\n                    width: 0,\r\n                    style: 'horizontal-scroll-box'\r\n                },\r\n                co = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    height: 0,\r\n                    width: 0,\r\n                    isCorner: true,\r\n                    isScrollBoxCorner: true,\r\n                    style: 'scroll-box-corner'\r\n                },\r\n                m = (self.style.scrollBarBoxMargin * 2),\r\n                b = (self.style.scrollBarBorderWidth * 2),\r\n                d = self.style.scrollBarBoxMargin * 0.5,\r\n                sbw = self.style.scrollBarWidth + (self.style.scrollBarBorderWidth * 2),\r\n                ratio = self.getRatio(),\r\n                bm = self.style.gridBorderCollapse === 'collapse' ? 1 : 2,\r\n                cellBorder = self.style.cellBorderWidth * bm,\r\n                columnHeaderCellBorder = self.style.columnHeaderCellBorderWidth * bm,\r\n                dataHeight = 0,\r\n                dataWidth = 0,\r\n                dims,\r\n                l = (self.data || []).length,\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n                rowHeaderCellWidth = self.getRowHeaderCellWidth(),\r\n                ch = self.style.cellHeight,\r\n                s = self.getSchema();\r\n            // sets actual DOM canvas element\r\n            function checkScrollBoxVisibility() {\r\n                self.scrollBox.horizontalBarVisible = (self.style.width !== 'auto' && dataWidth > self.scrollBox.width && self.style.overflowX !== 'hidden')\r\n                    || self.style.overflowX === 'scroll';\r\n                self.scrollBox.horizontalBoxVisible = dataWidth > self.scrollBox.width;\r\n                self.scrollBox.verticalBarVisible = (self.style.height !== 'auto' && dataHeight > self.scrollBox.height && self.style.overflowY !== 'hidden')\r\n                    || self.style.overflowY === 'scroll';\r\n                self.scrollBox.verticalBoxVisible = dataHeight > self.scrollBox.height;\r\n            }\r\n            function setScrollBoxSize() {\r\n                self.scrollBox.width = self.width - rowHeaderCellWidth;\r\n                self.scrollBox.height = self.height - columnHeaderCellHeight;\r\n            }\r\n            function setCanvasSize() {\r\n                if (self.isChildGrid) {\r\n                    return;\r\n                }\r\n                dims = {\r\n                    // HACK +1 ? maybe it's a magic cell border?  Required to line up properly in auto height mode.\r\n                    height: columnHeaderCellHeight + dataHeight + cellBorder + 1,\r\n                    width: dataWidth + rowHeaderCellWidth + cellBorder\r\n                };\r\n                ['width', 'height'].forEach(function (dim) {\r\n                    //TODO: support inherit\r\n                    if (['auto', undefined].indexOf(self.style[dim]) !== -1\r\n                            && ['auto', undefined].indexOf(self.appliedInlineStyles[dim]) !== -1) {\r\n                        self.parentNodeStyle[dim] = dims[dim] + 'px';\r\n                    } else {\r\n                        self.parentNodeStyle[dim] = self.style[dim];\r\n                        if (self.isComponet) {\r\n                            self.canvas.style[dim] = self.style[dim];\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            self.scrollCache.x = [];\r\n            self.scrollCache.y = [];\r\n            for (x = 0; x < l; x += 1) {\r\n                self.scrollCache.y[x] = dataHeight;\r\n                dataHeight += (((self.sizes.rows[x] || ch) + (self.sizes.trees[x] || 0)) * self.scale)\r\n                    // HACK? if an expanded tree row is frozen it is necessary to add the tree row's height a second time.\r\n                    + (self.frozenRow > x ? (self.sizes.trees[x] || 0) : 0);\r\n            }\r\n            if (l > 1) {\r\n                self.scrollCache.y[x] = dataHeight;\r\n            }\r\n            dataWidth = s.reduce(function reduceSchema(accumulator, column, columnIndex) {\r\n                // intentional redefintion of column.  This causes scrollCache to be in the correct order\r\n                column = s[self.orders.columns[columnIndex]];\r\n                if (column.hidden) {\r\n                    self.scrollCache.x[columnIndex] = accumulator;\r\n                    return accumulator;\r\n                }\r\n                var va = accumulator + self.getColummnWidth(self.orders.columns[columnIndex]);\r\n                self.scrollCache.x[columnIndex] = va;\r\n                return va;\r\n            }, 0) || 0;\r\n            if (self.attributes.showNewRow) {\r\n                dataHeight += ch;\r\n            }\r\n            if (self.attributes.snapToRow) {\r\n              dataHeight += self.style.cellHeight;\r\n            }\r\n            setCanvasSize();\r\n            if (self.isChildGrid) {\r\n                self.width = self.parentNode.offsetWidth;\r\n                self.height = self.parentNode.offsetHeight;\r\n            } else if (self.height !== self.canvas.offsetHeight || self.width !== self.canvas.offsetWidth) {\r\n                self.height = self.canvas.offsetHeight;\r\n                self.width = self.canvas.offsetWidth;\r\n                self.canvasOffsetLeft = self.args.canvasOffsetLeft || 0;\r\n                self.canvasOffsetTop = self.args.canvasOffsetTop || 0;\r\n            }\r\n            /// calculate scroll bar dimensions\r\n            // non-controversial\r\n            self.scrollBox.top = columnHeaderCellHeight + columnHeaderCellBorder;\r\n            self.scrollBox.left = rowHeaderCellWidth;\r\n            // width and height of scroll box\r\n            setScrollBoxSize();\r\n            // is the data larger than the scroll box\r\n            checkScrollBoxVisibility();\r\n            // if the scroll box is visible, make room for it by expanding the size of the element\r\n            // if the other dimension is set to auto\r\n            if (self.scrollBox.horizontalBarVisible) {\r\n                if (self.style.height === 'auto' && !self.isChildGrid) {\r\n                    self.height += sbw;\r\n                }\r\n                dataHeight += sbw;\r\n                setCanvasSize();\r\n                setScrollBoxSize();\r\n                checkScrollBoxVisibility();\r\n            }\r\n            if (self.scrollBox.verticalBarVisible) {\r\n                if (self.style.width === 'auto' && !self.isChildGrid) {\r\n                    self.width += sbw;\r\n                }\r\n                dataWidth += sbw;\r\n                setCanvasSize();\r\n                setScrollBoxSize();\r\n                checkScrollBoxVisibility();\r\n            }\r\n            // set again after bar visibility checks\r\n            setScrollBoxSize();\r\n            self.scrollBox.scrollWidth = dataWidth - self.scrollBox.width;\r\n            self.scrollBox.scrollHeight = dataHeight - self.scrollBox.height;\r\n            self.scrollBox.widthBoxRatio = self.scrollBox.width / dataWidth;\r\n            self.scrollBox.scrollBoxWidth = self.scrollBox.width\r\n                * self.scrollBox.widthBoxRatio\r\n                - self.style.scrollBarWidth - b - d;\r\n            // TODO: This heightBoxRatio number is terribly wrong.\r\n            // They should be a result of the size of the grid/canvas?\r\n            // it being off causes the scroll bar to \"slide\" under\r\n            // the dragged mouse.\r\n            // https://github.com/TonyGermaneri/canvas-datagrid/issues/97\r\n            self.scrollBox.heightBoxRatio = (self.scrollBox.height - columnHeaderCellHeight) / dataHeight;\r\n            self.scrollBox.scrollBoxHeight = self.scrollBox.height\r\n                * self.scrollBox.heightBoxRatio\r\n                - self.style.scrollBarWidth - b - d;\r\n            self.scrollBox.scrollBoxWidth = Math.max(self.scrollBox.scrollBoxWidth, self.style.scrollBarBoxMinSize);\r\n            self.scrollBox.scrollBoxHeight = Math.max(self.scrollBox.scrollBoxHeight, self.style.scrollBarBoxMinSize);\r\n            // horizontal\r\n            n.x += rowHeaderCellWidth;\r\n            n.y += self.height - self.style.scrollBarWidth - d;\r\n            n.width = self.width - self.style.scrollBarWidth - rowHeaderCellWidth - d - m;\r\n            n.height = self.style.scrollBarWidth + self.style.scrollBarBorderWidth + d;\r\n            // horizontal box\r\n            nb.y = n.y + self.style.scrollBarBoxMargin;\r\n            nb.width = self.scrollBox.scrollBoxWidth;\r\n            nb.height = self.style.scrollBarBoxWidth;\r\n            // vertical\r\n            v.x += self.width - self.style.scrollBarWidth - self.style.scrollBarBorderWidth - d;\r\n            v.y += columnHeaderCellHeight;\r\n            v.width = self.style.scrollBarWidth + self.style.scrollBarBorderWidth + d;\r\n            v.height = self.height - columnHeaderCellHeight - self.style.scrollBarWidth - d - m;\r\n            // vertical box\r\n            vb.x = v.x + self.style.scrollBarBoxMargin;\r\n            vb.width = self.style.scrollBarBoxWidth;\r\n            vb.height = self.scrollBox.scrollBoxHeight;\r\n            // corner\r\n            co.x = n.x + n.width + m;\r\n            co.y = v.y + v.height + m;\r\n            co.width = self.style.scrollBarWidth + self.style.scrollBarBorderWidth;\r\n            co.height = self.style.scrollBarWidth + self.style.scrollBarBorderWidth;\r\n            self.scrollBox.entities = {\r\n                horizontalBar: n,\r\n                horizontalBox: nb,\r\n                verticalBar: v,\r\n                verticalBox: vb,\r\n                corner: co\r\n            };\r\n            self.scrollBox.bar = {\r\n                v: v,\r\n                h: n\r\n            };\r\n            self.scrollBox.box = {\r\n                v: vb,\r\n                h: nb\r\n            };\r\n            /// calculate page and dom elements\r\n            self.page = Math.max(1, self.visibleRows.length - 3 - self.attributes.pageUpDownOverlap);\r\n            // set canvas drawing related items\r\n            if (!self.isChildGrid) {\r\n                self.canvas.width = self.width * ratio;\r\n                self.canvas.height = self.height * ratio;\r\n                self.ctx.scale(ratio, ratio);\r\n            }\r\n            // resize any open dom elements (input/textarea)\r\n            self.resizeEditInput();\r\n            self.scroll(true);\r\n            if (drawAfterResize) {\r\n                self.draw(true);\r\n            }\r\n            self.dispatchEvent('resize', {});\r\n            return true;\r\n        };\r\n        self.scroll = function (dontDraw) {\r\n            var s = self.getSchema(),\r\n                l = (self.data || []).length,\r\n                ch = self.style.cellHeight;\r\n            // go too far in leaps, then get focused\r\n            self.scrollIndexTop = Math.floor((l * (self.scrollBox.scrollTop / self.scrollBox.scrollHeight)) - 100);\r\n            self.scrollIndexTop = Math.max(self.scrollIndexTop, 0);\r\n            self.scrollPixelTop = self.scrollCache.y[self.scrollIndexTop];\r\n            // sometimes the grid is rendered but the height is zero\r\n            if (self.scrollBox.scrollHeight === 0) {\r\n                self.scrollIndexTop = 0;\r\n            }\r\n            self.scrollPixelTop = 0;\r\n            self.scrollIndexLeft = self.frozenColumn;\r\n            self.scrollPixelLeft = 0;\r\n            while (self.scrollPixelTop < self.scrollBox.scrollTop && self.scrollIndexTop < self.data.length) {\r\n                // start on index +1 since index 0 was used in \"go too far\" section above\r\n                self.scrollIndexTop += 1;\r\n                self.scrollPixelTop = self.scrollCache.y[self.scrollIndexTop];\r\n            }\r\n            while (self.scrollPixelLeft < (self.scrollBox.scrollLeft + 1) && self.scrollIndexLeft < s.length) {\r\n                self.scrollPixelLeft = self.scrollCache.x[self.scrollIndexLeft];\r\n                self.scrollIndexLeft += 1;\r\n            }\r\n            if (s.length > 0) {\r\n                self.scrollIndexLeft = Math.max(self.scrollIndexLeft - 1, 0);\r\n                self.scrollPixelLeft -= self.getColummnWidth(self.orders.columns[self.scrollIndexLeft]);\r\n            }\r\n            if ((self.data || []).length > 0) {\r\n                self.scrollIndexTop = Math.max(self.scrollIndexTop - 1, 0);\r\n                self.scrollPixelTop = Math.max((self.scrollPixelTop\r\n                    - (\r\n                        self.data[self.scrollIndexTop] ? (self.sizes.rows[self.scrollIndexTop] || ch)\r\n                                + (self.sizes.trees[self.scrollIndexTop] || 0)\r\n                        : ch\r\n                    ) * self.scale), 0);\r\n            }\r\n            self.ellipsisCache = {};\r\n            if (!dontDraw) {\r\n                self.draw(true);\r\n            }\r\n            //TODO: figure out why this has to be delayed for child grids\r\n            //BUG: wheeling event on 3rd level hierarchy fails to move input box\r\n            requestAnimationFrame(self.resizeEditInput);\r\n            self.dispatchEvent('scroll', {top: self.scrollBox.scrollTop, left: self.scrollBox.scrollLeft});\r\n        };\r\n        self.mousemove = function (e, overridePos) {\r\n            if (self.contextMenu || self.input) {\r\n                return;\r\n            }\r\n            self.mouse = overridePos || self.getLayerPos(e);\r\n            var ctrl = (e.ctrlKey || e.metaKey || self.attributes.persistantSelectionMode),\r\n                i,\r\n                s = self.getSchema(),\r\n                dragBounds,\r\n                sBounds,\r\n                x = self.mouse.x,\r\n                y = self.mouse.y,\r\n                o = self.getCellAt(x, y),\r\n                delta,\r\n                ev = {NativeEvent: e, cell: o, x: x, y: y},\r\n                previousCell = self.currentCell;\r\n            clearTimeout(self.scrollTimer);\r\n            if (!self.isInGrid({x: x, y: y})) {\r\n                self.hasFocus = false;\r\n            }\r\n            if (self.dispatchEvent('mousemove', ev)) {\r\n                return;\r\n            }\r\n            if (o && self.currentCell) {\r\n                self.rowBoundaryCrossed = self.currentCell.rowIndex !== o.rowIndex;\r\n                self.columnBoundaryCrossed = self.currentCell.columnIndex !== o.columnIndex;\r\n                self.cellBoundaryCrossed = self.rowBoundaryCrossed || self.columnBoundaryCrossed;\r\n                ['row', 'column', 'cell'].forEach(function (prefix) {\r\n                    if (self[prefix + 'BoundaryCrossed']) {\r\n                        ev.cell = previousCell;\r\n                        self.dispatchEvent(prefix + 'mouseout', ev);\r\n                        ev.cell = o;\r\n                        self.dispatchEvent(prefix + 'mouseover', ev);\r\n                    }\r\n                });\r\n            }\r\n            self.currentCell = o;\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            self.hovers = {};\r\n            if (!self.draggingItem\r\n                    && o\r\n                    && self.scrollModes.indexOf(o.context) === -1) {\r\n                self.dragItem = o;\r\n                self.dragMode = o.dragContext;\r\n                self.cursor = o.context;\r\n                if (o.context === 'cell') {\r\n                    self.cursor = 'default';\r\n                    self.hovers = { rowIndex: o.rowIndex, columnIndex: o.columnIndex };\r\n                }\r\n                if ((self.selecting || self.reorderObject)\r\n                        && o.context === 'cell') {\r\n                    delta = {\r\n                        x: Math.abs(self.dragStart.x - x),\r\n                        y: Math.abs(self.dragStart.y - y)\r\n                    };\r\n                    if (self.dragStartObject.columnIndex !== -1 && e.shiftKey) {\r\n                        self.dragStartObject = {\r\n                            rowIndex: self.activeCell.rowIndex,\r\n                            columnIndex: self.activeCell.columnIndex\r\n                        };\r\n                    }\r\n                    dragBounds = {\r\n                        top: Math.min(self.dragStartObject.rowIndex, o.rowIndex),\r\n                        left: Math.min(self.dragStartObject.columnIndex, o.columnIndex),\r\n                        bottom: Math.max(self.dragStartObject.rowIndex, o.rowIndex),\r\n                        right: Math.max(self.dragStartObject.columnIndex, o.columnIndex)\r\n                    };\r\n                    if (self.dragStartObject.columnIndex === -1) {\r\n                        sBounds = self.getSelectionBounds();\r\n                        dragBounds.left = -1;\r\n                        dragBounds.right = s.length - 1;\r\n                        dragBounds.top = Math.min(sBounds.top, o.rowIndex);\r\n                        dragBounds.bottom = Math.max(sBounds.bottom, o.rowIndex);\r\n                    }\r\n                    if (self.dragStartObject.rowIndex !== o.rowIndex\r\n                                || self.dragStartObject.columnIndex !== o.columnIndex) {\r\n                        self.ignoreNextClick = true;\r\n                    }\r\n                    if (self.cellBoundaryCrossed || (delta.x === 0 && delta.y === 0) || (self.attributes.selectionMode === 'row')) {\r\n                        if (((self.attributes.selectionMode === 'row') || self.dragStartObject.columnIndex === -1)\r\n                                && self.rowBoundaryCrossed) {\r\n                            self.selectRow(o.rowIndex, ctrl, null, true);\r\n                        } else if (self.attributes.selectionMode !== 'row') {\r\n                            if (!self.dragAddToSelection && o.rowIndex !== undefined) {\r\n                                if (self.selections[o.rowIndex] && self.selections[o.rowIndex].indexOf(o.columnIndex) !== -1) {\r\n                                    self.selections[o.rowIndex].splice(self.selections[o.rowIndex].indexOf(o.columnIndex), 1);\r\n                                }\r\n                            } else {\r\n                                self.selections[o.rowIndex] = self.selections[o.rowIndex] || [];\r\n                                if (self.selections[o.rowIndex].indexOf(o.columnIndex) === -1) {\r\n                                    self.selections[o.rowIndex].push(o.columnIndex);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if ((!self.selectionBounds || (dragBounds.top !== self.selectionBounds.top\r\n                            || dragBounds.left !== self.selectionBounds.left\r\n                            || dragBounds.bottom !== self.selectionBounds.bottom\r\n                            || dragBounds.right !== self.selectionBounds.right)) && !ctrl) {\r\n                        self.selections = [];\r\n                        sBounds = dragBounds;\r\n                        if (self.attributes.selectionMode === 'row') {\r\n                            for (i = sBounds.top; i <= sBounds.bottom; i += 1) {\r\n                                self.selectRow(i, true, null, true);\r\n                            }\r\n                        } else if (dragBounds.top !== -1) {\r\n                            self.selectArea(sBounds, true);\r\n                        }\r\n                    }\r\n                    self.autoScrollZone(e, x, y, ctrl);\r\n                }\r\n            }\r\n            self.cellBoundaryCrossed = false;\r\n            self.rowBoundaryCrossed = false;\r\n            self.columnBoundaryCrossed = false;\r\n            self.draw(true);\r\n        };\r\n        self.click = function (e, overridePos) {\r\n            var i,\r\n                startingBounds = JSON.stringify(self.getSelectionBounds()),\r\n                ctrl = (e.ctrlKey || e.metaKey || self.attributes.persistantSelectionMode),\r\n                pos = overridePos || self.getLayerPos(e);\r\n            self.currentCell = self.getCellAt(pos.x, pos.y);\r\n            if (self.currentCell.grid !== undefined) {\r\n                return;\r\n            }\r\n            function checkSelectionChange() {\r\n                var ev, sb = self.getSelectionBounds();\r\n                if (startingBounds === JSON.stringify(sb)) {\r\n                    return;\r\n                }\r\n                ev = {\r\n                    selections: self.selections,\r\n                    selectionBounds: self.getSelectionBounds()\r\n                };\r\n                Object.defineProperty(ev, 'selectedData', {\r\n                    get: function () {\r\n                        return self.getSelectedData();\r\n                    }\r\n                });\r\n                self.dispatchEvent('selectionchanged', ev);\r\n            }\r\n            if (self.input) {\r\n                self.endEdit();\r\n            }\r\n            if (self.ignoreNextClick) {\r\n                self.ignoreNextClick = false;\r\n                return;\r\n            }\r\n            i = self.currentCell;\r\n            if (self.dispatchEvent('click', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            if (['rowHeaderCell', 'columnHeaderCell'].indexOf(self.currentCell.style) === -1 && !ctrl) {\r\n                self.setActiveCell(i.columnIndex, i.rowIndex);\r\n            }\r\n            if (self.currentCell.context === 'cell') {\r\n                if (self.currentCell.style === 'cornerCell') {\r\n                    self.selectAll();\r\n                    self.draw();\r\n                    checkSelectionChange();\r\n                    return;\r\n                }\r\n                if (self.currentCell.style === 'columnHeaderCell') {\r\n                    if (self.attributes.columnHeaderClickBehavior === 'sort') {\r\n                        if (self.orderBy === i.header.name) {\r\n                            self.orderDirection = self.orderDirection === 'asc' ? 'desc' : 'asc';\r\n                        } else {\r\n                            self.orderDirection = 'asc';\r\n                        }\r\n                        self.order(i.header.name, self.orderDirection);\r\n                        checkSelectionChange();\r\n                        return;\r\n                    }\r\n                    if (self.attributes.columnHeaderClickBehavior === 'select') {\r\n                        self.selectColumn(i.header.index, ctrl, e.shiftKey);\r\n                        self.draw();\r\n                        return;\r\n                    }\r\n                }\r\n                self.selections[i.rowIndex] = self.selections[i.rowIndex] || [];\r\n                if (((self.attributes.selectionMode === 'row') || self.currentCell.style === 'rowHeaderCell')) {\r\n                    if (self.currentCell.style === 'rowHeaderCell'\r\n                            && self.attributes.tree && pos.x > 0\r\n                            && pos.x - self.currentCell.x < self.style.treeArrowWidth\r\n                            + self.style.treeArrowMarginLeft\r\n                            + self.style.treeArrowMarginRight + self.style.treeArrowClickRadius\r\n                            && pos.y - self.currentCell.y < self.style.treeArrowHeight\r\n                            + self.style.treeArrowMarginTop + self.style.treeArrowClickRadius\r\n                            && pos.y > 0) {\r\n                        self.toggleTree(i.rowIndex);\r\n                        return;\r\n                    }\r\n                }\r\n                if (e.shiftKey && !ctrl) {\r\n                    self.selectionBounds = self.getSelectionBounds();\r\n                    self.selectArea(undefined, false);\r\n                }\r\n            }\r\n            checkSelectionChange();\r\n            self.draw(true);\r\n        };\r\n        self.dragResizeColumn = function (e) {\r\n            var pos, x, y;\r\n            pos = self.getLayerPos(e);\r\n            x = self.resizingStartingWidth + pos.x - self.dragStart.x;\r\n            y = self.resizingStartingHeight + pos.y - self.dragStart.y;\r\n            if (x < self.style.minColumnWidth) {\r\n                x = self.style.minColumnWidth;\r\n            }\r\n            if (y < self.style.minRowHeight) {\r\n                y = self.style.minRowHeight;\r\n            }\r\n            if (self.dispatchEvent('resizecolumn', {x: x, y: y, draggingItem: self.draggingItem})) { return false; }\r\n            if (self.scrollBox.scrollLeft > self.scrollBox.scrollWidth - self.attributes.resizeScrollZone\r\n                    && self.dragMode === 'ew-resize') {\r\n                self.resize(true);\r\n                self.scrollBox.scrollLeft += x;\r\n            }\r\n            if (self.dragMode === 'ew-resize') {\r\n                self.sizes.columns[self.draggingItem.header.style === 'rowHeaderCell'\r\n                       ? 'cornerCell' : self.draggingItem.sortColumnIndex] = x;\r\n                if (['rowHeaderCell', 'cornerCell'].indexOf(self.draggingItem.header.style) !== -1) {\r\n                    self.resize(true);\r\n                }\r\n                self.resizeChildGrids();\r\n                return;\r\n            }\r\n            if (self.dragMode === 'ns-resize') {\r\n                if (self.draggingItem.rowOpen) {\r\n                    self.sizes.trees[self.draggingItem.rowIndex] = y;\r\n                } else if (self.attributes.globalRowResize) {\r\n                    self.style.cellHeight = y;\r\n                } else {\r\n                    self.sizes.rows[self.draggingItem.rowIndex] = y;\r\n                }\r\n                self.dispatchEvent('resizerow', {row: y});\r\n                self.resizeChildGrids();\r\n                return;\r\n            }\r\n            self.ellipsisCache = {};\r\n        };\r\n        self.stopDragResize = function () {\r\n            self.resize();\r\n            document.body.removeEventListener('mousemove', self.dragResizeColumn, false);\r\n            document.body.removeEventListener('mouseup', self.stopDragResize, false);\r\n            self.setStorageData();\r\n            self.draw(true);\r\n            self.ignoreNextClick = true;\r\n        };\r\n        self.scrollGrid = function (e) {\r\n            var pos = self.getLayerPos(e);\r\n            if (self.attributes.scrollPointerLock && self.pointerLockPosition\r\n                    && ['horizontal-scroll-box', 'vertical-scroll-box'].indexOf(self.scrollStartMode) !== -1) {\r\n                self.pointerLockPosition.x += e.movementX;\r\n                self.pointerLockPosition.y += e.movementY;\r\n                self.pointerLockPosition.x = Math.min(self.width - self.style.scrollBarWidth, Math.max(0, self.pointerLockPosition.x));\r\n                self.pointerLockPosition.y = Math.min(self.height - self.style.scrollBarWidth, Math.max(0, self.pointerLockPosition.y));\r\n                pos = self.pointerLockPosition;\r\n            }\r\n            self.scrollMode = self.getCellAt(pos.x, pos.y).context;\r\n            if (self.scrollMode === 'horizontal-scroll-box' && self.scrollStartMode !== 'horizontal-scroll-box') {\r\n                self.scrollStartMode = 'horizontal-scroll-box';\r\n                self.dragStart = pos;\r\n                self.scrollStart.left = self.scrollBox.scrollLeft;\r\n                clearTimeout(self.scrollTimer);\r\n                return;\r\n            }\r\n            if (self.scrollMode === 'vertical-scroll-box' && self.scrollStartMode !== 'vertical-scroll-box') {\r\n                self.scrollStartMode = 'vertical-scroll-box';\r\n                self.dragStart = pos;\r\n                self.scrollStart.top = self.scrollBox.scrollTop;\r\n                clearTimeout(self.scrollTimer);\r\n                return;\r\n            }\r\n            if (self.scrollStartMode === 'vertical-scroll-box'\r\n                    && self.scrollMode !== 'vertical-scroll-box') {\r\n                self.scrollMode = 'vertical-scroll-box';\r\n            }\r\n            if (self.scrollStartMode === 'horizontal-scroll-box'\r\n                    && self.scrollMode !== 'horizontal-scroll-box') {\r\n                self.scrollMode = 'horizontal-scroll-box';\r\n            }\r\n            clearTimeout(self.scrollTimer);\r\n            if (self.scrollModes.indexOf(self.scrollMode) === -1) {\r\n                return;\r\n            }\r\n            if (self.scrollMode === 'vertical-scroll-box') {\r\n                self.scrollBox.scrollTop = self.scrollStart.top + ((pos.y - self.dragStart.y)\r\n                    / self.scrollBox.heightBoxRatio);\r\n            } else if (self.scrollMode === 'vertical-scroll-top') {\r\n                self.scrollBox.scrollTop -= (self.page * self.style.cellHeight);\r\n                self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n            } else if (self.scrollMode === 'vertical-scroll-bottom') {\r\n                self.scrollBox.scrollTop += (self.page * self.style.cellHeight);\r\n                self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n            }\r\n            if (self.scrollMode === 'horizontal-scroll-box') {\r\n                self.scrollBox.scrollLeft = self.scrollStart.left + ((pos.x - self.dragStart.x)\r\n                    / self.scrollBox.widthBoxRatio);\r\n            } else if (self.scrollMode === 'horizontal-scroll-right') {\r\n                self.scrollBox.scrollLeft += self.attributes.selectionScrollIncrement;\r\n                self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n            } else if (self.scrollMode === 'horizontal-scroll-left') {\r\n                self.scrollBox.scrollLeft -= self.attributes.selectionScrollIncrement;\r\n                self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n            }\r\n        };\r\n        self.stopScrollGrid = function () {\r\n            clearTimeout(self.scrollTimer);\r\n            if (document.exitPointerLock) {\r\n                document.exitPointerLock();\r\n            }\r\n            document.removeEventListener('mousemove', self.scrollGrid, false);\r\n        };\r\n        self.dragReorder = function (e) {\r\n            var pos, x, y,\r\n                columReorder = self.dragMode === 'column-reorder',\r\n                rowReorder = self.dragMode === 'row-reorder';\r\n            pos = self.getLayerPos(e);\r\n            x = pos.x - self.dragStart.x;\r\n            y = pos.y - self.dragStart.y;\r\n            if (!self.attributes.allowColumnReordering && columReorder) {\r\n                return;\r\n            }\r\n            if (!self.attributes.allowRowReordering && rowReorder) {\r\n                return;\r\n            }\r\n            if (self.dispatchEvent('reordering', {\r\n                    NativeEvent: e,\r\n                    source: self.dragStartObject,\r\n                    target: self.currentCell,\r\n                    dragMode: self.dragMode\r\n                })) {\r\n                return;\r\n            }\r\n            if (Math.abs(x) > self.attributes.reorderDeadZone || Math.abs(y) > self.attributes.reorderDeadZone) {\r\n                self.reorderObject = self.draggingItem;\r\n                self.reorderTarget = self.currentCell;\r\n                self.reorderObject.dragOffset = {\r\n                    x: x,\r\n                    y: y\r\n                };\r\n                self.autoScrollZone(e, columReorder ? pos.x : -1, rowReorder ? pos.y : -1, false);\r\n            }\r\n        };\r\n        self.stopDragReorder = function (e) {\r\n            var oIndex,\r\n                tIndex,\r\n                cr = {\r\n                    'row-reorder': self.orders.rows,\r\n                    'column-reorder': self.orders.columns\r\n                },\r\n                i = {\r\n                    'row-reorder': 'rowIndex',\r\n                    'column-reorder': 'sortColumnIndex'\r\n                }[self.dragMode];\r\n            document.body.removeEventListener('mousemove', self.dragReorder, false);\r\n            document.body.removeEventListener('mouseup', self.stopDragReorder, false);\r\n            if (self.reorderObject\r\n                    && self.reorderTarget\r\n                    && ((self.dragMode === 'column-reorder' && self.reorderTarget.sortColumnIndex > -1\r\n                        && self.reorderTarget.sortColumnIndex < self.getSchema().length)\r\n                    || (self.dragMode === 'row-reorder' && self.reorderTarget.rowIndex > -1\r\n                        && self.reorderTarget.rowIndex < self.data.length))\r\n                    && self.reorderObject[i] !== self.reorderTarget[i]\r\n                    && !self.dispatchEvent('reorder', {\r\n                        NativeEvent: e,\r\n                        source: self.reorderObject,\r\n                        target: self.reorderTarget,\r\n                        dragMode: self.dragMode\r\n                    })) {\r\n                self.ignoreNextClick = true;\r\n                oIndex = cr[self.dragMode].indexOf(self.reorderObject[i]);\r\n                tIndex = cr[self.dragMode].indexOf(self.reorderTarget[i]);\r\n                cr[self.dragMode].splice(oIndex, 1);\r\n                cr[self.dragMode].splice(tIndex, 0, self.reorderObject[i]);\r\n                if(self.dragMode === 'column-reorder') {\r\n                  self.orders.columns = cr[self.dragMode];\r\n                } else {\r\n                  self.orders.rows = cr[self.dragMode];\r\n                }\r\n                self.resize();\r\n                self.setStorageData();\r\n            }\r\n            self.reorderObject = undefined;\r\n            self.reorderTarget = undefined;\r\n            self.draw(true);\r\n        };\r\n        self.dragMove = function (e) {\r\n            if (self.dispatchEvent('moving', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            var pos = self.getLayerPos(e);\r\n            self.moveOffset = {\r\n                x: self.currentCell.columnIndex - self.dragStartObject.columnIndex,\r\n                y: self.currentCell.rowIndex - self.dragStartObject.rowIndex\r\n            };\r\n            if (Math.abs(pos.x) > self.attributes.reorderDeadZone || Math.abs(pos.y) > self.attributes.reorderDeadZone) {\r\n                setTimeout(function () {\r\n                    self.autoScrollZone(e, pos.x, pos.y, false);\r\n                }, 1);\r\n            }\r\n        };\r\n        self.stopDragMove = function (e) {\r\n            document.body.removeEventListener('mousemove', self.dragMove, false);\r\n            document.body.removeEventListener('mouseup', self.stopDragMove, false);\r\n            var b = self.getSelectionBounds();\r\n            if (self.dispatchEvent('endmove', {NativeEvent: e, cell: self.currentCell})) {\r\n                self.movingSelection = undefined;\r\n                self.moveOffset = undefined;\r\n                self.draw(true);\r\n                return;\r\n            }\r\n            if (self.moveOffset) {\r\n                self.moveTo(self.movingSelection, b.left + self.moveOffset.x, b.top + self.moveOffset.y);\r\n                self.moveSelection(self.moveOffset.x, self.moveOffset.y);\r\n            }\r\n            self.movingSelection = undefined;\r\n            self.moveOffset = undefined;\r\n            self.draw(true);\r\n        };\r\n        self.freezeMove = function (e) {\r\n            if (self.dispatchEvent('freezemoving', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            var pos = self.getLayerPos(e);\r\n            self.ignoreNextClick = true;\r\n            self.freezeMarkerPosition = pos;\r\n            if (self.currentCell && self.currentCell.rowIndex !== undefined && self.dragMode === 'frozen-row-marker') {\r\n                self.scrollBox.scrollTop = 0;\r\n                self.frozenRow = self.currentCell.rowIndex + 1;\r\n            }\r\n            if (self.currentCell && self.currentCell.columnIndex !== undefined && self.dragMode === 'frozen-column-marker') {\r\n                self.scrollBox.scrollLeft = 0;\r\n                self.frozenColumn = self.currentCell.columnIndex + 1;\r\n            }\r\n            if (Math.abs(pos.x) > self.attributes.reorderDeadZone || Math.abs(pos.y) > self.attributes.reorderDeadZone) {\r\n                setTimeout(function () {\r\n                    self.autoScrollZone(e, pos.x, pos.y, false);\r\n                }, 1);\r\n            }\r\n        };\r\n        self.stopFreezeMove = function (e) {\r\n            document.body.removeEventListener('mousemove', self.freezeMove, false);\r\n            document.body.removeEventListener('mouseup', self.stopFreezeMove, false);\r\n            self.freezeMarkerPosition = undefined;\r\n            if (self.dispatchEvent('endfreezemove', {NativeEvent: e, cell: self.currentCell})) {\r\n                self.frozenRow = self.startFreezeMove.x;\r\n                self.frozenColumn = self.startFreezeMove.y;\r\n                self.draw(true);\r\n                return;\r\n            }\r\n            self.draw(true);\r\n        };\r\n        self.mousedown = function (e, overridePos) {\r\n            self.lastMouseDownTarget = e.target;\r\n            if (self.dispatchEvent('mousedown', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            if (e.button === 2 || self.input) { return; }\r\n            var ctrl = (e.ctrlKey || e.metaKey),\r\n                move = /-move/.test(self.dragMode),\r\n                freeze = /frozen-row-marker|frozen-column-marker/.test(self.dragMode),\r\n                resize = /-resize/.test(self.dragMode);\r\n            self.dragStart = overridePos || self.getLayerPos(e);\r\n            self.scrollStart = {\r\n                left: self.scrollBox.scrollLeft,\r\n                top: self.scrollBox.scrollTop\r\n            };\r\n            self.dragStartObject = self.getCellAt(self.dragStart.x, self.dragStart.y);\r\n            self.dragAddToSelection = !self.dragStartObject.selected;\r\n            if (!ctrl && !e.shiftKey && !/(vertical|horizontal)-scroll-(bar|box)/\r\n                    .test(self.dragStartObject.context)\r\n                    && self.currentCell\r\n                    && !self.currentCell.isColumnHeader\r\n                    && !move\r\n                    && !freeze\r\n                    && !resize) {\r\n                self.selections = [];\r\n            }\r\n            if (self.dragStartObject.isGrid) {\r\n                return;\r\n            }\r\n            if (self.scrollModes.indexOf(self.dragStartObject.context) !== -1) {\r\n                self.scrollMode = self.dragStartObject.context;\r\n                self.scrollStartMode = self.dragStartObject.context;\r\n                self.scrollGrid(e);\r\n                if (self.attributes.scrollPointerLock\r\n                        && ['horizontal-scroll-box', 'vertical-scroll-box'].indexOf(self.scrollStartMode) !== -1) {\r\n                    self.pointerLockPosition = {\r\n                        x: self.dragStart.x,\r\n                        y: self.dragStart.y\r\n                    };\r\n                    self.canvas.requestPointerLock();\r\n                }\r\n                document.addEventListener('mousemove', self.scrollGrid, false);\r\n                document.addEventListener('mouseup', self.stopScrollGrid, false);\r\n                self.ignoreNextClick = true;\r\n                return;\r\n            }\r\n            if (self.dragMode === 'cell') {\r\n                self.selecting = true;\r\n                if ((self.attributes.selectionMode === 'row' || self.dragStartObject.columnIndex === -1)\r\n                        && self.dragStartObject.rowIndex > -1) {\r\n                    self.selectRow(self.dragStartObject.rowIndex, ctrl, null);\r\n                } else if (self.attributes.selectionMode !== 'row') {\r\n                    self.mousemove(e);\r\n                }\r\n                return;\r\n            }\r\n            if (move) {\r\n                self.draggingItem = self.dragItem;\r\n                self.movingSelection = self.selections.concat([]);\r\n                self.dragging = self.dragStartObject;\r\n                if (self.dispatchEvent('beginmove', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n                document.body.addEventListener('mousemove', self.dragMove, false);\r\n                document.body.addEventListener('mouseup', self.stopDragMove, false);\r\n                return self.mousemove(e);\r\n            }\r\n            if (freeze) {\r\n                self.draggingItem = self.dragItem;\r\n                self.startFreezeMove = {\r\n                    x: self.frozenRow,\r\n                    y: self.frozenColumn\r\n                };\r\n                if (self.dispatchEvent('beginfreezemove', {NativeEvent: e})) { return; }\r\n                document.body.addEventListener('mousemove', self.freezeMove, false);\r\n                document.body.addEventListener('mouseup', self.stopFreezeMove, false);\r\n                return self.mousemove(e);\r\n            }\r\n            if (resize) {\r\n                self.draggingItem = self.dragItem;\r\n                if (self.draggingItem.rowOpen) {\r\n                    self.resizingStartingHeight = self.sizes.trees[self.draggingItem.rowIndex];\r\n                } else {\r\n                    self.resizingStartingHeight = self.sizes.rows[self.draggingItem.rowIndex] || self.style.cellHeight;\r\n                }\r\n                self.resizingStartingWidth = self.sizes.columns[self.draggingItem.header.style === 'rowHeaderCell'\r\n                       ? 'cornerCell' : self.draggingItem.sortColumnIndex] || self.draggingItem.width;\r\n                document.body.addEventListener('mousemove', self.dragResizeColumn, false);\r\n                document.body.addEventListener('mouseup', self.stopDragResize, false);\r\n                return;\r\n            }\r\n            if (['row-reorder', 'column-reorder'].indexOf(self.dragMode) !== -1) {\r\n                self.draggingItem = self.dragStartObject;\r\n                document.body.addEventListener('mousemove', self.dragReorder, false);\r\n                document.body.addEventListener('mouseup', self.stopDragReorder, false);\r\n                return;\r\n            }\r\n        };\r\n        self.mouseup = function (e) {\r\n            clearTimeout(self.scrollTimer);\r\n            self.cellBoundaryCrossed = true;\r\n            self.rowBoundaryCrossed = true;\r\n            self.columnBoundaryCrossed = true;\r\n            self.selecting = undefined;\r\n            self.draggingItem = undefined;\r\n            self.dragStartObject = undefined;\r\n            if (self.dispatchEvent('mouseup', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus && e.target !== self.canvas) {\r\n                return;\r\n            }\r\n            if (self.currentCell && self.currentCell.grid !== undefined) {\r\n                return;\r\n            }\r\n            if (self.contextMenu || self.input) { return; }\r\n            if (self.dragStart && self.isInGrid(self.dragStart)) {\r\n                self.controlInput.focus();\r\n            }\r\n            e.preventDefault();\r\n        };\r\n        // gets the horizontal adjacent cells as well as first/last based on column visibility\r\n        self.getAdjacentCells = function () {\r\n            var x,\r\n                i,\r\n                s = self.getSchema(),\r\n                o = {};\r\n            for (x = 0; x < s.length; x += 1) {\r\n                i = self.orders.columns[x];\r\n                if (!s[i].hidden) {\r\n                    if (o.first === undefined) {\r\n                        o.first = x;\r\n                        o.left = x;\r\n                    }\r\n                    o.last = x;\r\n                    if (x > self.activeCell.columnIndex && o.right === undefined) {\r\n                        o.right = x;\r\n                    }\r\n                    if (x < self.activeCell.columnIndex) {\r\n                        o.left = x;\r\n                    }\r\n                }\r\n            }\r\n            if (o.right === undefined) {\r\n                o.right = o.last;\r\n            }\r\n            return o;\r\n        };\r\n        self.keydown = function (e) {\r\n            var i,\r\n                ev,\r\n                adjacentCells = self.getAdjacentCells(),\r\n                x = self.activeCell.columnIndex,\r\n                y = self.activeCell.rowIndex,\r\n                ctrl = (e.ctrlKey || e.metaKey),\r\n                last = self.data.length - 1,\r\n                s = self.getSchema(),\r\n                cols = s.length - 1;\r\n            if (self.dispatchEvent('keydown', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            if (self.attributes.showNewRow) {\r\n                last += 1;\r\n            }\r\n            if (e.keyCode === 9) {\r\n                e.preventDefault();\r\n            }\r\n            // esc\r\n            if (e.keyCode === 27) {\r\n                self.selections = [];\r\n                self.draw(true);\r\n            // ctrl + a\r\n            } else if (ctrl && e.keyCode === 65) {\r\n                self.selectAll();\r\n            //ArrowDown\r\n            } else if (e.keyCode === 40) {\r\n                y += 1;\r\n            //ArrowUp\r\n            } else if (e.keyCode === 38) {\r\n                y -= 1;\r\n            //ArrowLeft Tab\r\n            } else if (e.keyCode === 37 || (e.shiftKey && e.keyCode === 9)) {\r\n                x = adjacentCells.left;\r\n            //ArrowRight Tab\r\n            } else if (e.keyCode === 39 || (!e.shiftKey && e.keyCode === 9)) {\r\n                x = adjacentCells.right;\r\n            //PageUp\r\n            } else if (e.keyCode === 33) {\r\n                y -= self.page;\r\n                e.preventDefault();\r\n            //PageDown\r\n            } else if (e.keyCode === 34) {\r\n                y += self.page;\r\n                e.preventDefault();\r\n            //Home ArrowUp\r\n            } else if (e.keyCode === 36 || (ctrl && e.keyCode === 38)) {\r\n                y = 0;\r\n            //End ArrowDown\r\n            } else if (e.keyCode === 35 || (ctrl && e.keyCode === 40)) {\r\n                y = self.data.length - 1;\r\n            //ArrowRight\r\n            } else if (ctrl && e.keyCode === 39) {\r\n                x = adjacentCells.last;\r\n            //ArrowLeft\r\n            } else if (ctrl && e.keyCode === 37) {\r\n                x = adjacentCells.first;\r\n            }\r\n            //Enter\r\n            if (e.keyCode === 13) {\r\n                return self.beginEditAt(x, y, e);\r\n            }\r\n            //Space\r\n            if (e.keyCode === 32) {\r\n                self.selections = [];\r\n                self.selections[Math.max(y, 0)] = [];\r\n                self.selections[Math.max(y, 0)].push(x);\r\n                self.selectionBounds = self.getSelectionBounds();\r\n                if (self.attributes.selectionMode === 'row') {\r\n                    for (i = self.selectionBounds.top; i <= self.selectionBounds.bottom; i += 1) {\r\n                        self.selectRow(i, ctrl, null, true);\r\n                    }\r\n                } else {\r\n                    self.selectArea(undefined, ctrl);\r\n                }\r\n                e.preventDefault();\r\n                self.draw(true);\r\n                return;\r\n            }\r\n            if (x < 0 || Number.isNaN(x)) {\r\n                x = adjacentCells.first;\r\n            }\r\n            if (y > last) {\r\n                y = last;\r\n            }\r\n            if (y < 0 || Number.isNaN(y)) {\r\n                y = 0;\r\n            }\r\n            if (x > cols) {\r\n                x = adjacentCells.last;\r\n            }\r\n            // TODO - most likley some column order related bugs in key based selection\r\n            // Arrows\r\n            if (e.shiftKey && [37, 38, 39, 40].indexOf(e.keyCode) !== -1) {\r\n                self.selections[Math.max(y, 0)] = self.selections[Math.max(y, 0)] || [];\r\n                self.selections[Math.max(y, 0)].push(x);\r\n                self.selectionBounds = self.getSelectionBounds();\r\n                self.selectArea(undefined, ctrl);\r\n                self.draw(true);\r\n            }\r\n            if (x !== self.activeCell.columnIndex || y !== self.activeCell.rowIndex) {\r\n                self.scrollIntoView(\r\n                  x !== self.activeCell.columnIndex ? x : undefined,\r\n                  y !== self.activeCell.rowIndex && !Number.isNaN(y) ? y : undefined\r\n                );\r\n\r\n                self.setActiveCell(x, y);\r\n                if (!e.shiftKey && self.attributes.selectionFollowsActiveCell) {\r\n                    if (!ctrl) {\r\n                        self.selections = [];\r\n                    }\r\n                    self.selections[y] = self.selections[y] || [];\r\n                    self.selections[y].push(x);\r\n                    ev = {\r\n                        selectedData: self.getSelectedData(),\r\n                        selections: self.selections,\r\n                        selectionBounds: self.getSelectionBounds()\r\n                    };\r\n                    Object.defineProperty(ev, 'selectedData', {\r\n                        get: function () {\r\n                            return self.getSelectedData();\r\n                        }\r\n                    });\r\n                    self.dispatchEvent('selectionchanged', ev);\r\n                }\r\n                self.draw(true);\r\n            }\r\n        };\r\n        self.keyup = function (e) {\r\n            if (self.dispatchEvent('keyup', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n        };\r\n        self.keypress = function (e) {\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            if (self.dispatchEvent('keypress', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n        };\r\n        self.dblclick = function (e) {\r\n            if (self.dispatchEvent('dblclick', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            if (self.currentCell.context === 'ew-resize'\r\n                    && self.currentCell.style === 'columnHeaderCell') {\r\n                self.fitColumnToValues(self.currentCell.header.name);\r\n            } else if (self.currentCell.context === 'ew-resize'\r\n                    && self.currentCell.style === 'cornerCell') {\r\n                self.autosize();\r\n            } else if (['cell', 'activeCell'].indexOf(self.currentCell.style) !== -1) {\r\n                self.beginEditAt(self.currentCell.columnIndex, self.currentCell.rowIndex);\r\n            }\r\n        };\r\n        self.scrollWheel = function (e) {\r\n            var l,\r\n                t,\r\n                ev = e,\r\n                deltaX = e.deltaX === undefined ? e.NativeEvent.deltaX : e.deltaX,\r\n                deltaY = e.deltaY === undefined ? e.NativeEvent.deltaY : e.deltaY,\r\n                deltaMode = e.deltaMode === undefined ? e.NativeEvent.deltaMode : e.deltaMode;\r\n            if (wheeling) {\r\n                return;\r\n            }\r\n            if (self.dispatchEvent('wheel', {NativeEvent: e})) {\r\n                return;\r\n            }\r\n            var e = e.NativeEvent || e;\r\n            self.touchHaltAnimation = true;\r\n            l = self.scrollBox.scrollLeft;\r\n            t = self.scrollBox.scrollTop;\r\n            if (self.hasFocus) {\r\n                //BUG Issue 42: https://github.com/TonyGermaneri/canvas-datagrid/issues/42\r\n                //https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n                if (deltaMode === 1) {\r\n                    // line mode = 17 pixels per line\r\n                    deltaY = deltaY * 17;\r\n                }\r\n                if ((self.scrollBox.scrollTop  < self.scrollBox.scrollHeight && deltaY > 0)\r\n                        || (self.scrollBox.scrollLeft < self.scrollBox.scrollWidth && deltaX > 0)\r\n                        || (self.scrollBox.scrollTop > 0 && deltaY < 0)\r\n                        || (self.scrollBox.scrollLeft > 0 && deltaX < 0)) {\r\n                    ev.preventDefault(e);\r\n                }\r\n                wheeling = setTimeout(function () {\r\n                    wheeling = undefined;\r\n                    self.scrollBox.scrollTo(deltaX + l, deltaY + t);\r\n                }, 1);\r\n            }\r\n        };\r\n        self.pasteItem = function (clipData, x, y, mimeType) {\r\n            var l, s = self.getVisibleSchema(), yi = y - 1, sel = [];\r\n            function normalizeRowData(importingRow, existingRow, offsetX, schema, mimeType, rowIndex) {\r\n                var r = existingRow;\r\n                if (!Array.isArray(importingRow) && importingRow !== null && typeof importingRow === 'object') {\r\n                    importingRow = Object.keys(importingRow).map(function (colKey) {\r\n                        return importingRow[colKey];\r\n                    });\r\n                }\r\n                if (/^text\\/html/.test(mimeType)) {\r\n                    importingRow = importingRow.substring(4, importingRow.length - 5).split('</td><td>');\r\n                }\r\n                if (typeof importingRow === 'string') {\r\n                    importingRow = [importingRow];\r\n                }\r\n                sel[rowIndex] = [];\r\n                importingRow.forEach(function (cellData, colIndex) {\r\n                    var cName = schema[colIndex + offsetX].name;\r\n                    if (importingRow[colIndex] === undefined || importingRow[colIndex] === null) {\r\n                        r[cName] = existingRow[cName];\r\n                        return;\r\n                    }\r\n                    sel[rowIndex].push(colIndex + offsetX);\r\n                    r[cName] = importingRow[colIndex];\r\n                });\r\n                return r;\r\n            }\r\n            if (/^text\\/html/.test(mimeType)) {\r\n                if (!/^(<meta[^>]+>)?<table>/.test(clipData.substring(0, 29))) {\r\n                    console.warn('Unrecognized HTML format.  HTML must be a simple table, e.g.: <table><tr><td>data</td></tr></table>.  Data with the mime type text/html not in this format will not be imported as row data.');\r\n                    return;\r\n                }\r\n                // strip table beginning and ending off, then split at rows\r\n                clipData = clipData.substring(clipData.indexOf('<table><tr>') + 11, clipData.length - 13).split('</tr><tr>');\r\n                // ditch any headers on the table\r\n                clipData = clipData.filter(function (row) {\r\n                    return !/^<th>|^<thead>/.test(row);\r\n                });\r\n            } else {\r\n                clipData = clipData.split('\\n');\r\n            }\r\n            l = clipData.length;\r\n            clipData.forEach(function (rowData) {\r\n                yi += 1;\r\n                var i = self.orders.rows[yi];\r\n                self.data[i] = normalizeRowData(rowData, self.data[i], x, s, mimeType, i);\r\n            });\r\n            self.selections = sel;\r\n            return l;\r\n        };\r\n        self.getNextVisibleColumnIndex = function (visibleColumnIndex) {\r\n            var x, s = self.getVisibleSchema();\r\n            for (x = 0; x < s.length; x += 1) {\r\n                if (s[x].columnIndex === visibleColumnIndex) {\r\n                    return s[x + 1].columnIndex;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n        self.getVisibleColumnIndexOf = function (columnIndex) {\r\n            var x, s = self.getVisibleSchema();\r\n            for (x = 0; x < s.length; x += 1) {\r\n                if (s[x].columnIndex === columnIndex) {\r\n                    return x;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n        self.paste = function (e) {\r\n            var d;\r\n            function getItem(dti) {\r\n                var type = dti.type;\r\n                dti.getAsString(function (s) {\r\n                    self.pasteItem(s, self.getVisibleColumnIndexOf(self.activeCell.columnIndex), self.activeCell.rowIndex, type);\r\n                    self.draw();\r\n                });\r\n            }\r\n            d = Array.prototype.filter.call(e.clipboardData.items, function (dti) {\r\n                return dti.type === 'text/html';\r\n            })[0] || Array.prototype.filter(function (dti) {\r\n                return dti.type === 'text/csv';\r\n            })[0] || Array.prototype.filter(function (dti) {\r\n                return dti.type === 'text/plain';\r\n            })[0];\r\n            if (!d) {\r\n                console.warn('Cannot find supported clipboard data type.  Supported types are text/html, text/csv, text/plain.');\r\n                return;\r\n            }\r\n            getItem(d);\r\n        };\r\n        self.cut = function (e) {\r\n            self.copy(e);\r\n            self.forEachSelectedCell(function (data, index, colName) {\r\n                data[index][colName] = '';\r\n            });\r\n        };\r\n        self.copy = function (e) {\r\n            if (self.dispatchEvent('copy', {NativeEvent: e})) { return; }\r\n            if (!self.hasFocus || !e.clipboardData) { return; }\r\n            var t,\r\n                d,\r\n                data = (self.data || []),\r\n                tableRows = [],\r\n                textRows = [],\r\n                outputHeaders = {},\r\n                outputHeaderKeys,\r\n                sData = self.getSelectedData(),\r\n                s = self.getSchema();\r\n            function htmlSafe(v) {\r\n                return v.replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n            }\r\n            function fCopyCell(v) {\r\n                v = v === null || v === undefined ? '' : v;\r\n                return '<td>' + (typeof v === 'string' ? htmlSafe(v) : v) + '</td>';\r\n            }\r\n            function addHeaders(headers, useHtml) {\r\n                if (!s.length || headers.length < 2) { return ''; }\r\n                var h = [];\r\n                if (useHtml) {\r\n                    h.push('<tr>');\r\n                }\r\n                s.forEach(function (column, columnIndex) {\r\n                    // intentional redefinition of column\r\n                    column = s[self.orders.columns[columnIndex]];\r\n                    if (!column.hidden && headers.indexOf(column.name) !== -1) {\r\n                        var ev = {NativeEvent: e, column: column};\r\n                        if(self.dispatchEvent('copyonschema', ev)) {\r\n                            column = ev.column;\r\n                        }\r\n\r\n                        var hVal = (column.name || column.title) || '';\r\n                        if (useHtml) {\r\n                            h.push('<th>' + htmlSafe(hVal) + '</th>');\r\n                        } else {\r\n                            h.push('\"' + hVal.replace(/\"/g, '\"\"') + '\"');\r\n                        }\r\n                    }\r\n                });\r\n                h.push(useHtml ? '</tr>' : '\\n');\r\n                return h.join(useHtml ? '' : ',');\r\n            }\r\n            function addCellValue(val, trRow, textRow, column) {\r\n                // escape strings\r\n                if (val !== null\r\n                        && val !== false\r\n                        && val !== undefined\r\n                        && val.replace) {\r\n                    trRow.push(fCopyCell(val));\r\n                    textRow.push('\"' + val.replace(/\"/g, '\"\"') + '\"');\r\n                    return;\r\n                }\r\n                if (val !== undefined) {\r\n                    textRow.push(val);\r\n                    trRow.push(fCopyCell(val));\r\n                    return;\r\n                }\r\n                // issue #66\r\n                textRow.push('');\r\n                trRow.push('<td>&nbsp;</td>');\r\n            }\r\n            if (sData.length > 0) {\r\n                sData.forEach(function (row) {\r\n                    var rowKeys = Object.keys(row);\r\n                    if (row) {\r\n                        var trRow = [],\r\n                            textRow = [],\r\n                            sSorted = [];\r\n                        // HACK: https://github.com/TonyGermaneri/canvas-datagrid/issues/181\r\n                        // I can't use sort here or O(1), so hacks\r\n                        s.forEach(function (column, columnIndex) {\r\n                            sSorted.push(s[self.orders.columns[columnIndex]]);\r\n                        });\r\n                        sSorted.forEach(function (column, columnIndex) {\r\n                            if (rowKeys.indexOf(column.name) !== -1) {\r\n                                outputHeaders[column.name] = true;\r\n                                // escape strings\r\n                                addCellValue(row[column.name], trRow, textRow, column);\r\n                            }\r\n                        });\r\n                        tableRows.push(trRow.join(''));\r\n                        textRows.push(textRow.join(','));\r\n                    }\r\n                });\r\n                outputHeaderKeys = Object.keys(outputHeaders);\r\n                t = addHeaders(outputHeaderKeys) + textRows.join('\\n');\r\n                d = '<table>' + addHeaders(outputHeaderKeys, true) + '<tr>' + tableRows.join('</tr><tr>') + '</tr></table>';\r\n                if (outputHeaderKeys.length === 1) {\r\n                    // if there was only one cell selected, remove the quotes from the string\r\n                    t = t.substring(1, t.length -1);\r\n                }\r\n                e.clipboardData.setData('text/html', d);\r\n                e.clipboardData.setData('text/plain', t);\r\n                e.clipboardData.setData('text/csv', t);\r\n                e.clipboardData.setData('application/json', JSON.stringify(sData));\r\n                e.preventDefault();\r\n            }\r\n        };\r\n        return;\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/events.js\n// module id = 4\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true, plusplus: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        var touchTimerMs = 50,\r\n            debounceTouchMove,\r\n            touchMoving,\r\n            touchScrollTimeout;\r\n        self.scrollAnimation = {};\r\n        self.touchDelta = {};\r\n        self.touchAnimateTo = {};\r\n        self.animationFrames = 0;\r\n        self.getTouchPos = function (e, touchIndex) {\r\n            var t = touchIndex ? e.touches[touchIndex] : e.touches[0],\r\n                rect = self.canvas.getBoundingClientRect(),\r\n                pos;\r\n            if (!t) { return; }\r\n            pos = {\r\n                x: t.clientX - rect.left,\r\n                y: t.clientY - rect.top\r\n            };\r\n            if (self.isChildGrid) {\r\n                pos.x -= self.canvasOffsetLeft;\r\n                pos.y -= self.canvasOffsetTop;\r\n            }\r\n            return {\r\n                x: pos.x,\r\n                y: pos.y,\r\n                rect: rect\r\n            };\r\n        };\r\n        // shamelessly stolen from from https://gist.github.com/gre/1650294\r\n        self.easingFunctions = {\r\n            linear: function (t) { return t; },\r\n            easeInQuad: function (t) { return t * t; },\r\n            easeOutQuad: function (t) { return t * (2 - t); },\r\n            easeInOutQuad: function (t) { return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; },\r\n            easeInCubic: function (t) { return t * t * t; },\r\n            easeOutCubic: function (t) { return (--t) * t * t + 1; },\r\n            easeInOutCubic: function (t) { return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; },\r\n            easeInQuart: function (t) { return t * t * t * t; },\r\n            easeOutQuart: function (t) { return 1 - (--t) * t * t * t; },\r\n            easeInOutQuart: function (t) { return t < 0.5 ? 8 * t  * t  * t * t : 1 - 8 * (--t) * t * t * t; },\r\n            easeInQuint: function (t) { return t * t * t * t * t; },\r\n            easeOutQuint: function (t) { return 1 + (--t) * t *  t * t * t; },\r\n            easeInOutQuint: function (t) { return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t; }\r\n        };\r\n        self.easing = function (t, b, c, d) {\r\n            return c * self.easingFunctions[self.attributes.touchEasingMethod](t / d) + b;\r\n        };\r\n        self.calculatePPSTimed = function () {\r\n            self.xPPST = -((self.touchDelta.x - self.touchSigmaTimed.x) / (self.touchDelta.t - self.touchSigmaTimed.t));\r\n            self.yPPST = -((self.touchDelta.y - self.touchSigmaTimed.y) / (self.touchDelta.t - self.touchSigmaTimed.t));\r\n            self.touchSigmaTimed = {\r\n                x: self.touchDelta.x,\r\n                y: self.touchDelta.y,\r\n                t: performance.now()\r\n            };\r\n        };\r\n        self.calculatePPS = function () {\r\n            self.xPPS = -((self.touchDelta.x - self.touchSigma.x) / (self.touchDelta.t - self.touchSigma.t));\r\n            self.yPPS = -((self.touchDelta.y - self.touchSigma.y) / (self.touchDelta.t - self.touchSigma.t));\r\n            self.touchSigma = {\r\n                x: self.touchDelta.x,\r\n                y: self.touchDelta.y,\r\n                t: performance.now()\r\n            };\r\n        };\r\n        self.touchEndAnimation = function () {\r\n            if (!self.canvas || !self.scrollBox.scrollTo) { return requestAnimationFrame(self.touchEndAnimation); }\r\n            var n = performance.now(),\r\n                d = self.attributes.touchReleaseAnimationDurationMs,\r\n                t;\r\n            t = n - self.touchDelta.t;\r\n            self.animationFrames += 1;\r\n            self.scrollAnimation.x = self.easing(t, self.touchDelta.scrollLeft, self.touchAnimateTo.x, d);\r\n            self.scrollAnimation.y = self.easing(t, self.touchDelta.scrollTop, self.touchAnimateTo.y, d);\r\n            if (t > d || (self.scrollAnimation.y === self.scrollBox.scrollTop\r\n                    && self.scrollAnimation.x === self.scrollBox.scrollLeft) || self.stopAnimation) {\r\n                return;\r\n            }\r\n            self.scrollBox.scrollTo(self.scrollAnimation.x, self.scrollAnimation.y);\r\n            requestAnimationFrame(self.touchEndAnimation);\r\n        };\r\n        self.touchEditCell = function (cell) {\r\n            self.beginEditAt(cell.columnIndex, cell.rowIndex);\r\n        };\r\n        self.touchCell = function (e) {\r\n            return function () {\r\n                clearInterval(self.calculatePPSTimer);\r\n                var i, pos = self.getTouchPos(e);\r\n                if (Math.abs(self.touchDelta.x) + Math.abs(self.touchDelta.y) < self.attributes.touchDeadZone) {\r\n                    i = self.getCellAt(pos.x, pos.y);\r\n                    if (!i) { return; }\r\n                    if (self.touchingCell && self.touchingCell.rowIndex === i.rowIndex\r\n                            && self.touchingCell.columnIndex === i.columnIndex) {\r\n                        self.touchEditCell(i);\r\n                        return;\r\n                    }\r\n                    if (self.input && self.input.editCell) {\r\n                        self.endEdit();\r\n                    }\r\n                    self.touchingCell = i;\r\n                    self.selectArea({\r\n                        top: i.rowIndex,\r\n                        bottom: i.rowIndex,\r\n                        left: i.columnIndex,\r\n                        right: i.columnIndex\r\n                    });\r\n                    self.draw(true);\r\n                }\r\n            };\r\n        };\r\n        self.touchstart = function (e) {\r\n            if (e.changedTouches[0]) {\r\n                self.touchStart = self.getTouchPos(e);\r\n                self.startingCell = self.getCellAt(self.touchStart.x, self.touchStart.y, true);\r\n            }\r\n            if (self.dispatchEvent('touchstart', {NativeEvent: e, cell: self.startingCell})) { return; }\r\n            self.disposeContextMenu();\r\n            clearInterval(self.calculatePPSTimer);\r\n            clearTimeout(self.touchContextTimeout);\r\n            self.touchStartEvent = e;\r\n            self.stopAnimation = true;\r\n            self.animationFrames = 0;\r\n            self.stopPropagation(e);\r\n            e.preventDefault();\r\n            if (e.touches.length === 1 && e.changedTouches[0] && !self.zoomAltered) {\r\n                self.touchLength = 1;\r\n                self.touchStart = self.touchStart || self.touchStart1;\r\n                self.touchScrollStart = {\r\n                    x: self.scrollBox.scrollLeft,\r\n                    y: self.scrollBox.scrollTop,\r\n                    t: performance.now()\r\n                };\r\n                self.touchDelta = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    scrollLeft: self.scrollBox.scrollLeft,\r\n                    scrollTop: self.scrollBox.scrollTop,\r\n                    t: self.touchScrollStart.t\r\n                };\r\n                self.touchSigma = {\r\n                    x: self.touchDelta.x,\r\n                    y: self.touchDelta.y,\r\n                    t: self.touchDelta.t\r\n                };\r\n                self.touchSigmaTimed = {\r\n                    x: self.touchDelta.x,\r\n                    y: self.touchDelta.y,\r\n                    t: self.touchDelta.t\r\n                };\r\n                self.touchContextTimeout = setTimeout(function () {\r\n                    self.contextmenuEvent(e, self.touchStart);\r\n                }, self.attributes.touchContextMenuTimeMs);\r\n                self.calculatePPSTimer = setInterval(self.calculatePPSTimed, touchTimerMs);\r\n                if (self.startingCell && (self.startingCell.isGrid || ['tree', 'inherit'].indexOf(self.startingCell.context) !== -1)) {\r\n                    self.hasFocus = false;\r\n                    return;\r\n                }\r\n                self.hasFocus = true;\r\n                if (self.startingCell.isHeader) {\r\n                    if (self.startingCell.isRowHeader) {\r\n                        self.selectArea({\r\n                            top: self.startingCell.rowIndex,\r\n                            bottom: self.startingCell.rowIndex,\r\n                            left: 0,\r\n                            right: self.getVisibleSchema().length - 1,\r\n                        });\r\n                        self.draw(true);\r\n                    } else if (self.startingCell.isColumnHeader) {\r\n                        if (self.attributes.columnHeaderClickBehavior === 'sort') {\r\n                            if (self.orderBy === self.startingCell.header.name) {\r\n                                self.orderDirection = self.orderDirection === 'asc' ? 'desc' : 'asc';\r\n                            } else {\r\n                                self.orderDirection = 'asc';\r\n                            }\r\n                            self.order(self.startingCell.header.name, self.orderDirection);\r\n                        }\r\n                        if (self.attributes.columnHeaderClickBehavior === 'select') {\r\n                            self.selectArea({\r\n                                top: 0,\r\n                                bottom: self.data.length - 1,\r\n                                left: self.startingCell.columnIndex,\r\n                                right: self.startingCell.columnIndex,\r\n                            });\r\n                            self.draw(true);\r\n                        }\r\n                    }\r\n                    self.touchEndEvents(e);\r\n                    return;\r\n                }\r\n            }\r\n            if (self.zoomAltered) { return; }\r\n            document.body.addEventListener('touchmove', self.touchmove, {passive: false});\r\n            document.body.addEventListener('touchend', self.touchend, false);\r\n            document.body.addEventListener('touchcancel', self.touchcancel, false);\r\n            self.draw(true);\r\n        };\r\n        self.touchSelect = function (cell, handleType) {\r\n            if (cell.rowIndex === undefined || cell.columnIndex === undefined) { return; }\r\n            self.touchSelecting = true;\r\n            var bounds = self.getSelectionBounds();\r\n            if (handleType === 'selection-handle-bl'\r\n                    && cell.rowIndex >= bounds.top\r\n                    && cell.columnIndex <= bounds.right) {\r\n                bounds.bottom = cell.rowIndex;\r\n                bounds.left = cell.columnIndex;\r\n            } else if (handleType === 'selection-handle-tl'\r\n                    && cell.rowIndex <= bounds.bottom\r\n                    && cell.columnIndex <= bounds.right) {\r\n                bounds.top = cell.rowIndex;\r\n                bounds.left = cell.columnIndex;\r\n            } else if (handleType === 'selection-handle-tr'\r\n                    && cell.rowIndex <= bounds.bottom\r\n                    && cell.columnIndex >= bounds.left) {\r\n                bounds.top = cell.rowIndex;\r\n                bounds.right = cell.columnIndex;\r\n            } else if (handleType === 'selection-handle-br'\r\n                    && cell.rowIndex >= bounds.top\r\n                    && cell.columnIndex >= bounds.left) {\r\n                bounds.bottom = cell.rowIndex;\r\n                bounds.right = cell.columnIndex;\r\n            }\r\n            if (self.attributes.selectionMode === 'row' || cell.rowIndex === -1) {\r\n                bounds.left = 0;\r\n                bounds.right = self.getSchema().length - 1;\r\n            } else {\r\n                bounds.left = Math.max(0, bounds.left);\r\n            }\r\n            self.selectArea(bounds);\r\n            self.draw(true);\r\n        };\r\n        function touchMove(e) {\r\n            var ch, rw, rScrollZone, lScrollZone, bScrollZone, tScrollZone, sbw, t1, t2;\r\n            if (self.dispatchEvent('beforetouchmove', {NativeEvent: e})) { return; }\r\n            clearTimeout(touchScrollTimeout);\r\n            if (e.changedTouches[0]) {\r\n                self.touchPosition = self.getTouchPos(e);\r\n            }\r\n            if (e.changedTouches[1]) {\r\n                self.touchPosition1 = self.getTouchPos(e, 1);\r\n            }\r\n            if (Math.abs(self.touchDelta.x) + Math.abs(self.touchDelta.y) > self.attributes.touchDeadZone) {\r\n                clearTimeout(self.touchContextTimeout);\r\n            }\r\n            if (e.touches.length === 2 && self.touchPosition && self.touchPosition1) {\r\n                t1 = self.touchPosition.y;\r\n                t2 = self.touchPosition1.y;\r\n                if (!self.zoomDeltaStart) {\r\n                    self.zoomDeltaStart = Math.abs(t1 - t2);\r\n                    self.startScale = self.scale;\r\n                }\r\n                self.touchLength = 2;\r\n                self.scaleDelta = self.zoomDeltaStart - Math.abs(t1 - t2);\r\n                self.scale = self.startScale - (self.scaleDelta * self.attributes.touchZoomSensitivity);\r\n                self.scale = Math.min(Math.max(self.scale, self.attributes.touchZoomMin), self.attributes.touchZoomMax);\r\n                self.zoomAltered = true;\r\n                self.resize(true);\r\n                self.resizeChildGrids();\r\n                return;\r\n            }\r\n            if (self.zoomAltered) { return; }\r\n            self.touchLength = 1;\r\n            self.touchPosition = self.touchPosition || self.touchPosition1;\r\n            ch = self.getColumnHeaderCellHeight();\r\n            rw = self.getRowHeaderCellWidth();\r\n            rScrollZone = self.width - self.style.scrollBarWidth - self.touchPosition.x < self.attributes.selectionScrollZone;\r\n            lScrollZone = self.touchPosition.x - rw < self.attributes.selectionScrollZone;\r\n            bScrollZone = self.height - self.style.scrollBarWidth - self.touchPosition.y < self.attributes.selectionScrollZone;\r\n            tScrollZone = self.touchPosition.y - ch < self.attributes.selectionScrollZone;\r\n            sbw = self.style.scrollBarWidth;\r\n            function touchScroll() {\r\n                var x = self.scrollBox.scrollLeft,\r\n                    y = self.scrollBox.scrollTop;\r\n                x += (rScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                y += (bScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                y -= (tScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                x -= (lScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                self.scrollBox.scrollTo(x, y);\r\n                touchScrollTimeout = setTimeout(touchScroll, self.attributes.scrollRepeatRate);\r\n            }\r\n            e.stopPropagation();\r\n            self.touchDelta = {\r\n                x: self.touchPosition.x - self.touchStart.x,\r\n                y: self.touchPosition.y - self.touchStart.y,\r\n                scrollLeft: self.scrollBox.scrollLeft,\r\n                scrollTop: self.scrollBox.scrollTop,\r\n                t: performance.now()\r\n            };\r\n            self.currentCell = self.getCellAt(self.touchPosition.x, self.touchPosition.y);\r\n            self.dispatchEvent('touchmove', {NativeEvent: e, cell: self.currentCell});\r\n            self.calculatePPS();\r\n            self.touchDuration = performance.now() - self.touchScrollStart.t;\r\n            self.stopAnimation = true;\r\n            self.animationFrames = 0;\r\n            if (self.touchSelecting && (rScrollZone || lScrollZone || tScrollZone || bScrollZone)) {\r\n                touchScroll();\r\n            }\r\n            if (/vertical-scroll-/.test(self.startingCell.style)) {\r\n                self.scrollBox.scrollTop = self.scrollBox.scrollHeight\r\n                    * ((self.touchPosition.y - ch - sbw) / (self.scrollBox.height - sbw - ch));\r\n                return;\r\n            }\r\n            if (/horizontal-scroll-/.test(self.startingCell.style)) {\r\n                self.scrollBox.scrollLeft = self.scrollBox.scrollWidth\r\n                    * ((self.touchPosition.x - rw - sbw) / (self.scrollBox.width - sbw - rw));\r\n                return;\r\n            }\r\n            if (/selection-handle-/.test(self.startingCell.style)) {\r\n                self.touchSelect(self.currentCell, self.startingCell.style);\r\n                return;\r\n            }\r\n            self.scrollBox.scrollTo(self.touchScrollStart.x - self.touchDelta.x,\r\n                self.touchScrollStart.y - self.touchDelta.y);\r\n        };\r\n        self.touchmove = function (e) {\r\n            if (touchMoving) {\r\n                return;\r\n            }\r\n            requestAnimationFrame(function () {\r\n                touchMoving = true;\r\n                touchMove(e);\r\n                touchMoving = false;\r\n            });\r\n        };\r\n        self.touchEndEvents = function (e) {\r\n            self.zoomDeltaStart = undefined;\r\n            self.touchSelecting = false;\r\n            clearInterval(self.touchScrollTimeout);\r\n            clearInterval(self.touchContextTimeout);\r\n            clearInterval(self.calculatePPSTimer);\r\n            e.stopPropagation();\r\n            document.body.removeEventListener('touchmove', self.touchmove, {passive: false});\r\n            document.body.removeEventListener('touchend', self.touchend, false);\r\n            document.body.removeEventListener('touchcancel', self.touchcancel, false);\r\n        };\r\n        self.touchend = function (e) {\r\n            if (self.dispatchEvent('touchend', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            self.zoomDeltaStart = undefined;\r\n            if (e.changedTouches[0]) {\r\n                self.touchPosition = undefined;\r\n            }\r\n            if (e.changedTouches[1]) {\r\n                self.touchPosition1 = undefined;\r\n            }\r\n            if (self.zoomAltered) {\r\n                if (e.touches.length === 0) {\r\n                    self.zoomAltered = false;\r\n                }\r\n                return;\r\n            }\r\n            var dz = Math.abs(self.touchDelta.x) + Math.abs(self.touchDelta.y) < self.attributes.touchDeadZone;\r\n            if (isNaN(self.xPPS)) {\r\n                self.xPPS = 0;\r\n            }\r\n            if (isNaN(self.yPPS)) {\r\n                self.yPPS = 0;\r\n            }\r\n            if (isNaN(self.xPPST)) {\r\n                self.xPPST = 0;\r\n            }\r\n            if (isNaN(self.yPPST)) {\r\n                self.yPPST = 0;\r\n            }\r\n            self.touchAnimateTo.x = self.xPPS * self.attributes.touchReleaseAcceleration;\r\n            self.touchAnimateTo.y = self.yPPS * self.attributes.touchReleaseAcceleration;\r\n            self.calculatePPSTimed();\r\n            if (dz && !self.contextMenu) {\r\n                self.touchCell(self.touchStartEvent)();\r\n            } else if (self.animationFrames === 0\r\n                    && (Math.abs(self.xPPST) > self.attributes.scrollAnimationPPSThreshold\r\n                        || Math.abs(self.yPPST) > self.attributes.scrollAnimationPPSThreshold)\r\n                    && !/-scroll-/.test(self.startingCell.style)\r\n                    && !dz) {\r\n                self.stopAnimation = false;\r\n                self.touchEndAnimation();\r\n            }\r\n            self.touchEndEvents(e);\r\n        };\r\n        self.touchcancel = function (e) {\r\n            if (self.dispatchEvent('touchcancel', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            self.touchEndEvents(e);\r\n        };\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/touch.js\n// module id = 5\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals HTMLElement: false, Reflect: false, define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self, ctor) {\r\n        self.scale = 1;\r\n        self.orders = {\r\n            rows: [],\r\n            columns: []\r\n        };\r\n        self.appliedInlineStyles = {};\r\n        self.cellGridAttributes = {};\r\n        self.treeGridAttributes = {};\r\n        self.visibleRowHeights = [];\r\n        self.hasFocus = false;\r\n        self.activeCell = {\r\n            columnIndex: 0,\r\n            rowIndex: 0\r\n        };\r\n        self.innerHTML = '';\r\n        self.storageName = 'canvasDataGrid';\r\n        self.invalidSearchExpClass = 'canvas-datagrid-invalid-search-regExp';\r\n        self.localStyleLibraryStorageKey = 'canvas-datagrid-user-style-library';\r\n        self.dataType = 'application/x-canvas-datagrid';\r\n        self.orderBy = null;\r\n        self.orderDirection = 'asc';\r\n        self.orderings = {\r\n            columns: [],\r\n            add: function (orderBy, orderDirection, sortFunction) {\r\n                self.orderings.columns = self.orderings.columns.filter(function (col) {\r\n                    return col.orderBy !== orderBy;\r\n                });\r\n                self.orderings.columns.push({\r\n                    orderBy: orderBy,\r\n                    orderDirection: orderDirection,\r\n                    sortFunction: sortFunction\r\n                });\r\n            },\r\n            sort: function () {\r\n                self.orderings.columns.forEach(function (col) {\r\n                    self.data.sort(col.sortFunction(col.orderBy, col.orderDirection));\r\n                });\r\n            }\r\n        };\r\n        self.columnFilters = {};\r\n        self.filters = {};\r\n        self.frozenRow = 0;\r\n        self.frozenColumn = 0;\r\n        self.ellipsisCache = {};\r\n        self.scrollCache = { x: [], y: [] };\r\n        self.scrollBox = {};\r\n        self.visibleRows = [];\r\n        self.visibleCells = [];\r\n        self.sizes = {\r\n            rows: {},\r\n            columns: {},\r\n            trees: {}\r\n        };\r\n        self.currentFilter = function () {\r\n            return true;\r\n        };\r\n        self.selections = [];\r\n        self.hovers = {};\r\n        self.attributes = {};\r\n        self.style = {};\r\n        self.formatters = {};\r\n        self.sorters = {};\r\n        self.parsers = {};\r\n        self.schemaHashes = {};\r\n        self.events = {};\r\n        self.changes = [];\r\n        self.scrollIndexTop = 0;\r\n        self.scrollPixelTop = 0;\r\n        self.scrollIndexLeft = 0;\r\n        self.scrollPixelLeft = 0;\r\n        self.childGrids = {};\r\n        self.openChildren = {};\r\n        self.scrollModes = [\r\n            'vertical-scroll-box',\r\n            'vertical-scroll-top',\r\n            'vertical-scroll-bottom',\r\n            'horizontal-scroll-box',\r\n            'horizontal-scroll-right',\r\n            'horizontal-scroll-left'\r\n        ];\r\n        self.componentL1Events = {};\r\n        self.eventNames = ['afterdraw', 'afterrendercell', 'attributechanged', 'beforebeginedit',\r\n            'beforecreatecellgrid', 'beforedraw', 'beforeendedit', 'beforerendercell', 'beforerendercellgrid',\r\n            'beginedit', 'cellmouseout', 'cellmouseover', 'click', 'collapsetree', 'contextmenu', 'copy',\r\n            'datachanged', 'dblclick', 'endedit', 'expandtree', 'formatcellvalue', 'keydown', 'keypress',\r\n            'keyup', 'mousedown', 'mousemove', 'mouseup', 'newrow', 'ordercolumn', 'rendercell', 'rendercellgrid',\r\n            'renderorderbyarrow', 'rendertext', 'rendertreearrow', 'reorder', 'reordering', 'resize',\r\n            'resizecolumn', 'resizerow', 'schemachanged', 'scroll', 'selectionchanged', 'stylechanged',\r\n            'touchcancel', 'touchend', 'touchmove', 'touchstart', 'wheel'];\r\n        self.mouse = { x: 0, y: 0};\r\n        self.getSelectedData = function (expandToRow) {\r\n            var d = [], s = self.getSchema(), l = self.data.length;\r\n            if (l === 0) { return []; }\r\n            self.selections.forEach(function (row, index) {\r\n                if (!row) { return; }\r\n                if (index === l) { return; }\r\n                if (row.length === 0) {\r\n                    d[index] = null;\r\n                    return;\r\n                }\r\n                d[index] = {};\r\n                row.forEach(function (col) {\r\n                    var orderedIndex;\r\n                    if (col === -1 || !s[col]) { return; }\r\n                    orderedIndex = self.orders.columns[col];\r\n                    if (!expandToRow && s[orderedIndex].hidden) { return; }\r\n                    if (self.data[index]) {\r\n                        d[index][s[orderedIndex].name] = self.data[index][s[orderedIndex].name];\r\n                    }\r\n                });\r\n            });\r\n            return d;\r\n        };\r\n        self.getColumnHeaderCellHeight = function () {\r\n            if (!self.attributes.showColumnHeaders) { return 0; }\r\n            return ((self.sizes.rows[-1] || self.style.columnHeaderCellHeight) * self.scale);\r\n        };\r\n        self.getRowHeaderCellWidth = function () {\r\n            if (!self.attributes.showRowHeaders) { return 0; }\r\n            return (self.sizes.columns[-1] || self.style.rowHeaderCellWidth) * self.scale;\r\n        };\r\n        self.setStorageData = function () {\r\n            if (!self.attributes.saveAppearance || !self.attributes.name) { return; }\r\n            var visibility = {};\r\n            self.getSchema().forEach(function (column) {\r\n                visibility[column.name] = !column.hidden;\r\n            });\r\n            localStorage.setItem(self.storageName + '-' + self.attributes.name, JSON.stringify({\r\n                sizes: {\r\n                    rows: self.sizes.rows,\r\n                    columns: self.sizes.columns\r\n                },\r\n                orders: {\r\n                    rows: self.orders.rows,\r\n                    columns: self.orders.columns\r\n                },\r\n                orderBy: self.orderBy,\r\n                orderDirection: self.orderDirection,\r\n                visibility: visibility\r\n            }));\r\n        };\r\n        self.getSchema = function () {\r\n            return self.schema || self.tempSchema || [];\r\n        };\r\n        function fillArray(low, high) {\r\n            var i = [], x;\r\n            for (x = low; x <= high; x += 1) {\r\n                i[x] = x;\r\n            }\r\n            return i;\r\n        }\r\n        self.createColumnOrders = function () {\r\n            var s = self.getSchema();\r\n            self.orders.columns = fillArray(0, s.length - 1);\r\n        };\r\n        self.createRowOrders = function () {\r\n            self.orders.rows = fillArray(0, self.data.length - 1);\r\n        };\r\n        self.getVisibleSchema = function () {\r\n            return self.getSchema().filter(function (col) {\r\n                return !col.hidden;\r\n            });\r\n        };\r\n        self.applyDefaultValue = function (row, header) {\r\n            var d = header.defaultValue || '';\r\n            if (typeof d === 'function') {\r\n                d = d.apply(self.intf, [header]);\r\n            }\r\n            row[header.name] = d;\r\n        };\r\n        self.createNewRowData = function () {\r\n            self.newRow = {};\r\n            self.getSchema().forEach(function forEachHeader(header) {\r\n                self.applyDefaultValue(self.newRow, header);\r\n            });\r\n        };\r\n        self.getSchemaNameHash = function (key) {\r\n            var n = 0;\r\n            while (self.schemaHashes[key]) {\r\n                n += 1;\r\n                key = key + n;\r\n            }\r\n            return key;\r\n        };\r\n        self.filter = function (type) {\r\n            var f = self.filters[type];\r\n            if (!f && type !== undefined) {\r\n                console.warn('Cannot find filter for type %s, falling back to substring match.', type);\r\n                f = self.filters.string;\r\n            }\r\n            return f;\r\n        };\r\n        self.applyFilter = function () {\r\n            self.refreshFromOrigialData();\r\n            Object.keys(self.columnFilters).forEach(function (filter) {\r\n                var header = self.getHeaderByName(filter);\r\n                if (!header) {\r\n                    return;\r\n                }\r\n                self.currentFilter = header.filter || self.filter(header.type || 'string');\r\n                self.data = self.data.filter(function (row) {\r\n                    return self.currentFilter(row[filter], self.columnFilters[filter]);\r\n                });\r\n            });\r\n            self.resize();\r\n            self.draw(true);\r\n        };\r\n        self.applyDataTransforms = function () {\r\n            self.applyFilter();\r\n            self.orderings.sort();\r\n        }\r\n        self.getBestGuessDataType = function (columnName, data) {\r\n            var t, x, l = data.length;\r\n            for (x = 0; x < l; x += 1) {\r\n                if (data[x] !== undefined && data[x] !== null && [null, undefined].indexOf(data[x][columnName]) !== -1) {\r\n                    t = typeof data[x];\r\n                    return t === 'object' ? 'string' : t;\r\n                }\r\n            }\r\n            return 'string';\r\n        };\r\n        self.drawChildGrids = function () {\r\n            Object.keys(self.childGrids).forEach(function (gridKey) {\r\n                self.childGrids[gridKey].draw();\r\n            });\r\n        };\r\n        self.resizeChildGrids = function () {\r\n            Object.keys(self.childGrids).forEach(function (gridKey) {\r\n                self.childGrids[gridKey].resize();\r\n            });\r\n        };\r\n        self.autoScrollZone = function (e, x, y, ctrl) {\r\n            var setTimer,\r\n                rowHeaderCellWidth = self.getRowHeaderCellWidth(),\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight();\r\n            if (y !== -1) {\r\n                if (x > self.width - self.attributes.selectionScrollZone && x < self.width) {\r\n                    self.scrollBox.scrollLeft += self.attributes.selectionScrollIncrement;\r\n                    setTimer = true;\r\n                }\r\n                if (x - self.attributes.selectionScrollZone - rowHeaderCellWidth < 0) {\r\n                    self.scrollBox.scrollLeft -= self.attributes.selectionScrollIncrement;\r\n                    setTimer = true;\r\n                }\r\n            }\r\n            if (y !== -1) {\r\n                if (y > self.height - self.attributes.selectionScrollZone && y < self.height) {\r\n                    self.scrollBox.scrollTop += self.attributes.selectionScrollIncrement;\r\n                    setTimer = true;\r\n                }\r\n                if (y - self.attributes.selectionScrollZone - columnHeaderCellHeight < 0) {\r\n                    self.scrollBox.scrollTop -= self.attributes.selectionScrollIncrement;\r\n                    setTimer = true;\r\n                }\r\n            }\r\n            if (setTimer && !ctrl && self.currentCell && self.currentCell.columnIndex !== -1) {\r\n                self.scrollTimer = setTimeout(self.mousemove, self.attributes.scrollRepeatRate, e);\r\n            }\r\n        };\r\n        self.refreshFromOrigialData = function () {\r\n            self.data = self.originalData.filter(function (row) {\r\n                return true;\r\n            });\r\n        };\r\n        self.validateColumn = function (c, s) {\r\n            if (!c.name) {\r\n                throw new Error('A column must contain at least a name.');\r\n            }\r\n            if (s.filter(function (i) { return i.name === c.name; }).length > 0) {\r\n                throw new Error('A column with the name '\r\n                    + c.name + ' already exists and cannot be added again.');\r\n            }\r\n            return true;\r\n        };\r\n        self.setDefaults = function (obj1, obj2, key, def) {\r\n            obj1[key] = obj2[key] === undefined ? def : obj2[key];\r\n        };\r\n        self.setAttributes = function () {\r\n            self.defaults.attributes.forEach(function eachAttribute(i) {\r\n                self.setDefaults(self.attributes, self.args, i[0], i[1]);\r\n            });\r\n        };\r\n        self.setStyle = function () {\r\n            self.defaults.styles.forEach(function eachStyle(i) {\r\n                self.setDefaults(self.style, self.args.style || {}, i[0], i[1]);\r\n            });\r\n        };\r\n        self.autosize = function (colName) {\r\n            self.getVisibleSchema().forEach(function (col, colIndex) {\r\n                if (col.name === colName || colName === undefined) {\r\n                    self.sizes.columns[colIndex]\r\n                        = Math.max(self.findColumnMaxTextLength(col.name), self.style.minColumnWidth);\r\n                }\r\n            });\r\n            self.sizes.columns[-1] = self.findColumnMaxTextLength('cornerCell');\r\n        };\r\n        self.dispose = function () {\r\n            if (!self.isChildGrid && self.canvas && self.canvas.parentNode) {\r\n                self.canvas.parentNode.removeChild(self.canvas);\r\n            }\r\n            if(!self.isChildGrid) {\r\n                document.body.removeChild(self.controlInput)\r\n            }\r\n            self.eventParent.removeEventListener('mouseup', self.mouseup, false);\r\n            self.eventParent.removeEventListener('mousedown', self.mousedown, false);\r\n            self.eventParent.removeEventListener('dblclick', self.dblclick, false);\r\n            self.eventParent.removeEventListener('click', self.click, false);\r\n            self.eventParent.removeEventListener('mousemove', self.mousemove);\r\n            self.eventParent.removeEventListener('wheel', self.scrollWheel, false);\r\n            self.canvas.removeEventListener('contextmenu', self.contextmenu, false);\r\n            self.canvas.removeEventListener('copy', self.copy);\r\n            self.controlInput.removeEventListener('copy', self.copy);\r\n            self.controlInput.removeEventListener('cut', self.cut);\r\n            self.controlInput.removeEventListener('paste', self.paste);\r\n            self.controlInput.removeEventListener('keypress', self.keypress, false);\r\n            self.controlInput.removeEventListener('keyup', self.keyup, false);\r\n            self.controlInput.removeEventListener('keydown', self.keydown, false);\r\n            window.removeEventListener('resize', self.resize);\r\n            if (self.observer && self.observer.disconnect) {\r\n                self.observer.disconnect();\r\n            }\r\n        };\r\n        self.tryLoadStoredSettings = function () {\r\n            var s;\r\n            self.reloadStoredValues();\r\n            if (self.storedSettings\r\n                    && typeof self.storedSettings.orders === 'object'\r\n                    && self.storedSettings.orders !== null) {\r\n                if (self.storedSettings.orders.rows.length >= (self.data || []).length) {\r\n                    self.orders.rows = self.storedSettings.orders.rows;\r\n                }\r\n                s = self.getSchema();\r\n                if (self.storedSettings.orders.columns.length === s.length) {\r\n                    self.orders.columns = self.storedSettings.orders.columns;\r\n                }\r\n                self.orderBy = self.storedSettings.orderBy === undefined\r\n                    ? s[0].name : self.storedSettings.orderBy;\r\n                self.orderDirection = self.storedSettings.orderDirection === undefined\r\n                    ? 'asc' : self.storedSettings.orderDirection;\r\n                if (self.storedSettings.orderBy !== undefined && self.getHeaderByName(self.orderBy) && self.orderDirection) {\r\n                    self.order(self.orderBy, self.orderDirection);\r\n                }\r\n            }\r\n        };\r\n        self.getDomRoot = function () {\r\n            return self.shadowRoot ? self.shadowRoot.host : self.parentNode;\r\n        };\r\n        self.getFontName = function (fontStyle) {\r\n            return fontStyle.replace(/\\d+\\.?\\d*px/, '');\r\n        };\r\n        self.getFontHeight = function (fontStyle) {\r\n            return parseFloat(fontStyle, 10);\r\n        };\r\n        self.parseStyleValue = function (key) {\r\n            if (/Font/.test(key)) {\r\n                self.style[key + 'Height'] = self.getFontHeight(self.style[key]);\r\n                self.style[key + 'Name'] = self.getFontName(self.style[key]);\r\n                return;\r\n            }\r\n            // when inheriting styles from already instantiated grids, don't parse already parsed values.\r\n            if (key === 'moveOverlayBorderSegments' && typeof self.style[key] === 'string') {\r\n                self.style[key] = self.style[key].split(',')\r\n                    .map(function (i) { return parseInt(i, 10); });\r\n            }\r\n        };\r\n        self.initProp = function (propName) {\r\n            if (!self.args[propName]) { return; }\r\n            Object.keys(self.args[propName]).forEach(function (key) {\r\n                self[propName][key] = self.args[propName][key];\r\n            });\r\n        };\r\n        self.getStyleProperty = function (key) {\r\n            if (self.styleKeys.indexOf(key) === -1) {\r\n                return self.parentNodeStyle[key];\r\n            }\r\n            return self.style[key];\r\n        };\r\n        self.setStyleProperty = function (key, value, supressDrawAndEvent) {\r\n            var isDim = ['height', 'width', 'minHeight', 'minWidth', 'maxHeight', 'maxWidth'].indexOf(key) !== -1;\r\n            if (self.styleKeys.indexOf(key) === -1) {\r\n                self.parentNodeStyle[key] = value;\r\n            } else {\r\n                if (/-/.test(key)) {\r\n                    key = self.dehyphenateProperty(key);\r\n                }\r\n                self.style[key] = value;\r\n                self.parseStyleValue(key);\r\n            }\r\n            if (isDim) {\r\n                self.resize();\r\n            }\r\n            if (!supressDrawAndEvent) {\r\n                self.draw(true);\r\n                self.dispatchEvent('stylechanged', {name: 'style', value: value});\r\n            }\r\n        };\r\n        self.reloadStoredValues = function () {\r\n            if (self.attributes.name && self.attributes.saveAppearance) {\r\n                try {\r\n                    self.storedSettings = localStorage.getItem(self.storageName + '-' + self.attributes.name);\r\n                } catch (e) {\r\n                    console.warn(\"Error loading stored values. \" + e.message);\r\n                    self.storedSettings = undefined;\r\n                }\r\n                if (self.storedSettings) {\r\n                    try {\r\n                        self.storedSettings = JSON.parse(self.storedSettings);\r\n                    } catch (e) {\r\n                        console.warn('could not read settings from localStore', e);\r\n                        self.storedSettings = undefined;\r\n                    }\r\n                }\r\n                if (self.storedSettings) {\r\n                    if (typeof self.storedSettings.sizes === 'object'\r\n                            && self.storedSettings.sizes !== null) {\r\n                        self.sizes.rows = self.storedSettings.sizes.rows;\r\n                        self.sizes.columns = self.storedSettings.sizes.columns;\r\n                        ['trees', 'columns', 'rows'].forEach(function (i) {\r\n                            if (!self.sizes[i]) {\r\n                                self.sizes[i] = {};\r\n                            }\r\n                        });\r\n                    }\r\n                    if (typeof self.storedSettings.visibility === 'object') {\r\n                        self.getSchema().forEach(function (column) {\r\n                            if (self.storedSettings.visibility && self.storedSettings.visibility[column.name] !== undefined) {\r\n                                column.hidden = !self.storedSettings.visibility[column.name];\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        self.init = function () {\r\n            if (self.initialized) { return; }\r\n            function addStyleKeyIfNoneExists(key) {\r\n                if (self.styleKeys.indexOf(key) === -1) {\r\n                    self.styleKeys.push(key);\r\n                }\r\n            }\r\n            var publicStyleKeyIntf = {};\r\n            self.setAttributes();\r\n            self.setStyle();\r\n            self.initScrollBox();\r\n            self.setDom();\r\n            self.nodeType = 'canvas-datagrid';\r\n            self.ie = /Trident/.test(window.navigator.userAgent);\r\n            self.edge = /Edge/.test(window.navigator.userAgent);\r\n            self.webKit = /WebKit/.test(window.navigator.userAgent);\r\n            self.moz = /Gecko/.test(window.navigator.userAgent);\r\n            self.mobile = /Mobile/i.test(window.navigator.userAgent);\r\n            self.cursorGrab = 'grab';\r\n            self.cursorGrabing = 'grabbing';\r\n            self.cursorGrab = self.webKit ? '-webkit-grab' : self.cursorGrab;\r\n            self.cursorGrabing = self.moz ? '-webkit-grabbing' : self.cursorGrabbing;\r\n            self.pointerLockPosition = {x: 0, y: 0};\r\n            Object.keys(self.style).forEach(self.parseStyleValue);\r\n            self.intf.moveSelection = self.moveSelection;\r\n            self.intf.moveTo = self.moveTo;\r\n            self.intf.addEventListener = self.addEventListener;\r\n            self.intf.removeEventListener = self.removeEventListener;\r\n            self.intf.dispatchEvent = self.dispatchEvent;\r\n            /**\r\n             * Releases grid resources and removes grid elements.\r\n             * @memberof canvasDatagrid\r\n             * @name dispose\r\n             * @method\r\n             */\r\n            self.intf.dispose = self.dispose;\r\n            /**\r\n             * Appends the grid to another element later.  Not implemented.\r\n             * @memberof canvasDatagrid\r\n             * @name appendTo\r\n             * @method\r\n             * @param {number} el The element to append the grid to.\r\n             */\r\n            self.intf.appendTo = self.appendTo;\r\n            self.intf.getVisibleCellByIndex = self.getVisibleCellByIndex;\r\n            self.intf.filters = self.filters;\r\n            self.intf.sorters = self.sorters;\r\n            self.intf.autosize = self.autosize;\r\n            self.intf.beginEditAt = self.beginEditAt;\r\n            self.intf.endEdit = self.endEdit;\r\n            self.intf.setActiveCell = self.setActiveCell;\r\n            self.intf.forEachSelectedCell = self.forEachSelectedCell;\r\n            self.intf.scrollIntoView = self.scrollIntoView;\r\n            self.intf.clearChangeLog = self.clearChangeLog;\r\n            self.intf.gotoCell = self.gotoCell;\r\n            self.intf.gotoRow = self.gotoRow;\r\n            self.intf.getHeaderByName = self.getHeaderByName;\r\n            self.intf.findColumnScrollLeft = self.findColumnScrollLeft;\r\n            self.intf.findRowScrollTop = self.findRowScrollTop;\r\n            self.intf.fitColumnToValues = self.fitColumnToValues;\r\n            self.intf.findColumnMaxTextLength = self.findColumnMaxTextLength;\r\n            self.intf.disposeContextMenu = self.disposeContextMenu;\r\n            self.intf.getCellAt = self.getCellAt;\r\n            self.intf.isCellVisible = self.isCellVisible;\r\n            self.intf.isRowVisible = self.isRowVisible;\r\n            self.intf.isColumnVisible = self.isColumnVisible;\r\n            self.intf.order = self.order;\r\n            self.intf.draw = self.draw;\r\n            self.intf.isComponent = self.isComponent;\r\n            self.intf.selectArea = self.selectArea;\r\n            self.intf.clipElement = self.clipElement;\r\n            self.intf.getSchemaFromData = self.getSchemaFromData;\r\n            self.intf.setFilter = self.setFilter;\r\n            self.intf.selectRow = self.selectRow;\r\n            self.intf.parentGrid = self.parentGrid;\r\n            self.intf.toggleTree = self.toggleTree;\r\n            self.intf.expandTree = self.expandTree;\r\n            self.intf.collapseTree = self.collapseTree;\r\n            self.intf.canvas = self.canvas;\r\n            self.intf.context = self.ctx;\r\n            self.intf.insertRow = self.insertRow;\r\n            self.intf.deleteRow = self.deleteRow;\r\n            self.intf.addRow = self.addRow;\r\n            self.intf.insertColumn = self.insertColumn;\r\n            self.intf.deleteColumn = self.deleteColumn;\r\n            self.intf.addColumn = self.addColumn;\r\n            self.intf.getClippingRect = self.getClippingRect;\r\n            self.intf.setRowHeight = self.setRowHeight;\r\n            self.intf.setColumnWidth = self.setColumnWidth;\r\n            self.intf.resetColumnWidths = self.resetColumnWidths;\r\n            self.intf.resetRowHeights = self.resetRowHeights;\r\n            self.intf.resize = self.resize;\r\n            self.intf.selectColumn = self.selectColumn;\r\n            self.intf.selectRow = self.selectRow;\r\n            self.intf.selectAll = self.selectAll;\r\n            self.intf.selectNone = self.selectNone;\r\n            self.intf.drawChildGrids = self.drawChildGrids;\r\n            self.intf.assertPxColor = self.assertPxColor;\r\n            self.intf.clearPxColorAssertions = self.clearPxColorAssertions;\r\n            self.intf.integerToAlpha = self.integerToAlpha;\r\n            self.intf.copy = self.copy;\r\n            self.intf.setStyleProperty = self.setStyleProperty;\r\n            Object.defineProperty(self.intf, 'defaults', {\r\n                get: function () {\r\n                    return {\r\n                        styles: self.defaults.styles.reduce(function (a, i) { a[i[0]] = i[1]; return a; }, {}),\r\n                        attributes: self.defaults.attributes.reduce(function (a, i) { a[i[0]] = i[1]; return a; }, {})\r\n                    };\r\n                }\r\n            });\r\n            self.styleKeys = Object.keys(self.intf.defaults.styles);\r\n            self.styleKeys.map(function (i) { return self.hyphenateProperty(i, false); }).forEach(addStyleKeyIfNoneExists);\r\n            self.styleKeys.map(function (i) { return self.hyphenateProperty(i, true); }).forEach(addStyleKeyIfNoneExists);\r\n            self.DOMStyles = window.getComputedStyle(document.body, null);\r\n            self.styleKeys.concat(Object.keys(self.DOMStyles)).forEach(function (key) {\r\n                // unless this line is here, Object.keys() will not work on <instance>.style\r\n                publicStyleKeyIntf[key] = undefined;\r\n                Object.defineProperty(publicStyleKeyIntf, key, {\r\n                    get: function () {\r\n                        return self.getStyleProperty(key);\r\n                    },\r\n                    set: function (value) {\r\n                        if (self.initialized) {\r\n                            self.appliedInlineStyles[key] = value;\r\n                        }\r\n                        self.setStyleProperty(key, value);\r\n                    }\r\n                });\r\n            });\r\n            Object.defineProperty(self.intf, 'shadowRoot', {\r\n                get: function () {\r\n                    return self.shadowRoot;\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'activeCell', {\r\n                get: function () {\r\n                    return self.activeCell;\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'hasFocus', {\r\n                get: function () {\r\n                    return self.hasFocus;\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'style', {\r\n                get: function () {\r\n                    return publicStyleKeyIntf;\r\n                },\r\n                set: function (valueObject) {\r\n                    Object.keys(valueObject).forEach(function (key) {\r\n                        self.setStyleProperty(key, valueObject[key], true);\r\n                    });\r\n                    self.draw(true);\r\n                    self.dispatchEvent('stylechanged', {name: 'style', value: valueObject});\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'attributes', { value: {}});\r\n            Object.keys(self.attributes).forEach(function (key) {\r\n                Object.defineProperty(self.intf.attributes, key, {\r\n                    get: function () {\r\n                        return self.attributes[key];\r\n                    },\r\n                    set: function (value) {\r\n                        self.attributes[key] = value;\r\n                        if (key === 'name') {\r\n                            self.tryLoadStoredSettings();\r\n                        }\r\n                        self.draw(true);\r\n                        self.dispatchEvent('attributechanged', {name: key, value: value[key]});\r\n                    }\r\n                });\r\n            });\r\n            self.filters.string = function (value, filterFor) {\r\n                value = String(value);\r\n                var filterRegExp,\r\n                    regEnd = /\\/(i|g|m)*$/,\r\n                    pattern = regEnd.exec(filterFor),\r\n                    flags = pattern ? pattern[0].substring(1) : '',\r\n                    flagLength = flags.length;\r\n                self.invalidFilterRegEx = undefined;\r\n                if (filterFor.substring(0, 1) === '/' && pattern) {\r\n                    try {\r\n                        filterRegExp = new RegExp(filterFor.substring(1, filterFor.length - (flagLength + 1)), flags);\r\n                    } catch (e) {\r\n                        self.invalidFilterRegEx = e;\r\n                        return;\r\n                    }\r\n                    return filterRegExp.test(value);\r\n                }\r\n                return value.toString ? value.toString().toLocaleUpperCase()\r\n                    .indexOf(filterFor.toLocaleUpperCase()) !== -1 : false;\r\n            };\r\n            self.filters.number = function (value, filterFor) {\r\n                if (!filterFor) { return true; }\r\n                return value === filterFor;\r\n            };\r\n            ['formatters', 'filters', 'sorters'].forEach(self.initProp);\r\n            self.applyComponentStyle(false, self.intf);\r\n            self.reloadStoredValues();\r\n            if (self.args.data) {\r\n                self.intf.data = self.args.data;\r\n            }\r\n            if (self.intf.innerText || self.intf.textContent) {\r\n                if (self.intf.dataType === 'application/x-canvas-datagrid') {\r\n                    self.intf.dataType = 'application/json+x-canvas-datagrid';\r\n                }\r\n                self.intf.data = self.intf.innerText || self.intf.textContent;\r\n            }\r\n            if (self.args.schema) {\r\n                self.intf.schema = self.args.schema;\r\n            }\r\n            if (self.isChildGrid || !self.isComponent) {\r\n                requestAnimationFrame(function () { self.resize(true); });\r\n            } else {\r\n                self.resize(true);\r\n            }\r\n            self.initialized = true;\r\n            return self;\r\n        };\r\n        /**\r\n         * Removes focus from the grid.\r\n         * @memberof canvasDatagrid\r\n         * @name blur\r\n         * @method\r\n         */\r\n        self.intf.blur = function (e) {\r\n            self.hasFocus = false;\r\n        };\r\n        /**\r\n         * Focuses on the grid.\r\n         * @memberof canvasDatagrid\r\n         * @name focus\r\n         * @method\r\n         */\r\n        self.intf.focus = function () {\r\n            self.hasFocus = true;\r\n            self.controlInput.focus();\r\n        };\r\n        if (self.shadowRoot || self.isChildGrid) {\r\n            Object.defineProperty(self.intf, 'height', {\r\n                get: function () {\r\n                    if (self.shadowRoot) {\r\n                        return self.shadowRoot.height;\r\n                    }\r\n                    return self.parentNode.height;\r\n                },\r\n                set: function (value) {\r\n                    if (self.shadowRoot) {\r\n                        self.shadowRoot.height = value;\r\n                    } else {\r\n                        self.parentNode.height = value;\r\n                    }\r\n                    self.resize(true);\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'width', {\r\n                get: function () {\r\n                    if (self.shadowRoot) {\r\n                        return self.shadowRoot.width;\r\n                    }\r\n                    return self.parentNode.width;\r\n                },\r\n                set: function (value) {\r\n                    if (self.shadowRoot) {\r\n                        self.shadowRoot.width = value;\r\n                    } else {\r\n                        self.parentNode.width = value;\r\n                    }\r\n                    self.resize(true);\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'parentNode', {\r\n                get: function () {\r\n                    return self.parentNode;\r\n                },\r\n                set: function (value) {\r\n                    if (!self.isChildGrid) {\r\n                        throw new TypeError('Cannot set property parentNode which has only a getter');\r\n                    }\r\n                    self.parentNode = value;\r\n                }\r\n            });\r\n        }\r\n        Object.defineProperty(self.intf, 'visibleRowHeights', {\r\n            get: function () {\r\n                return self.visibleRowHeights;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'openChildren', {\r\n            get: function () {\r\n                return self.openChildren;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'childGrids', {\r\n            get: function () {\r\n                return Object.keys(self.childGrids).map(function (gridId) {\r\n                    return self.childGrids[gridId];\r\n                });\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'isChildGrid', {\r\n            get: function () {\r\n                return self.isChildGrid;\r\n            }\r\n        });\r\n        Object.defineProperty(self, 'cursor', {\r\n            get: function () {\r\n                return self.parentNodeStyle.cursor;\r\n            },\r\n            set: function (value) {\r\n                if (value === 'cell') { value = 'default'; }\r\n                if (self.currentCursor !== value) {\r\n                    self.parentNodeStyle.cursor = value;\r\n                    self.currentCursor = value;\r\n                }\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'orderDirection', {\r\n            get: function () {\r\n                return self.orderDirection;\r\n            },\r\n            set: function (value) {\r\n                if (value !== 'desc') {\r\n                    value = 'asc';\r\n                }\r\n                self.orderDirection = value;\r\n                self.order(self.orderBy, self.orderDirection);\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'orderBy', {\r\n            get: function () {\r\n                return self.orderBy;\r\n            },\r\n            set: function (value) {\r\n                if (self.getSchema().find(function (col) {\r\n                        return col.name === value;\r\n                    }) === undefined) {\r\n                    throw new Error('Cannot sort by unknown column name.');\r\n                }\r\n                self.orderBy = value;\r\n                self.order(self.orderBy, self.orderDirection);\r\n            }\r\n        });\r\n        if (self.isComponent) {\r\n            Object.defineProperty(self.intf, 'offsetHeight', {\r\n                get: function () {\r\n                    return self.canvas.offsetHeight;\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'offsetWidth', {\r\n                get: function () {\r\n                    return self.canvas.offsetWidth;\r\n                }\r\n            });\r\n        }\r\n        Object.defineProperty(self.intf, 'scrollHeight', {\r\n            get: function () {\r\n                return self.scrollBox.scrollHeight;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'scrollWidth', {\r\n            get: function () {\r\n                return self.scrollBox.scrollWidth;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'scrollTop', {\r\n            get: function () {\r\n                return self.scrollBox.scrollTop;\r\n            },\r\n            set: function (value) {\r\n                self.scrollBox.scrollTop = value;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'scrollLeft', {\r\n            get: function () {\r\n                return self.scrollBox.scrollLeft;\r\n            },\r\n            set: function (value) {\r\n                self.scrollBox.scrollLeft = value;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'sizes', {\r\n            get: function () {\r\n                return self.sizes;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'parentDOMNode', {\r\n            get: function () {\r\n                return self.parentDOMNode;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'input', {\r\n            get: function () {\r\n                return self.input;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'controlInput', {\r\n            get: function () {\r\n                return self.controlInput;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'currentCell', {\r\n            get: function () {\r\n                return self.currentCell;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'visibleCells', {\r\n            get: function () {\r\n                return self.visibleCells;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'visibleRows', {\r\n            get: function () {\r\n                return self.visibleRows;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'selections', {\r\n            get: function () {\r\n                return self.selections;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'dragMode', {\r\n            get: function () {\r\n                return self.dragMode;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'changes', {\r\n            get: function () {\r\n                return self.changes;\r\n            }\r\n        });\r\n        self.intf.formatters = self.formatters;\r\n        Object.defineProperty(self.intf, 'dataType', {\r\n            get: function () {\r\n                return self.dataType;\r\n            },\r\n            set: function (value) {\r\n                if (!self.parsers[value]) {\r\n                    throw new Error('No parser for MIME type ' + value);\r\n                }\r\n                self.dataType = value;\r\n            }\r\n        });\r\n        self.eventNames.forEach(function (eventName) {\r\n            Object.defineProperty(self.intf, 'on' + eventName, {\r\n                get: function () {\r\n                    return self.componentL1Events[eventName];\r\n                },\r\n                set: function (value) {\r\n                    self.events[eventName] = [];\r\n                    self.componentL1Events[eventName] = value;\r\n                    if (!value) { return; }\r\n                    self.addEventListener(eventName, value);\r\n                }\r\n            });\r\n        });\r\n        Object.defineProperty(self.intf, 'frozenRow', {\r\n            get: function () {\r\n                return self.frozenRow;\r\n            },\r\n            set: function (val) {\r\n                if (isNaN(val)) {\r\n                    throw new TypeError('Expected value for frozenRow to be a number.');\r\n                }\r\n                if (self.visibleRows.length < val) {\r\n                    throw new RangeError('Cannot set a value larger than the number of visible rows.');\r\n                }\r\n                self.frozenRow = val;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'frozenColumn', {\r\n            get: function () {\r\n                return self.frozenColumn;\r\n            },\r\n            set: function (val) {\r\n                if (isNaN(val)) {\r\n                    throw new TypeError('Expected value for frozenRow to be a number.');\r\n                }\r\n                if (self.getVisibleSchema().length < val) {\r\n                    throw new RangeError('Cannot set a value larger than the number of visible columns.');\r\n                }\r\n                self.frozenColumn = val;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'scrollIndexRect', {\r\n            get: function () {\r\n                return {\r\n                    top: self.scrollIndexTop,\r\n                    right: self.scrollIndexRight,\r\n                    bottom: self.scrollIndexBottom,\r\n                    left: self.scrollIndexLeft\r\n                };\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'scrollPixelRect', {\r\n            get: function () {\r\n                return {\r\n                    top: self.scrollPixelTop,\r\n                    right: self.scrollPixelRight,\r\n                    bottom: self.scrollPixelBottom,\r\n                    left: self.scrollPixelLeft\r\n                };\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'rowOrder', {\r\n            get: function () {\r\n                return self.orders.rows;\r\n            },\r\n            set: function (val) {\r\n                if (!Array.isArray(val)) {\r\n                    throw new TypeError('Value must be an array.');\r\n                }\r\n                if (!self.data || val.length < self.data.length) {\r\n                    throw new RangeError('Array length must be equal to or greater than number of rows.');\r\n                }\r\n                self.orders.rows = val;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'columnOrder', {\r\n            get: function () {\r\n                return self.orders.columns;\r\n            },\r\n            set: function (val) {\r\n                if (!Array.isArray(val)) {\r\n                    throw new TypeError('Value must be an array.');\r\n                }\r\n                if (val.length < self.getSchema().length) {\r\n                    throw new RangeError('Array length must be equal to or greater than number of columns.');\r\n                }\r\n                self.orders.columns = val;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'selectionBounds', {\r\n            get: function () {\r\n                return self.getSelectionBounds();\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'selectedRows', {\r\n            get: function () {\r\n                return self.getSelectedData(true);\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'selectedCells', {\r\n            get: function () {\r\n                return self.getSelectedData();\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'visibleSchema', {\r\n            get: function () {\r\n                return self.getVisibleSchema().map(function eachDataRow(col) {\r\n                    return col;\r\n                });\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'treeGridAttributes', {\r\n            get: function () {\r\n                return self.treeGridAttributes;\r\n            },\r\n            set: function setTreeGridAttributes(value) {\r\n                self.treeGridAttributes = value;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'cellGridAttributes', {\r\n            get: function () {\r\n                return self.cellGridAttributes;\r\n            },\r\n            set: function setCellGridAttributes(value) {\r\n                self.cellGridAttributes = value;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'ctx', {\r\n            get: function () {\r\n                return self.ctx;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'schema', {\r\n            get: function schemaGetter() {\r\n                return self.getSchema();\r\n            },\r\n            set: function schemaSetter(value) {\r\n                if (value === undefined) {\r\n                    // Issue #89 - allow schema to be set to initialized state\r\n                    self.schema = undefined;\r\n                    self.tempSchema = undefined;\r\n                    self.dispatchEvent('schemachanged', {schema: undefined});\r\n                    return;\r\n                }\r\n                if (!Array.isArray(value) || typeof value[0] !== 'object') {\r\n                    throw new Error('Schema must be an array of objects.');\r\n                }\r\n                if (value[0].name === undefined) {\r\n                    throw new Error('Expected schema to contain an object with at least a name property.');\r\n                }\r\n                self.schema = value.map(function eachSchemaColumn(column, index) {\r\n                    column.width = column.width || self.style.cellWidth;\r\n                    column.filter = column.filter || self.filter(column.type);\r\n                    column.type = column.type || 'string';\r\n                    column.index = index;\r\n                    column.columnIndex = index;\r\n                    column.rowIndex = -1;\r\n                    return column;\r\n                });\r\n                self.tempSchema = undefined;\r\n                self.createNewRowData();\r\n                self.createColumnOrders();\r\n                self.tryLoadStoredSettings();\r\n                if (self.storedSettings && typeof self.storedSettings.visibility === 'object') {\r\n                    self.schema.forEach(function hideEachSchemaColumn(column, index) {\r\n                        if (self.storedSettings && self.storedSettings.visibility[column.name] !== undefined) {\r\n                            column.hidden = !self.storedSettings.visibility[column.name];\r\n                        }\r\n                    });\r\n                }\r\n                self.resize(true);\r\n                self.dispatchEvent('schemachanged', {schema: self.schema});\r\n            }\r\n        });\r\n        /**\r\n         * Gets an array of currently registered MIME types.\r\n         * @memberof canvasDatagrid\r\n         * @name getDataTypes\r\n         * @method\r\n         */\r\n        self.intf.getTypes = function () {\r\n            return Object.keys(self.parsers);\r\n        };\r\n        self.parseInnerHtml = function (data) {\r\n            if (!data || /^ +$/.test(data)) {\r\n                return [];\r\n            }\r\n            try {\r\n                data = JSON.parse(data);\r\n            } catch (e) {\r\n                console.warn(Error('Cannot parse application/json+x-canvas-datagrid formated data. '\r\n                    + e.message + '  \\nNote: canvas-datagrid.innerHTML is for string data only.  '\r\n                    + 'Use the canvas-datagrid.data property to set object data.'));\r\n            }\r\n            return data;\r\n        };\r\n        self.parsers['application/json+x-canvas-datagrid'] = function (data, callback) {\r\n            self.parsers['application/x-canvas-datagrid'](self.parseInnerHtml(data), function (data, schema) {\r\n                return callback(data, schema);\r\n            });\r\n        };\r\n        self.parsers['application/x-canvas-datagrid'] = function (data, callback) {\r\n            return callback(data);\r\n        };\r\n        self.intf.parsers = self.parsers;\r\n        // send to dataType ETL function to extract from input data\r\n        // and transform into native [{}, {}] format\r\n        self.etl = function (data, callback) {\r\n            if (!self.intf.parsers[self.dataType]) {\r\n                throw new Error('Unsupported data type.');\r\n            }\r\n            self.intf.parsers[self.dataType](data, function (data, schema) {\r\n                if (Array.isArray(schema)) {\r\n                    self.schema = schema;\r\n                }\r\n                // Issue #89 - allow schema to be auto-created every time data is set\r\n                if (self.attributes.autoGenerateSchema) {\r\n                    self.schema = self.getSchemaFromData(data);\r\n                }\r\n                if (!self.schema) {\r\n                    self.tempSchema = self.getSchemaFromData(data);\r\n                }\r\n                if (self.getSchema()) {\r\n                    self.createColumnOrders();\r\n                }\r\n                // set the unfiltered/sorted data array\r\n                self.originalData = data;\r\n                // apply filter, sort, etc to incoming dataset\r\n                self.applyDataTransforms();\r\n                // empty data was set\r\n                if (!self.schema && (self.data || []).length === 0) {\r\n                    self.tempSchema = [{name: ''}];\r\n                }\r\n                self.fitColumnToValues('cornerCell', true);\r\n                if ((self.tempSchema && !self.schema) || self.attributes.autoGenerateSchema) {\r\n                    self.createColumnOrders();\r\n                    self.dispatchEvent('schemachanged', {schema: self.tempSchema});\r\n                }\r\n                callback();\r\n            });\r\n        };\r\n        Object.defineProperty(self.intf, 'data', {\r\n            get: function dataGetter() {\r\n                return self.data;\r\n            },\r\n            set: function dataSetter(value) {\r\n                self.etl(value, function () {\r\n                    self.changes = [];\r\n                    self.createNewRowData();\r\n                    if (self.attributes.autoResizeColumns && self.data.length > 0\r\n                            && self.storedSettings === undefined) {\r\n                        self.autosize();\r\n                    }\r\n                    // set the header column to fit the numbers in it\r\n                    self.fitColumnToValues('cornerCell', true);\r\n                    self.createRowOrders();\r\n                    self.tryLoadStoredSettings();\r\n                    self.dispatchEvent('datachanged', {data: self.data});\r\n                    self.resize(true);\r\n                });\r\n            }\r\n        });\r\n        self.initScrollBox = function () {\r\n            var sHeight = 0,\r\n                sWidth = 0,\r\n                scrollTop = 0,\r\n                scrollLeft = 0,\r\n                scrollHeight = 0,\r\n                scrollWidth = 0,\r\n                scrollBoxHeight = 20,\r\n                scrollBoxWidth = 20;\r\n            function setScrollTop(value, preventScrollEvent) {\r\n                if (isNaN(value)) {\r\n                    throw new Error('ScrollTop value must be a number');\r\n                }\r\n                if (value < 0) {\r\n                    value = 0;\r\n                }\r\n                if (value > scrollHeight) {\r\n                    value = scrollHeight;\r\n                }\r\n                if (scrollHeight < 0) {\r\n                    value = 0;\r\n                }\r\n                scrollTop = value;\r\n                if (!preventScrollEvent) {\r\n                    self.scroll();\r\n                }\r\n            }\r\n            function setScrollLeft(value, preventScrollEvent) {\r\n                if (isNaN(value)) {\r\n                    throw new Error('ScrollLeft value must be a number');\r\n                }\r\n                if (value < 0) {\r\n                    value = 0;\r\n                }\r\n                if (value > scrollWidth) {\r\n                    value = scrollWidth;\r\n                }\r\n                if (scrollWidth < 0) {\r\n                    value = 0;\r\n                }\r\n                scrollLeft = value;\r\n                if (!preventScrollEvent) {\r\n                    self.scroll();\r\n                }\r\n            }\r\n            self.scrollBox.toString = function () {\r\n                return '{\"width\": ' + scrollWidth.toFixed(2)\r\n                    + ', \"height\": ' + scrollHeight.toFixed(2)\r\n                    + ', \"left\": ' + scrollLeft.toFixed(2)\r\n                    + ', \"top\": ' + scrollTop.toFixed(2)\r\n                    + ', \"widthRatio\": ' + self.scrollBox.widthBoxRatio.toFixed(5)\r\n                    + ', \"heightRatio\": ' + self.scrollBox.heightBoxRatio.toFixed(5) + '}';\r\n            };\r\n            self.scrollBox.scrollTo = function (x, y, supressDrawEvent) {\r\n                setScrollLeft(x, true);\r\n                setScrollTop(y, supressDrawEvent);\r\n            };\r\n            Object.defineProperty(self.scrollBox, 'scrollBoxHeight', {\r\n                get: function () {\r\n                    return scrollBoxHeight;\r\n                },\r\n                set: function (value) {\r\n                    scrollBoxHeight = value;\r\n                }\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'scrollBoxWidth', {\r\n                get: function () {\r\n                    return scrollBoxWidth;\r\n                },\r\n                set: function (value) {\r\n                    scrollBoxWidth = value;\r\n                }\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'height', {\r\n                get: function () {\r\n                    return sHeight;\r\n                },\r\n                set: function (value) {\r\n                    sHeight = value;\r\n                }\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'width', {\r\n                get: function () {\r\n                    return sWidth;\r\n                },\r\n                set: function (value) {\r\n                    sWidth = value;\r\n                }\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'scrollTop', {\r\n                get: function () {\r\n                    return scrollTop;\r\n                },\r\n                set: setScrollTop\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'scrollLeft', {\r\n                get: function () {\r\n                    return scrollLeft;\r\n                },\r\n                set: setScrollLeft\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'scrollHeight', {\r\n                get: function () {\r\n                    return scrollHeight;\r\n                },\r\n                set: function (value) {\r\n                    if (scrollTop > value) {\r\n                        scrollTop = Math.max(value, 0);\r\n                    }\r\n                    scrollHeight = value;\r\n                }\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'scrollWidth', {\r\n                get: function () {\r\n                    return scrollWidth;\r\n                },\r\n                set: function (value) {\r\n                    if (scrollLeft > value) {\r\n                        scrollLeft = Math.max(value, 0);\r\n                    }\r\n                    scrollWidth = value;\r\n                }\r\n            });\r\n        };\r\n        return;\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/intf.js\n// module id = 6\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false, Event: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        var zIndexTop, hoverScrollTimeout, autoCompleteContext;\r\n        function applyContextItemStyle(contextItemContainer) {\r\n            self.createInlineStyle(contextItemContainer, 'canvas-datagrid-context-menu-item' + (self.mobile ? '-mobile' : ''));\r\n            contextItemContainer.addEventListener('mouseover', function () {\r\n                self.createInlineStyle(contextItemContainer, 'canvas-datagrid-context-menu-item:hover');\r\n            });\r\n            contextItemContainer.addEventListener('mouseout', function () {\r\n                self.createInlineStyle(contextItemContainer, 'canvas-datagrid-context-menu-item');\r\n            });\r\n        }\r\n        function createContextMenu(ev, pos, items, parentContextMenu) {\r\n            var container = document.createElement('div'),\r\n                upArrow = document.createElement('div'),\r\n                downArrow = document.createElement('div'),\r\n                children = [],\r\n                selectedIndex = -1,\r\n                intf = {},\r\n                rect;\r\n            if (!Array.isArray(items)) { throw new Error('createContextMenu expects an array.'); }\r\n            function createItems() {\r\n                items.forEach(function (item) {\r\n                    var contextItemContainer = document.createElement('div'),\r\n                        childMenuArrow;\r\n                    function removeChildContext(e) {\r\n                        if (e.relatedTarget === container\r\n                                || item.contextMenu.container === e.relatedTarget\r\n                                || childMenuArrow === e.relatedTarget\r\n                                || (contextItemContainer === e.relatedTarget)\r\n                                || item.contextMenu.container.contains(e.relatedTarget)\r\n                                ) { return; }\r\n                        item.contextMenu.dispose();\r\n                        children.splice(children.indexOf(item.contextMenu), 1);\r\n                        item.contextMenu = undefined;\r\n                        contextItemContainer.removeEventListener('mouseout', removeChildContext);\r\n                        container.removeEventListener('mouseout', removeChildContext);\r\n                        contextItemContainer.setAttribute('contextOpen', '0');\r\n                        contextItemContainer.setAttribute('opening', '0');\r\n                    }\r\n                    function contextAddCallback(items) {\r\n                        // check yet again if the user hasn't moved off\r\n                        if (contextItemContainer.getAttribute('opening') !== '1' ||\r\n                                contextItemContainer.getAttribute('contextOpen') === '1') {\r\n                            return;\r\n                        }\r\n                        var cPos = contextItemContainer.getBoundingClientRect();\r\n                        cPos = {\r\n                            left: cPos.left + self.style.childContextMenuMarginLeft + container.offsetWidth,\r\n                            top: cPos.top + self.style.childContextMenuMarginTop,\r\n                            bottom: cPos.bottom,\r\n                            right: cPos.right\r\n                        };\r\n                        item.contextMenu = createContextMenu(ev, cPos, items, intf);\r\n                        contextItemContainer.setAttribute('contextOpen', '1');\r\n                        contextItemContainer.addEventListener('mouseout', removeChildContext);\r\n                        container.addEventListener('mouseout', removeChildContext);\r\n                        children.push(item.contextMenu);\r\n                    }\r\n                    function createChildContext() {\r\n                        var i;\r\n                        if (contextItemContainer.getAttribute('contextOpen') === '1') {\r\n                            return;\r\n                        }\r\n                        contextItemContainer.setAttribute('opening', '1');\r\n                        if (typeof item.items === 'function') {\r\n                            i  = item.items.apply(intf, [function (items) {\r\n                                contextAddCallback(items);\r\n                            }]);\r\n                            if (i !== undefined && Array.isArray(i)) {\r\n                                contextAddCallback(i);\r\n                            }\r\n                            return;\r\n                        }\r\n                        contextAddCallback(item.items);\r\n                    }\r\n                    function addItem(item) {\r\n                        function addContent(content) {\r\n                            if (content === null) { return; }\r\n                            if (typeof content === 'function') {\r\n                                return addContent(content(ev));\r\n                            }\r\n                            if (typeof content === 'object') {\r\n                                contextItemContainer.appendChild(content);\r\n                                return;\r\n                            }\r\n                            applyContextItemStyle(contextItemContainer);\r\n                            contextItemContainer.innerHTML = content;\r\n                            return;\r\n                        }\r\n                        addContent(item.title);\r\n                        item.contextItemContainer = contextItemContainer;\r\n                        if ((item.items && item.items.length > 0) || typeof item.items === 'function') {\r\n                            childMenuArrow = document.createElement('div');\r\n                            self.createInlineStyle(childMenuArrow, 'canvas-datagrid-context-child-arrow');\r\n                            childMenuArrow.innerHTML = self.style.childContextMenuArrowHTML;\r\n                            contextItemContainer.appendChild(childMenuArrow);\r\n                            contextItemContainer.addEventListener('mouseover', createChildContext);\r\n                            contextItemContainer.addEventListener('mouseout', function () {\r\n                                contextItemContainer.setAttribute('opening', '0');\r\n                            });\r\n                        }\r\n                        if (item.click) {\r\n                            contextItemContainer.addEventListener('click', function (ev) {\r\n                                item.click.apply(self, [ev]);\r\n                            });\r\n                        }\r\n                    }\r\n                    addItem(item);\r\n                    container.appendChild(contextItemContainer);\r\n                });\r\n            }\r\n            function clickIndex(idx) {\r\n                items[idx].contextItemContainer.dispatchEvent(new Event('click'));\r\n            }\r\n            function checkArrowVisibility() {\r\n                if (container.scrollTop > 0) {\r\n                    self.parentDOMNode.appendChild(upArrow);\r\n                } else if (upArrow.parentNode) {\r\n                    upArrow.parentNode.removeChild(upArrow);\r\n                }\r\n                if (container.scrollTop >= container.scrollHeight - container.offsetHeight && downArrow.parentNode) {\r\n                    downArrow.parentNode.removeChild(downArrow);\r\n                } else if (container.scrollHeight - container.offsetHeight > 0\r\n                        && !(container.scrollTop >= container.scrollHeight - container.offsetHeight)) {\r\n                    self.parentDOMNode.appendChild(downArrow);\r\n                }\r\n            }\r\n            function startHoverScroll(type) {\r\n                return function t() {\r\n                    var a = self.attributes.contextHoverScrollAmount;\r\n                    if (type === 'up' && container.scrollTop === 0) { return; }\r\n                    if (type === 'down' && container.scrollTop === container.scrollHeight) { return; }\r\n                    container.scrollTop += (type === 'up' ? -a : a);\r\n                    hoverScrollTimeout = setTimeout(t, self.attributes.contextHoverScrollRateMs, type);\r\n                };\r\n            }\r\n            function endHoverScroll(type) {\r\n                return function () {\r\n                    clearTimeout(hoverScrollTimeout);\r\n                };\r\n            }\r\n            function init() {\r\n                var loc = {},\r\n                    s = self.scrollOffset(self.canvas);\r\n                if (zIndexTop === undefined) {\r\n                    zIndexTop = self.style.contextMenuZIndex;\r\n                }\r\n                createItems();\r\n                self.createInlineStyle(container, 'canvas-datagrid-context-menu' + (self.mobile ? '-mobile' : ''));\r\n                loc.x = pos.left - s.left;\r\n                loc.y = pos.top - s.top;\r\n                loc.height = 0;\r\n                zIndexTop += 1;\r\n                container.style.position = 'absolute';\r\n                upArrow.style.color = self.style.contextMenuArrowColor;\r\n                downArrow.style.color = self.style.contextMenuArrowColor;\r\n                [upArrow, downArrow].forEach(function (el) {\r\n                    el.style.textAlign = 'center';\r\n                    el.style.position = 'absolute';\r\n                    el.style.zIndex = zIndexTop + 1;\r\n                });\r\n                container.style.zIndex = zIndexTop;\r\n                if (parentContextMenu && parentContextMenu.inputDropdown) {\r\n                    container.style.maxHeight = window.innerHeight - loc.y - self.style.autocompleteBottomMargin + 'px';\r\n                    container.style.minWidth = pos.width + 'px';\r\n                    loc.y += pos.height;\r\n                }\r\n                if (self.mobile) {\r\n                    container.style.width = pos.width + 'px';\r\n                }\r\n                container.style.left = loc.x + 'px';\r\n                container.style.top = loc.y + 'px';\r\n                container.addEventListener('scroll', checkArrowVisibility);\r\n                container.addEventListener('wheel', function (e) {\r\n                    if (self.hasFocus) {\r\n                        container.scrollTop += e.deltaY;\r\n                        container.scrollLeft += e.deltaX;\r\n                    }\r\n                    checkArrowVisibility();\r\n                });\r\n                upArrow.innerHTML = self.style.contextMenuArrowUpHTML;\r\n                downArrow.innerHTML = self.style.contextMenuArrowDownHTML;\r\n                container.appendChild(upArrow);\r\n                document.body.appendChild(downArrow);\r\n                document.body.appendChild(container);\r\n                rect = container.getBoundingClientRect();\r\n                // TODO: fix !(parentContextMenu && parentContextMenu.inputDropdown) state (autocomplete)\r\n                if (rect.bottom > window.innerHeight) {\r\n                    if (!(parentContextMenu && parentContextMenu.inputDropdown)) {\r\n                        loc.y -= (rect.bottom + self.style.contextMenuWindowMargin) - window.innerHeight;\r\n                    }\r\n                    if (loc.y < 0) { loc.y = self.style.contextMenuWindowMargin; }\r\n                    if (container.offsetHeight > window.innerHeight - self.style.contextMenuWindowMargin) {\r\n                        container.style.height = window.innerHeight - (self.style.contextMenuWindowMargin * 2) + 'px';\r\n                    }\r\n                }\r\n                if (rect.right > window.innerWidth) {\r\n                    loc.x -= rect.right - window.innerWidth + self.style.contextMenuWindowMargin;\r\n                }\r\n                if (loc.x < 0) { loc.x = self.style.contextMenuWindowMargin; }\r\n                if (loc.y < 0) { loc.y = self.style.contextMenuWindowMargin; }\r\n                container.style.left = loc.x + 'px';\r\n                container.style.top = loc.y + 'px';\r\n                rect = container.getBoundingClientRect();\r\n                upArrow.style.top = rect.top + 'px';\r\n                downArrow.style.top = rect.top + rect.height - downArrow.offsetHeight + 'px';\r\n                upArrow.style.left = rect.left + 'px';\r\n                downArrow.style.left = rect.left + 'px';\r\n                downArrow.style.width = container.offsetWidth + 'px';\r\n                upArrow.style.width = container.offsetWidth + 'px';\r\n                downArrow.addEventListener('mouseover', startHoverScroll('down'));\r\n                downArrow.addEventListener('mouseout', endHoverScroll('down'));\r\n                upArrow.addEventListener('mouseover', startHoverScroll('up'));\r\n                upArrow.addEventListener('mouseout', endHoverScroll('up'));\r\n                checkArrowVisibility();\r\n            }\r\n            intf.parentGrid = self.intf;\r\n            intf.parentContextMenu = parentContextMenu;\r\n            intf.container = container;\r\n            init();\r\n            intf.clickIndex = clickIndex;\r\n            intf.rect = rect;\r\n            intf.items = items;\r\n            intf.upArrow = upArrow;\r\n            intf.downArrow = downArrow;\r\n            intf.dispose = function () {\r\n                clearTimeout(hoverScrollTimeout);\r\n                children.forEach(function (c) {\r\n                    c.dispose();\r\n                });\r\n                [downArrow, upArrow, container].forEach(function (el) {\r\n                    if (el.parentNode) { el.parentNode.removeChild(el); }\r\n                });\r\n            };\r\n            Object.defineProperty(intf, 'selectedIndex', {\r\n                get: function () {\r\n                    return selectedIndex;\r\n                },\r\n                set: function (value) {\r\n                    if (typeof value !== 'number' || isNaN(value || !isFinite(value))) {\r\n                        throw new Error('Context menu selected index must be a sane number.');\r\n                    }\r\n                    selectedIndex = value;\r\n                    if (selectedIndex > items.length - 1) {\r\n                        selectedIndex = items.length - 1;\r\n                    }\r\n                    if (selectedIndex < 0) {\r\n                        selectedIndex = 0;\r\n                    }\r\n                    items.forEach(function (item, index) {\r\n                        if (index === selectedIndex) {\r\n                            return self.createInlineStyle(item.contextItemContainer, 'canvas-datagrid-context-menu-item:hover');\r\n                        }\r\n                        self.createInlineStyle(item.contextItemContainer, 'canvas-datagrid-context-menu-item');\r\n                    });\r\n                }\r\n            });\r\n            return intf;\r\n        }\r\n        function createFilterContextMenuItems(e) {\r\n            var filterContainer = document.createElement('div'),\r\n                filterLabel = document.createElement('div'),\r\n                filterAutoCompleteButton = document.createElement('button'),\r\n                filterInput = document.createElement('input'),\r\n                n = e.cell && e.cell.header ? e.cell.header.title || e.cell.header.name : '',\r\n                autoCompleteItems,\r\n                iRect;\r\n            function checkRegExpErrorState() {\r\n                filterInput.style.background = self.style.contextFilterInputBackground;\r\n                filterInput.style.color = self.style.contextFilterInputColor;\r\n                if (self.invalidFilterRegEx) {\r\n                    filterInput.style.background = self.style.contextFilterInvalidRegExpBackground;\r\n                    filterInput.style.color = self.style.contextFilterInvalidRegExpColor;\r\n                }\r\n            }\r\n            function fillAutoComplete() {\r\n                var count = 0;\r\n                autoCompleteItems = {};\r\n                self.data.forEach(function (row) {\r\n                    var value = row[e.cell.header.name];\r\n                    if (autoCompleteItems[value] || count > self.attributes.maxAutoCompleteItems) { return; }\r\n                    count += 1;\r\n                    autoCompleteItems[value] = {\r\n                        title: self.formatters[e.cell.header.type || 'string']({ cell: { value: value }}),\r\n                        click: function (e) {\r\n                            filterInput.value = value;\r\n                            e.stopPropagation();\r\n                            filterInput.dispatchEvent(new Event('keyup'));\r\n                            self.disposeAutocomplete();\r\n                            return;\r\n                        }\r\n                    };\r\n                });\r\n                autoCompleteItems = Object.keys(autoCompleteItems).map(function (key) {\r\n                    return autoCompleteItems[key];\r\n                });\r\n            }\r\n            function createAutoCompleteContext(ev) {\r\n                if (ev && [40, 38, 13, 9].indexOf(ev.keyCode) !== -1) { return; }\r\n                fillAutoComplete();\r\n                iRect = filterInput.getBoundingClientRect();\r\n                if (autoCompleteContext) {\r\n                    autoCompleteContext.dispose();\r\n                    autoCompleteContext = undefined;\r\n                }\r\n                autoCompleteContext = createContextMenu(e, {\r\n                    left: iRect.left,\r\n                    top: iRect.top,\r\n                    right: iRect.right,\r\n                    bottom: iRect.bottom,\r\n                    height: iRect.height,\r\n                    width: iRect.width\r\n                }, autoCompleteItems, {inputDropdown: true});\r\n                autoCompleteContext.selectedIndex = 0;\r\n            }\r\n            self.createInlineStyle(filterLabel, 'canvas-datagrid-context-menu-label');\r\n            self.createInlineStyle(filterAutoCompleteButton, 'canvas-datagrid-context-menu-filter-button');\r\n            self.createInlineStyle(filterInput, 'canvas-datagrid-context-menu-filter-input');\r\n            checkRegExpErrorState();\r\n            filterInput.onclick = self.disposeAutocomplete;\r\n            filterInput.addEventListener('keydown', function (e) {\r\n                //down\r\n                if (e.keyCode === 40) {\r\n                    autoCompleteContext.selectedIndex += 1;\r\n                }\r\n                //up\r\n                if (e.keyCode === 38) {\r\n                    autoCompleteContext.selectedIndex -= 1;\r\n                }\r\n                //enter\r\n                if (e.keyCode === 13) {\r\n                    autoCompleteContext.clickIndex(autoCompleteContext.selectedIndex);\r\n                    self.disposeContextMenu();\r\n                }\r\n                //tab\r\n                if (e.keyCode === 9) {\r\n                    autoCompleteContext.clickIndex(autoCompleteContext.selectedIndex);\r\n                    e.preventDefault();\r\n                }\r\n                //esc\r\n                if (e.keyCode === 27) {\r\n                    self.disposeContextMenu();\r\n                }\r\n            });\r\n            filterInput.addEventListener('keyup', function () {\r\n                self.setFilter(e.cell.header.name, filterInput.value);\r\n            });\r\n            filterInput.addEventListener('keyup', createAutoCompleteContext);\r\n            ['focus', 'blur', 'keydown', 'keyup', 'change'].forEach(function (en) {\r\n                filterInput.addEventListener(en, checkRegExpErrorState);\r\n            });\r\n            filterInput.value = e.cell.header ? self.columnFilters[e.cell.header.name] || '' : '';\r\n            filterLabel.innerHTML = self.attributes.filterOptionText.replace(/%s/g, n);\r\n            filterAutoCompleteButton.onclick = function () {\r\n                if (autoCompleteContext) {\r\n                    return self.disposeAutocomplete();\r\n                }\r\n                createAutoCompleteContext();\r\n            };\r\n            filterAutoCompleteButton.innerHTML = self.style.contextFilterButtonHTML;\r\n            filterContainer.addEventListener('click', function (e) {\r\n                return e.stopPropagation();\r\n            });\r\n            filterContainer.appendChild(filterLabel);\r\n            filterContainer.appendChild(filterInput);\r\n            filterContainer.appendChild(filterAutoCompleteButton);\r\n            e.items.push({\r\n                title: filterContainer\r\n            });\r\n            if (Object.keys(self.columnFilters).length) {\r\n                Object.keys(self.columnFilters).forEach(function (cf) {\r\n                    var h = self.getHeaderByName(cf);\r\n                    e.items.push({\r\n                        title: self.attributes.removeFilterOptionText.replace(/%s/g, h.title || h.name),\r\n                        click: function removeFilterClick(e) {\r\n                            e.preventDefault();\r\n                            self.setFilter(cf, '');\r\n                            self.controlInput.focus();\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        function addDefaultContextMenuItem(e) {\r\n            var isNormalCell = !(e.cell.isBackground || e.cell.isColumnHeaderCellCap\r\n                    || e.cell.isScrollBar || e.cell.isCorner || e.cell.isRowHeader)\r\n                    && e.cell.header;\r\n            if (self.attributes.showFilter && isNormalCell) {\r\n                createFilterContextMenuItems(e);\r\n            }\r\n            if (self.attributes.showCopy\r\n                    && self.selections.reduce(function (p, r) {\r\n                        return p + r.length;\r\n                    }, 0) > 0) {\r\n                e.items.push({\r\n                    title: self.attributes.copyText,\r\n                    click: function () {\r\n                        document.execCommand('copy');\r\n                        self.disposeContextMenu();\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n            }\r\n            if (self.attributes.showPaste && self.clipBoardData) {\r\n                e.items.push({\r\n                    title: self.attributes.pasteText,\r\n                    click: function () {\r\n                        self.paste(self.clipBoardData, e.cell.columnIndex, e.cell.rowIndex);\r\n                        self.draw();\r\n                    }\r\n                });\r\n            }\r\n            if (self.attributes.showColumnSelector) {\r\n                e.items.push({\r\n                    title: self.attributes.columnSelectorText,\r\n                    items: function () {\r\n                        var d = [];\r\n                        self.getSchema().forEach(function (column) {\r\n                            function toggleColumnVisibility(e) {\r\n                                column.hidden = !column.hidden;\r\n                                self.dispatchEvent('togglecolumn', {column: column, hidden: column.hidden});\r\n                                e.preventDefault();\r\n                                self.stopPropagation(e);\r\n                                self.disposeContextMenu();\r\n                                self.resize(true);\r\n                                self.setStorageData();\r\n                            }\r\n                            var el = document.createElement('div');\r\n                            applyContextItemStyle(el);\r\n                            el.addEventListener('touchstart', toggleColumnVisibility);\r\n                            el.addEventListener('click', toggleColumnVisibility);\r\n                            el.innerHTML = (column.hidden ? self.attributes.columnSelectorHiddenText\r\n                                    : self.attributes.columnSelectorVisibleText)\r\n                                    + (column.title || column.name);\r\n                            d.push({\r\n                                title: el\r\n                            });\r\n                        });\r\n                        return d;\r\n                    }\r\n                });\r\n                if (e.cell && e.cell.header && e.cell.columnIndex > -1) {\r\n                    e.items.push({\r\n                        title: self.attributes.hideColumnText\r\n                            .replace(/%s/ig, e.cell.header.title || e.cell.header.name),\r\n                        click: function (ev) {\r\n                            self.getSchema()[e.cell.columnIndex].hidden = true;\r\n                            ev.preventDefault();\r\n                            self.stopPropagation(ev);\r\n                            self.disposeContextMenu();\r\n                            self.setStorageData();\r\n                            setTimeout(function () { self.resize(true); }, 10);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            if (self.attributes.saveAppearance && self.attributes.showClearSettingsOption\r\n                    && (Object.keys(self.sizes.rows).length > 0\r\n                        || Object.keys(self.sizes.columns).length > 0)) {\r\n                e.items.push({\r\n                    title: self.attributes.clearSettingsOptionText,\r\n                    click: function (e) {\r\n                        e.preventDefault();\r\n                        self.sizes.rows = {};\r\n                        self.sizes.columns = {};\r\n                        self.createRowOrders();\r\n                        self.createColumnOrders();\r\n                        self.storedSettings = undefined;\r\n                        self.dispatchEvent('resizecolumn', {columnWidth: self.style.cellWidth});\r\n                        self.dispatchEvent('resizerow', {cellHeight: self.style.cellHeight});\r\n                        self.setStorageData();\r\n                        self.resize(true);\r\n                        self.disposeContextMenu();\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n            }\r\n            if (self.attributes.allowSorting && self.attributes.showOrderByOption && isNormalCell) {\r\n                e.items.push({\r\n                    title: self.attributes.showOrderByOptionTextAsc.replace('%s', e.cell.header.title || e.cell.header.name),\r\n                    click: function (ev) {\r\n                        ev.preventDefault();\r\n                        self.order(e.cell.header.name, 'asc');\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n                e.items.push({\r\n                    title: self.attributes.showOrderByOptionTextDesc.replace('%s', e.cell.header.title || e.cell.header.name),\r\n                    click: function (ev) {\r\n                        ev.preventDefault();\r\n                        self.order(e.cell.header.name, 'desc');\r\n                        self.disposeContextMenu();\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        self.disposeAutocomplete = function () {\r\n            if (autoCompleteContext) {\r\n                autoCompleteContext.dispose();\r\n                autoCompleteContext = undefined;\r\n            }\r\n        };\r\n        self.disposeContextMenu = function () {\r\n            document.removeEventListener('click', self.disposeContextMenu);\r\n            zIndexTop = self.style.contextMenuZIndex;\r\n            self.disposeAutocomplete();\r\n            if (self.contextMenu) {\r\n                self.contextMenu.dispose();\r\n            }\r\n            self.contextMenu = undefined;\r\n        };\r\n        self.contextmenuEvent = function (e, overridePos) {\r\n            if (!self.hasFocus && e.target !== self.canvas) {\r\n                return;\r\n            }\r\n            function createDiposeEvent() {\r\n                requestAnimationFrame(function () {\r\n                    document.addEventListener('click', self.disposeContextMenu);\r\n                    document.removeEventListener('mouseup', createDiposeEvent);\r\n                });\r\n            }\r\n            var contextPosition,\r\n                items = [],\r\n                pos = overridePos || self.getLayerPos(e),\r\n                ev = {\r\n                    NativeEvent: e,\r\n                    cell: self.getCellAt(pos.x, pos.y),\r\n                    items: items\r\n                };\r\n            if (!ev.cell.isGrid) {\r\n                addDefaultContextMenuItem(ev);\r\n            }\r\n            if (self.dispatchEvent('contextmenu', ev)) {\r\n                return;\r\n            }\r\n            if (!ev.cell.isGrid) {\r\n                if (self.contextMenu) {\r\n                    self.disposeContextMenu();\r\n                }\r\n                contextPosition = {\r\n                    left: pos.x + pos.rect.left\r\n                        + self.style.contextMenuMarginLeft + self.canvasOffsetLeft,\r\n                    top: pos.y + pos.rect.top\r\n                        + self.style.contextMenuMarginTop + self.canvasOffsetTop,\r\n                    right: ev.cell.width + ev.cell.x + pos.rect.left,\r\n                    bottom: ev.cell.height + ev.cell.y + pos.rect.top,\r\n                    height: ev.cell.height,\r\n                    width: ev.cell.width\r\n                };\r\n                if (self.mobile) {\r\n                    contextPosition.left = self.style.mobileContextMenuMargin + 'px';\r\n                    contextPosition.width = self.width - (self.style.mobileContextMenuMargin * 2) + 'px';\r\n                }\r\n                self.contextMenu = createContextMenu(ev, contextPosition, items);\r\n                document.addEventListener('mouseup', createDiposeEvent);\r\n                e.preventDefault();\r\n            }\r\n        };\r\n        return;\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/contextMenu.js\n// module id = 7\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        self.getClippingRect = function (ele) {\r\n            var boundingRect = self.position(self.parentNode),\r\n                eleRect = self.position(ele),\r\n                s = self.scrollOffset(self.canvas),\r\n                clipRect = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    h: 0,\r\n                    w: 0\r\n                },\r\n                parentRect = {\r\n                    x: -Infinity,\r\n                    y: -Infinity,\r\n                    h: Infinity,\r\n                    w: Infinity\r\n                },\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n                rowHeaderCellWidth = self.getRowHeaderCellWidth();\r\n            boundingRect.top -= s.top;\r\n            boundingRect.left -= s.left;\r\n            eleRect.top -= s.top;\r\n            eleRect.left -= s.left;\r\n            clipRect.h = boundingRect.top + boundingRect.height - ele.offsetTop - self.style.scrollBarWidth;\r\n            clipRect.w = boundingRect.left + boundingRect.width - ele.offsetLeft - self.style.scrollBarWidth;\r\n            clipRect.x = boundingRect.left + (eleRect.left * -1) + rowHeaderCellWidth;\r\n            clipRect.y = boundingRect.top + (eleRect.top * -1) + columnHeaderCellHeight;\r\n            return {\r\n                x: clipRect.x > parentRect.x ? clipRect.x : parentRect.x,\r\n                y: clipRect.y > parentRect.y ? clipRect.y : parentRect.y,\r\n                h: clipRect.h < parentRect.h ? clipRect.h : parentRect.h,\r\n                w: clipRect.w < parentRect.w ? clipRect.w : parentRect.w\r\n            };\r\n        };\r\n        self.clipElement = function (ele) {\r\n            var clipRect = self.getClippingRect(ele);\r\n            if (clipRect.w < 0) { clipRect.w = 0; }\r\n            if (clipRect.h < 0) { clipRect.h = 0; }\r\n            ele.style.clip = 'rect('\r\n                + clipRect.y + 'px,'\r\n                + clipRect.w + 'px,'\r\n                + clipRect.h + 'px,'\r\n                + clipRect.x + 'px'\r\n                + ')';\r\n            // INFO https://developer.mozilla.org/en-US/docs/Web/CSS/clip\r\n            // clip has been \"deprecated\" for clipPath.  Of course nothing but chrome\r\n            // supports clip path, so we'll keep using clip until someday clipPath becomes\r\n            // more widely support.  The code below works correctly, but setting clipPath and clip\r\n            // at the same time has undesirable results.\r\n            // ele.style.clipPath = 'polygon('\r\n            //     + clipRect.x + 'px ' + clipRect.y + 'px,'\r\n            //     + clipRect.x + 'px ' + clipRect.h + 'px,'\r\n            //     + clipRect.w + 'px ' + clipRect.h + 'px,'\r\n            //     + clipRect.w + 'px ' + clipRect.y + 'px'\r\n            //     + ')';\r\n        };\r\n        self.scrollOffset = function (e) {\r\n            var x = 0, y = 0, scrollingElement = document.scrollingElement || { scrollLeft: 0, scrollTop: 0 };\r\n            while (e.parentNode && e.nodeName !== 'CANVAS-DATAGRID' && e !== self.intf) {\r\n                if (e.nodeType !== 'canvas-datagrid-tree'\r\n                        && e.nodeType !== 'canvas-datagrid-cell') {\r\n                    x -= e.scrollLeft;\r\n                    y -= e.scrollTop;\r\n                }\r\n                e = e.parentNode;\r\n            }\r\n            return {\r\n                left: x - scrollingElement.scrollLeft,\r\n                top: y - scrollingElement.scrollTop\r\n            };\r\n        };\r\n        self.resizeEditInput = function () {\r\n            if (self.input && self.input.editCell) {\r\n                var pos = self.canvas.getBoundingClientRect(),\r\n                    s = self.scrollOffset(self.intf),\r\n                    bm = self.style.gridBorderCollapse === 'collapse' ? 1 : 2,\r\n                    borderWidth = (self.style.cellBorderWidth * bm),\r\n                    cell = self.getVisibleCellByIndex(self.input.editCell.columnIndex, self.input.editCell.rowIndex)\r\n                        || {x: -100, y: -100, height: 0, width: 0};\r\n                if (self.mobile) {\r\n                    self.input.style.left = '0';\r\n                    self.input.style.top = (self.height - self.style.mobileEditInputHeight) - borderWidth - 1 + 'px';\r\n                    self.input.style.height = self.style.mobileEditInputHeight + 'px';\r\n                    self.input.style.width = self.width - borderWidth - 1 + 'px';\r\n                    return;\r\n                }\r\n                self.input.style.left = pos.left + cell.x + self.canvasOffsetLeft - s.left + 'px';\r\n                self.input.style.top = pos.top + cell.y - self.style.cellBorderWidth + self.canvasOffsetTop - s.top + 'px';\r\n                self.input.style.height = cell.height - borderWidth + 'px';\r\n                self.input.style.width = cell.width - self.style.cellPaddingLeft + 'px';\r\n                self.clipElement(self.input);\r\n            }\r\n        };\r\n        self.position = function (e, ignoreScrollOffset) {\r\n            var x = 0, y = 0, s = e, h, w;\r\n            while (e.offsetParent && e.nodeName !== 'CANVAS-DATAGRID') {\r\n                x += e.offsetLeft;\r\n                y += e.offsetTop;\r\n                h = e.offsetHeight;\r\n                w = e.offsetWidth;\r\n                e = e.offsetParent;\r\n            }\r\n            if (ignoreScrollOffset) {\r\n                return {left: x, top: y, height: h, width: w};\r\n            }\r\n            e = s;\r\n            s = self.scrollOffset(e);\r\n            return { left: x + s.left, top: y + s.top, height: h, width: w };\r\n        };\r\n        self.getLayerPos = function (e) {\r\n            var rect = self.canvas.getBoundingClientRect(),\r\n                pos = {\r\n                    x: e.clientX - rect.left,\r\n                    y: e.clientY - rect.top\r\n                };\r\n            if (self.isChildGrid) {\r\n                pos.x -= self.canvasOffsetLeft;\r\n                pos.y -= self.canvasOffsetTop;\r\n            }\r\n            return {\r\n                x: pos.x,\r\n                y: pos.y,\r\n                rect: rect\r\n            };\r\n        };\r\n        /**\r\n         * Ends editing, optionally aborting the edit.\r\n         * @memberof canvasDatagrid\r\n         * @name endEdit\r\n         * @method\r\n         * @param {boolean} abort When true, abort the edit.\r\n         */\r\n        self.endEdit = function (abort) {\r\n            var cell = self.input.editCell,\r\n                y = cell.rowIndex;\r\n            function abortEdit() {\r\n                abort = true;\r\n            }\r\n            if (self.dispatchEvent('beforeendedit', {\r\n                    cell: cell,\r\n                    newValue: self.input.value,\r\n                    oldValue: cell.value,\r\n                    abort: abortEdit,\r\n                    input: self.input\r\n                })) { return false; }\r\n            if (self.input.value !== cell.value && !abort) {\r\n                self.changes[y] = self.changes[y] || {};\r\n                self.changes[y][cell.header.name] = self.input.value;\r\n                if (!cell.data) {\r\n                    self.data[cell.rowIndex] = {};\r\n                    cell.data = self.data[cell.rowIndex];\r\n                }\r\n                cell.data[cell.header.name] = self.input.value;\r\n                if (y === self.data.length) {\r\n                    if (self.dispatchEvent('newrow', {\r\n                            value: self.input.value,\r\n                            defaultValue: cell.value,\r\n                            aborted: abort,\r\n                            cell: cell,\r\n                            input: self.input\r\n                        })) { return false; }\r\n                    self.addRow(cell.data);\r\n                    self.createNewRowData();\r\n                }\r\n                self.draw(true);\r\n            }\r\n            if (self.input.parentNode) {\r\n                self.input.parentNode.removeChild(self.input);\r\n            }\r\n            self.intf.focus();\r\n            self.dispatchEvent('endedit', {\r\n                cell: cell,\r\n                value: self.input.value,\r\n                aborted: abort,\r\n                input: self.input\r\n            });\r\n            self.input = undefined;\r\n            return true;\r\n        };\r\n        /**\r\n         * Begins editing at cell x, row y.\r\n         * @memberof canvasDatagrid\r\n         * @name beginEditAt\r\n         * @method\r\n         * @param {number} x The column index of the cell to edit.\r\n         * @param {number} y The row index of the cell to edit.\r\n         */\r\n        self.beginEditAt = function (x, y, NativeEvent) {\r\n            if (!self.attributes.editable) { return; }\r\n            if (self.input) {\r\n                self.endEdit();\r\n            }\r\n            var cell = self.getVisibleCellByIndex(x, y),\r\n                s = self.getSchema(),\r\n                adjacentCells,\r\n                enumItems,\r\n                enu,\r\n                option,\r\n                valueInEnum;\r\n            if (!(cell && cell.header)) { return; }\r\n            //HACK for IE10, does not like literal enum\r\n            enu = cell.header['enum'];\r\n            if (self.dispatchEvent('beforebeginedit', {cell: cell, NativeEvent: NativeEvent})) { return false; }\r\n            self.scrollIntoView(x, y);\r\n            self.setActiveCell(x, y);\r\n            adjacentCells = self.getAdjacentCells();\r\n            if (enu) {\r\n                self.input = document.createElement('select');\r\n            } else {\r\n                self.input = document.createElement(self.attributes.multiLine\r\n                    ? 'textarea' : 'input');\r\n            }\r\n            cell = self.getVisibleCellByIndex(x, y);\r\n            //HACK on mobile devices sometimes edit can begin without the cell being in view, I don't know how.\r\n            if (!cell) { return; }\r\n            if (enu) {\r\n                // add enums\r\n                if (typeof enu === 'function') {\r\n                    enumItems = enu.apply(self.intf, [{cell: cell}]);\r\n                } else if (Array.isArray(enu)) {\r\n                    enumItems = enu;\r\n                }\r\n                enumItems.forEach(function (e) {\r\n                    var i = document.createElement('option'),\r\n                        val,\r\n                        title;\r\n                    if (Array.isArray(e)) {\r\n                        val = e[0];\r\n                        title = e[1];\r\n                    } else {\r\n                        val = e;\r\n                        title = e;\r\n                    }\r\n                    if (val === cell.value) { valueInEnum = true; }\r\n                    i.value = val;\r\n                    i.innerHTML = title;\r\n                    self.input.appendChild(i);\r\n                });\r\n                if (!valueInEnum) {\r\n                    option = document.createElement('option');\r\n                    option.value = cell.value;\r\n                    option.innerHTML = cell.value;\r\n                    self.input.appendChild(option);\r\n                }\r\n                self.input.addEventListener('change', function () {\r\n                    self.endEdit();\r\n                    self.draw(true);\r\n                });\r\n            }\r\n            // if the user has not prevented the default action, append to the body\r\n            if (!self.dispatchEvent('appendeditinput', {cell: cell, input:self.input})) { \r\n                document.body.appendChild(self.input);\r\n            }\r\n            self.createInlineStyle(self.input, self.mobile ? 'canvas-datagrid-edit-mobile-input' : 'canvas-datagrid-edit-input');\r\n            self.input.style.position = 'absolute';\r\n            self.input.editCell = cell;\r\n            self.resizeEditInput();\r\n            self.input.style.zIndex = self.style.editCellZIndex;\r\n            self.input.style.fontSize = (parseInt(self.style.editCellFontSize, 10) * self.scale) + 'px';\r\n            self.input.value = [null, undefined].indexOf(cell.value) !== -1 ? '' : cell.value;\r\n            self.input.focus();\r\n            self.input.addEventListener('click', self.stopPropagation);\r\n            self.input.addEventListener('dblclick', self.stopPropagation);\r\n            self.input.addEventListener('mouseup', self.stopPropagation);\r\n            self.input.addEventListener('mousedown', self.stopPropagation);\r\n            self.input.addEventListener('keydown', function (e) {\r\n                var nx = cell.columnIndex,\r\n                    ny = cell.rowIndex;\r\n                // esc\r\n                if (e.keyCode === 27) {\r\n                    self.endEdit(true);\r\n                    self.draw(true);\r\n                // enter\r\n                } else if (e.keyCode === 13\r\n                        && (!self.attributes.multiLine\r\n                            || (self.attributes.multiLine && e.shiftKey))) {\r\n                    self.endEdit();\r\n                    self.draw(true);\r\n                } else if (e.keyCode === 9) {\r\n                    e.preventDefault();\r\n                    if (!self.endEdit()) {\r\n                        return;\r\n                    }\r\n                    if (e.shiftKey) {\r\n                        nx = adjacentCells.left;\r\n                    } else {\r\n                        nx = adjacentCells.right;\r\n                    }\r\n                    if (adjacentCells.left === x && e.shiftKey) {\r\n                        nx = adjacentCells.last;\r\n                        ny -= 1;\r\n                    }\r\n                    if (adjacentCells.right === x && !e.shiftKey) {\r\n                        nx = adjacentCells.first;\r\n                        ny += 1;\r\n                    }\r\n                    if (ny < 0) {\r\n                        ny = self.data.length - 1;\r\n                    }\r\n                    if (ny > self.data.length - 1) {\r\n                        ny = 0;\r\n                    }\r\n                    self.scrollIntoView(nx, ny);\r\n                    self.beginEditAt(nx, ny, e);\r\n                }\r\n            });\r\n            self.dispatchEvent('beginedit', {cell: cell, input: self.input});\r\n        };\r\n        self.createInlineStyle = function (el, className) {\r\n            var css = {\r\n                'canvas-datagrid-context-menu-filter-input': {\r\n                    height: '19px',\r\n                    verticalAlign: 'bottom',\r\n                    marginLeft: '2px',\r\n                    padding: '0',\r\n                    background: self.style.contextFilterInputBackground,\r\n                    color: self.style.contextFilterInputColor,\r\n                    border: self.style.contextFilterInputBorder,\r\n                    borderRadius: self.style.contextFilterInputBorderRadius,\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextFilterInputFontFamily,\r\n                    fontSize: self.style.contextFilterInputFontSize\r\n                },\r\n                'canvas-datagrid-context-menu-filter-button': {\r\n                    height: '19px',\r\n                    verticalAlign: 'bottom',\r\n                    marginLeft: '2px',\r\n                    padding: '0',\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextFilterButtonBorder,\r\n                    borderRadius: self.style.contextFilterButtonBorderRadius,\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFilterButtonFontFamily,\r\n                    fontSize: self.style.contextMenuFilterButtonFontSize\r\n                },\r\n                'canvas-datagrid-context-child-arrow': {\r\n                    cssFloat: 'right',\r\n                    color: self.style.childContextMenuArrowColor,\r\n                    fontSize: self.style.contextMenuChildArrowFontSize,\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    verticalAlign: 'middle'\r\n                },\r\n                'canvas-datagrid-autocomplete': {\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextMenuBorder,\r\n                    padding: self.style.contextMenuPadding,\r\n                    borderRadius: self.style.contextMenuBorderRadius,\r\n                    opacity: self.style.contextMenuOpacity,\r\n                    position: 'absolute',\r\n                    zIndex: 9999,\r\n                    overflow: 'hidden'\r\n                },\r\n                'canvas-datagrid-autocomplete-item': {\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor\r\n                },\r\n                'canvas-datagrid-autocomplete-item:hover': {\r\n                    background: self.style.contextMenuHoverBackground,\r\n                    color: self.style.contextMenuHoverColor\r\n                },\r\n                'canvas-datagrid-canvas': {\r\n                    position: 'absolute',\r\n                    zIndex: '-1'\r\n                },\r\n                'canvas-datagrid': {\r\n                    display: 'block'\r\n                },\r\n                'canvas-datagrid-control-input': {\r\n                    position: 'fixed',\r\n                    top: '-5px',\r\n                    left: '-5px',\r\n                    border: 'none',\r\n                    opacity: '0',\r\n                    cursor: 'pointer',\r\n                    width: '1px',\r\n                    height: '1px',\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize\r\n                },\r\n                'canvas-datagrid-edit-mobile-input': {\r\n                    boxSizing: 'content-box',\r\n                    outline: 'none',\r\n                    margin: '0',\r\n                    padding: '0 0 0 0',\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.mobileEditFontFamily,\r\n                    fontSize: self.style.mobileEditFontSize,\r\n                    border: self.style.editCellBorder,\r\n                    color: self.style.editCellColor,\r\n                    background: self.style.editCellBackgroundColor,\r\n                    appearance: 'none',\r\n                    webkitAppearance: 'none',\r\n                    mozAppearance: 'none',\r\n                    borderRadius: '0'\r\n                },\r\n                'canvas-datagrid-edit-input': {\r\n                    boxSizing: 'content-box',\r\n                    outline: 'none',\r\n                    margin: '0',\r\n                    padding: '0 0 0 ' + self.style.editCellPaddingLeft + 'px',\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.editCellFontFamily,\r\n                    fontSize: self.style.editCellFontSize,\r\n                    boxShadow: self.style.editCellBoxShadow,\r\n                    border: self.style.editCellBorder,\r\n                    color: self.style.editCellColor,\r\n                    background: self.style.editCellBackgroundColor,\r\n                    appearance: 'none',\r\n                    webkitAppearance: 'none',\r\n                    mozAppearance: 'none',\r\n                    borderRadius: '0'\r\n                },\r\n                'canvas-datagrid-context-menu-item-mobile': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    color: 'inherit',\r\n                    background: 'inherit',\r\n                    margin: self.style.contextMenuItemMargin,\r\n                    borderRadius: self.style.contextMenuItemBorderRadius,\r\n                    verticalAlign: 'middle'\r\n                },\r\n                'canvas-datagrid-context-menu-item': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    color: 'inherit',\r\n                    background: 'inherit',\r\n                    margin: self.style.contextMenuItemMargin,\r\n                    borderRadius: self.style.contextMenuItemBorderRadius,\r\n                    verticalAlign: 'middle'\r\n                },\r\n                'canvas-datagrid-context-menu-item:hover': {\r\n                    background: self.style.contextMenuHoverBackground,\r\n                    color: self.style.contextMenuHoverColor\r\n                },\r\n                'canvas-datagrid-context-menu-label': {\r\n                    margin: self.style.contextMenuLabelMargin,\r\n                    display: self.style.contextMenuLabelDisplay,\r\n                    minWidth: self.style.contextMenuLabelMinWidth,\r\n                    maxWidth: self.style.contextMenuLabelMaxWidth\r\n                },\r\n                'canvas-datagrid-context-menu-mobile': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextMenuBorder,\r\n                    padding: self.style.contextMenuPadding,\r\n                    borderRadius: self.style.contextMenuBorderRadius,\r\n                    opacity: self.style.contextMenuOpacity,\r\n                    overflow: 'hidden',\r\n                    whiteSpace: 'nowrap'\r\n                },\r\n                'canvas-datagrid-context-menu': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextMenuBorder,\r\n                    padding: self.style.contextMenuPadding,\r\n                    borderRadius: self.style.contextMenuBorderRadius,\r\n                    opacity: self.style.contextMenuOpacity,\r\n                    overflow: 'hidden',\r\n                    whiteSpace: 'nowrap',\r\n                    cursor: self.style.contextMenuCursor\r\n                },\r\n                'canvas-datagrid-invalid-search-regExp': {\r\n                    background: self.style.contextMenuFilterInvalidExpresion\r\n                }\r\n            };\r\n            if (css[className]) {\r\n                Object.keys(css[className]).map(function (prop) {\r\n                    el.style[prop] = css[className][prop];\r\n                });\r\n            }\r\n            return;\r\n        };\r\n        self.appendTo = function (e) {\r\n            self.parentNode = e;\r\n            self.setDom();\r\n        };\r\n        self.setDom = function () {\r\n            if (self.isChildGrid) {\r\n                self.parentGrid = self.parentNode.parentGrid;\r\n                self.ctx = self.parentGrid.context;\r\n                self.canvas = self.parentGrid.canvas;\r\n                self.controlInput = self.parentGrid.controlInput;\r\n                self.eventParent = self.canvas;\r\n            } else {\r\n                self.controlInput = self.controlInput || document.createElement('input');\r\n                self.controlInput.onblur = self.intf.blur;\r\n                self.createInlineStyle(self.controlInput, 'canvas-datagrid-control-input');\r\n                self.isChildGrid = false;\r\n                self.parentDOMNode = self.parentNode;\r\n                self.parentIsCanvas = /^canvas$/i.test(self.parentDOMNode.tagName);\r\n                if (self.parentIsCanvas) {\r\n                    self.canvas = self.parentDOMNode;\r\n                } else {\r\n                    self.canvas = document.createElement('canvas');\r\n                    if (self.intf.createShadowRoot) {\r\n                        self.parentDOMNode.appendChild(self.canvas);\r\n                    }\r\n                }\r\n                document.body.appendChild(self.controlInput);\r\n                self.createInlineStyle(self.canvas, 'canvas-datagrid');\r\n                self.ctx = self.canvas.getContext('2d');\r\n                self.ctx.textBaseline = 'alphabetic';\r\n                self.eventParent = self.canvas;\r\n            }\r\n            self.parentNodeStyle = self.canvas.style;\r\n            self.controlInput.setAttribute('readonly', true);\r\n            self.controlInput.addEventListener('blur', function (e) {\r\n                if (e.target !== self.canvas) {\r\n                    self.hasFocus = false;\r\n                }\r\n            });\r\n            self.eventParent.addEventListener('scroll', self.resize, false);\r\n            self.eventParent.addEventListener('touchstart', self.touchstart, false);\r\n            self.eventParent.addEventListener('mouseup', self.mouseup, false);\r\n            self.eventParent.addEventListener('mousedown', self.mousedown, false);\r\n            self.eventParent.addEventListener('dblclick', self.dblclick, false);\r\n            self.eventParent.addEventListener('click', self.click, false);\r\n            self.eventParent.addEventListener('mousemove', self.mousemove);\r\n            self[self.isChildGrid ? 'parentGrid' : 'eventParent'].addEventListener('wheel', self.scrollWheel, false);\r\n            self.canvas.addEventListener('contextmenu', self.contextmenuEvent, false);\r\n            self.controlInput.addEventListener('copy', self.copy);\r\n            self.controlInput.addEventListener('cut', self.cut);\r\n            self.controlInput.addEventListener('paste', self.paste);\r\n            self.controlInput.addEventListener('keypress', self.keypress, false);\r\n            self.controlInput.addEventListener('keyup', self.keyup, false);\r\n            self.controlInput.addEventListener('keydown', self.keydown, false);\r\n            window.addEventListener('resize', self.resize);\r\n        };\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/dom.js\n// module id = 8\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        /**\r\n         * Converts a integer into a letter A - ZZZZZ...\r\n         * @memberof canvasDatagrid\r\n         * @name integerToAlpha\r\n         * @method\r\n         * @param {column} n The number to convert.\r\n         */\r\n        self.integerToAlpha = function (n) {\r\n            var ordA = 'a'.charCodeAt(0),\r\n                ordZ = 'z'.charCodeAt(0),\r\n                len = ordZ - ordA + 1,\r\n                s = '';\r\n            while (n >= 0) {\r\n                s = String.fromCharCode(n % len + ordA) + s;\r\n                n = Math.floor(n / len) - 1;\r\n            }\r\n            return s;\r\n        };\r\n        /**\r\n         * Inserts a new column before the specified index into the schema.\r\n         * @tutorial schema\r\n         * @memberof canvasDatagrid\r\n         * @name insertColumn\r\n         * @method\r\n         * @param {column} c The column to insert into the schema.\r\n         * @param {number} index The index of the column to insert before.\r\n         */\r\n        self.insertColumn = function (c, index) {\r\n            var s = self.getSchema();\r\n            if (s.length < index) {\r\n                throw new Error('Index is beyond the length of the schema.');\r\n            }\r\n            self.validateColumn(c, s);\r\n            s.splice(index, 0, c);\r\n            self.data.forEach(function (row) {\r\n                self.applyDefaultValue(row, c);\r\n            });\r\n            self.intf.schema = s;\r\n        };\r\n        /**\r\n         * Deletes a column from the schema at the specified index.\r\n         * @memberof canvasDatagrid\r\n         * @name deleteColumn\r\n         * @tutorial schema\r\n         * @method\r\n         * @param {number} index The index of the column to delete.\r\n         */\r\n        self.deleteColumn = function (index) {\r\n            var s = self.getSchema();\r\n            // remove data matching this column name from data\r\n            self.data.forEach(function (row) {\r\n                delete row[s[index].name];\r\n            });\r\n            s.splice(index, 1);\r\n            self.intf.schema = s;\r\n        };\r\n        /**\r\n         * Adds a new column into the schema.\r\n         * @tutorial schema\r\n         * @memberof canvasDatagrid\r\n         * @name addColumn\r\n         * @method\r\n         * @param {column} c The column to add to the schema.\r\n         */\r\n        self.addColumn = function (c) {\r\n            var s = self.getSchema();\r\n            self.validateColumn(c, s);\r\n            s.push(c);\r\n            self.data.forEach(function (row) {\r\n                self.applyDefaultValue(row, c);\r\n            });\r\n            self.intf.schema = s;\r\n        };\r\n        /**\r\n         * Deletes a row from the dataset at the specified index.\r\n         * @memberof canvasDatagrid\r\n         * @name deleteRow\r\n         * @method\r\n         * @param {number} index The index of the row to delete.\r\n         */\r\n        self.deleteRow = function (index) {\r\n            self.originalData.splice(index, 1);\r\n            self.setFilter();\r\n            self.resize(true);\r\n        };\r\n        /**\r\n         * Inserts a new row into the dataset before the specified index.\r\n         * @memberof canvasDatagrid\r\n         * @name insertRow\r\n         * @method\r\n         * @param {object} d data.\r\n         * @param {number} index The index of the row to insert before.\r\n         */\r\n        self.insertRow = function (d, index) {\r\n            if (self.originalData.length < index) {\r\n                throw new Error('Index is beyond the length of the dataset.');\r\n            }\r\n            self.originalData.splice(index, 0, d);\r\n            self.getSchema().forEach(function (c) {\r\n                if (d[c.name] === undefined) {\r\n                    self.applyDefaultValue(self.originalData[index], c);\r\n                }\r\n            });\r\n            self.setFilter();\r\n            self.resize(true);\r\n        };\r\n        /**\r\n         * Adds a new row into the dataset.\r\n         * @memberof canvasDatagrid\r\n         * @name addRow\r\n         * @method\r\n         * @param {object} d data.\r\n         */\r\n        self.addRow = function (d) {\r\n            self.originalData.push(d);\r\n            self.getSchema().forEach(function (c) {\r\n                if (d[c.name] === undefined) {\r\n                    self.applyDefaultValue(self.originalData[self.originalData.length - 1], c);\r\n                }\r\n            });\r\n            self.setFilter();\r\n            self.resize(true);\r\n        };\r\n        /**\r\n         * Sets the height of a given row by index number.\r\n         * @memberof canvasDatagrid\r\n         * @name setRowHeight\r\n         * @method\r\n         * @param {number} rowIndex The index of the row to set.\r\n         * @param {number} height Height to set the row to.\r\n         */\r\n        self.setRowHeight = function (rowIndex, height) {\r\n            self.sizes.rows[rowIndex] = height;\r\n            self.draw(true);\r\n        };\r\n        /**\r\n         * Sets the width of a given column by index number.\r\n         * @memberof canvasDatagrid\r\n         * @name setColumnWidth\r\n         * @method\r\n         * @param {number} colIndex The index of the column to set.\r\n         * @param {number} width Width to set the column to.\r\n         */\r\n        self.setColumnWidth = function (colIndex, width) {\r\n            self.sizes.columns[colIndex] = width;\r\n            self.draw(true);\r\n        };\r\n        /**\r\n         * Removes any changes to the width of the columns due to user or api interaction, setting them back to the schema or style default.\r\n         * @memberof canvasDatagrid\r\n         * @name resetColumnWidths\r\n         * @tutorial schema\r\n         * @method\r\n         */\r\n        self.resetColumnWidths = function () {\r\n            self.sizes.columns = {};\r\n            self.draw(true);\r\n        };\r\n        /**\r\n         * Removes any changes to the height of the rows due to user or api interaction, setting them back to the schema or style default.\r\n         * @memberof canvasDatagrid\r\n         * @name resetRowHeights\r\n         * @tutorial schema\r\n         * @method\r\n         */\r\n        self.resetRowHeights = function () {\r\n            self.sizes.rows = {};\r\n            self.draw(true);\r\n        };\r\n        /**\r\n         * Sets the value of the filter.\r\n         * @memberof canvasDatagrid\r\n         * @name setFilter\r\n         * @method\r\n         * @param {string} column Name of the column to filter.\r\n         * @param {string} value The value to filter for.\r\n         */\r\n        self.setFilter = function (column, value) {\r\n            if (column === undefined && value === undefined) {\r\n                self.columnFilters = {};\r\n            } else if (column && (value === '' || value === undefined)) {\r\n                delete self.columnFilters[column];\r\n            } else {\r\n                self.columnFilters[column] = value;\r\n            }\r\n            self.applyDataTransforms();\r\n        };\r\n        /**\r\n         * Returns the number of pixels to scroll down to line up with row rowIndex.\r\n         * @memberof canvasDatagrid\r\n         * @name findRowScrollTop\r\n         * @method\r\n         * @param {number} rowIndex The row index of the row to scroll find.\r\n         */\r\n        self.findRowScrollTop = function (rowIndex) {\r\n            if (self.scrollCache.y[rowIndex] === undefined) { throw new RangeError('Row index out of range.'); }\r\n            return self.scrollCache.y[rowIndex];\r\n        };\r\n        /**\r\n         * Returns the number of pixels to scroll to the left to line up with column columnIndex.\r\n         * @memberof canvasDatagrid\r\n         * @name findColumnScrollLeft\r\n         * @method\r\n         * @param {number} columnIndex The column index of the column to find.\r\n         */\r\n        self.findColumnScrollLeft = function (columnIndex) {\r\n            var i = Math.max(columnIndex - 1, 0);\r\n            if (self.scrollCache.x[i] === undefined) { throw new Error('Column index out of range.'); }\r\n            return self.scrollCache.x[i] - self.getColummnWidth(self.orders.columns[columnIndex]);\r\n        };\r\n        /**\r\n         * Scrolls to the cell at columnIndex x, and rowIndex y.  If you define both rowIndex and columnIndex additional calculations can be made to center the cell using the target cell's height and width.  Defining only one rowIndex or only columnIndex will result in simpler calculations.\r\n         * @memberof canvasDatagrid\r\n         * @name gotoCell\r\n         * @method\r\n         * @param {number} x The column index of the cell to scroll to.\r\n         * @param {number} y The row index of the cell to scroll to.\r\n         * @param {number} [offsetX=0] Percentage offset the cell should be from the left edge (not including headers).  The default is 0, meaning the cell will appear at the left edge. Valid values are 0 through 1. 1 = Left, 0 = Right, 0.5 = Center.\r\n         * @param {number} [offsetY=0] Percentage offset the cell should be from the top edge (not including headers).  The default is 0, meaning the cell will appear at the top edge. Valid values are 0 through 1. 1 = Bottom, 0 = Top, 0.5 = Center.\r\n         */\r\n        self.gotoCell = function (x, y, offsetX, offsetY) {\r\n            var targetX = x === undefined ? undefined : self.findColumnScrollLeft(x),\r\n                targetY = y === undefined ? undefined : self.findRowScrollTop(y),\r\n                cell,\r\n                sbw = self.scrollBox.width - (self.scrollBox.verticalBarVisible ? self.style.scrollBarWidth : 0),\r\n                sbh = self.scrollBox.height - (self.scrollBox.horizontalBarVisible ? self.style.scrollBarWidth : 0);\r\n            offsetX = offsetX === undefined ? 0 : offsetX;\r\n            offsetY = offsetY === undefined ? 0 : offsetY;\r\n            targetX -= sbw * offsetX;\r\n            targetY -= sbh * offsetY;\r\n            if (x !== undefined && y !== undefined) {\r\n                self.scrollBox.scrollTo(targetX, targetY);\r\n                requestAnimationFrame(function () {\r\n                    cell = self.getVisibleCellByIndex(x, y);\r\n                    // HACK: just don't offset if the target cell cannot be seen\r\n                    // TODO: offset does not work on very small grids, not sure why\r\n                    if (!cell) { return; }\r\n                    targetX += cell.width * offsetX;\r\n                    targetY += cell.height * offsetY;\r\n                    self.scrollBox.scrollTo(targetX, targetY);\r\n                });\r\n            } else if (x !== undefined) {\r\n                self.scrollBox.scrollLeft = targetX;\r\n            } else if (y !== undefined) {\r\n                self.scrollBox.scrollTop = targetY;\r\n            }\r\n        };\r\n        /**\r\n         * Scrolls the row y.\r\n         * @memberof canvasDatagrid\r\n         * @name gotoRow\r\n         * @method\r\n         * @param {number} y The row index of the cell to scroll to.\r\n         */\r\n        self.gotoRow = function (y) {\r\n            self.gotoCell(0, y);\r\n        };\r\n        /**\r\n         * Scrolls the cell at cell x, row y into view if it is not already.\r\n         * @memberof canvasDatagrid\r\n         * @name scrollIntoView\r\n         * @method\r\n         * @param {number} x The column index of the cell to scroll into view.\r\n         * @param {number} y The row index of the cell to scroll into view.\r\n         * @param {number} [offsetX=0] Percentage offset the cell should be from the left edge (not including headers).  The default is 0, meaning the cell will appear at the left edge. Valid values are 0 through 1. 1 = Left, 0 = Right, 0.5 = Center.\r\n         * @param {number} [offsetY=0] Percentage offset the cell should be from the top edge (not including headers).  The default is 0, meaning the cell will appear at the top edge. Valid values are 0 through 1. 1 = Bottom, 0 = Top, 0.5 = Center.\r\n         */\r\n        self.scrollIntoView = function (x, y, offsetX, offsetY) {\r\n            if (self.visibleCells.filter(function (cell) {\r\n                    return (cell.rowIndex === y || y === undefined)\r\n                        && (cell.columnIndex === x || x === undefined)\r\n                        && cell.x > 0\r\n                        && cell.y > 0\r\n                        && cell.x + cell.width < self.width\r\n                        && cell.y + cell.height < self.height;\r\n                }).length === 0) {\r\n                self.gotoCell(x, y, offsetX, offsetY);\r\n            }\r\n        };\r\n        /**\r\n         * Sets the active cell. Requires redrawing.\r\n         * @memberof canvasDatagrid\r\n         * @name setActiveCell\r\n         * @method\r\n         * @param {number} x The column index of the cell to set active.\r\n         * @param {number} y The row index of the cell to set active.\r\n         */\r\n        self.setActiveCell = function (x, y) {\r\n            if (x < 0) { x = 0; }\r\n            if (y < 0) { y = 0; }\r\n            self.activeCell = {\r\n                rowIndex: y,\r\n                columnIndex: x\r\n            };\r\n        };\r\n        /**\r\n         * Removes the selection.\r\n         * @memberof canvasDatagrid\r\n         * @name selectNone\r\n         * @param {boolean} dontDraw Suppress the draw method after the selection change.\r\n         * @method\r\n         */\r\n        self.selectNone = function (dontDraw) {\r\n            self.selections = [];\r\n            self.dispatchEvent('selectionchanged', {\r\n                selectedData: self.getSelectedData(),\r\n                selections: self.selections,\r\n                selectionBounds: self.selectionBounds\r\n            });\r\n            if (dontDraw) { return; }\r\n            self.draw();\r\n        };\r\n        /**\r\n         * Selects every visible cell.\r\n         * @memberof canvasDatagrid\r\n         * @name selectAll\r\n         * @param {boolean} dontDraw Suppress the draw method after the selection change.\r\n         * @method\r\n         */\r\n        self.selectAll = function (dontDraw) {\r\n            self.selectArea({\r\n                top: 0,\r\n                left: -1,\r\n                right: self.getSchema().length - 1,\r\n                bottom: self.data.length - 1\r\n            });\r\n            if (dontDraw) { return; }\r\n            self.draw();\r\n        };\r\n        /**\r\n         * Returns true if the selected columnIndex is selected on every row.\r\n         * @memberof canvasDatagrid\r\n         * @name isColumnSelected\r\n         * @method\r\n         * @param {number} columnIndex The column index to check.\r\n         */\r\n        self.isColumnSelected = function (columnIndex) {\r\n            var colIsSelected = true;\r\n            self.data.forEach(function (row, rowIndex) {\r\n                if (!self.selections[rowIndex] || self.selections[rowIndex].indexOf(self.orders.columns[columnIndex]) === -1) {\r\n                    colIsSelected = false;\r\n                }\r\n            });\r\n            return colIsSelected;\r\n        };\r\n        /**\r\n         * Runs the defined method on each selected cell.\r\n         * @memberof canvasDatagrid\r\n         * @name forEachSelectedCell\r\n         * @method\r\n         * @param {number} fn The function to execute.  The signature of the function is: (data, rowIndex, columnName).\r\n         * @param {number} expandToRow When true the data in the array is expanded to the entire row.\r\n         */\r\n        self.forEachSelectedCell = function (fn, expandToRow) {\r\n            var d = [], s = expandToRow ? self.getSchema() : self.getVisibleSchema(), l = self.data.length;\r\n            self.selections.forEach(function (row, index) {\r\n                if (index === l) { return; }\r\n                if (row.length === 0) {\r\n                    d[index] = null;\r\n                    return;\r\n                }\r\n                d[index] = {};\r\n                row.forEach(function (col) {\r\n                    if (col === -1 || !s[col]) { return; }\r\n                    fn(self.data, index, s[col].name);\r\n                });\r\n            });\r\n        };\r\n        /**\r\n         * Selects a column.\r\n         * @memberof canvasDatagrid\r\n         * @name selectColumn\r\n         * @method\r\n         * @param {number} columnIndex The column index to select.\r\n         * @param {boolean} toggleSelectMode When true, behaves as if you were holding control/command when you clicked the column.\r\n         * @param {boolean} shift When true, behaves as if you were holding shift when you clicked the column.\r\n         * @param {boolean} supressSelectionchangedEvent When true, prevents the selectionchanged event from firing.\r\n         */\r\n        self.selectColumn = function (columnIndex, ctrl, shift, supressEvent) {\r\n            var s, e, x;\r\n            function addCol(i) {\r\n                self.data.forEach(function (row, rowIndex) {\r\n                    self.selections[rowIndex] = self.selections[rowIndex] || [];\r\n                    if (self.selections[rowIndex].indexOf(i) === -1) {\r\n                        self.selections[rowIndex].push(i);\r\n                    }\r\n                });\r\n            }\r\n            function removeCol(i) {\r\n                self.data.forEach(function (row, rowIndex) {\r\n                    self.selections[rowIndex] = self.selections[rowIndex] || [];\r\n                    if (self.selections[rowIndex].indexOf(i) !== -1) {\r\n                        self.selections[rowIndex].splice(self.selections[rowIndex].indexOf(i), 1);\r\n                    }\r\n                });\r\n            }\r\n            if (shift) {\r\n                if (!self.activeCell) { return; }\r\n                s = Math.min(self.activeCell.columnIndex, columnIndex);\r\n                e = Math.max(self.activeCell.columnIndex, columnIndex);\r\n                for (x = s; e > x; x += 1) {\r\n                    addCol(x);\r\n                }\r\n            }\r\n            if (!ctrl && !shift) {\r\n                self.selections = [];\r\n                self.activeCell.columnIndex = columnIndex;\r\n                self.activeCell.rowIndex = self.scrollIndexTop;\r\n            }\r\n            if (ctrl && self.isColumnSelected(columnIndex)) {\r\n                removeCol(columnIndex);\r\n            } else {\r\n                addCol(columnIndex);\r\n            }\r\n            if (supressEvent) { return; }\r\n            self.dispatchEvent('selectionchanged', {\r\n                selectedData: self.getSelectedData(),\r\n                selections: self.selections,\r\n                selectionBounds: self.getSelectionBounds()\r\n            });\r\n        };\r\n        /**\r\n         * Selects a row.\r\n         * @memberof canvasDatagrid\r\n         * @name selectRow\r\n         * @method\r\n         * @param {number} rowIndex The row index to select.\r\n         * @param {boolean} ctrl When true, behaves as if you were holding control/command when you clicked the row.\r\n         * @param {boolean} shift When true, behaves as if you were holding shift when you clicked the row.\r\n         * @param {boolean} supressSelectionchangedEvent When true, prevents the selectionchanged event from firing.\r\n         */\r\n        self.selectRow = function (rowIndex, ctrl, shift, supressEvent) {\r\n            var x, st, en, s = self.getVisibleSchema();\r\n            function de() {\r\n                if (supressEvent) { return; }\r\n                self.dispatchEvent('selectionchanged', {\r\n                    selectedData: self.getSelectedData(),\r\n                    selections: self.selections,\r\n                    selectionBounds: self.selectionBounds\r\n                });\r\n            }\r\n            function addRow(ri) {\r\n                self.selections[ri] = [];\r\n                self.selections[ri].push(-1);\r\n                s.forEach(function (col, index) {\r\n                    self.selections[ri].push(self.orders.columns.indexOf(col.index));\r\n                });\r\n            }\r\n            if (self.dragAddToSelection === false || self.dragObject === undefined) {\r\n                if (self.selections[rowIndex] && self.selections[rowIndex].length - 1 === s.length) {\r\n                    if (ctrl) {\r\n                        self.selections[rowIndex] = [];\r\n                        de();\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            if (self.dragAddToSelection === true || self.dragObject === undefined) {\r\n                if (shift && self.dragObject === undefined) {\r\n                    if (!self.activeCell) { return; }\r\n                    st = Math.min(self.activeCell.rowIndex, rowIndex);\r\n                    en = Math.max(self.activeCell.rowIndex, rowIndex);\r\n                    for (x = st; en >= x; x += 1) {\r\n                        addRow(x);\r\n                    }\r\n                } else {\r\n                    addRow(rowIndex);\r\n                }\r\n            }\r\n            de();\r\n        };\r\n        /**\r\n         * Collapse a tree grid by row index.\r\n         * @memberof canvasDatagrid\r\n         * @name collapseTree\r\n         * @method\r\n         * @param {number} index The index of the row to collapse.\r\n         */\r\n        self.collapseTree = function (rowIndex) {\r\n            self.dispatchEvent('collapsetree', {\r\n                childGrid: self.childGrids[rowIndex],\r\n                data: self.data[rowIndex],\r\n                rowIndex: rowIndex\r\n            });\r\n            self.openChildren[rowIndex].blur();\r\n            self.openChildren[rowIndex].dispose();\r\n            delete self.openChildren[rowIndex];\r\n            delete self.sizes.trees[rowIndex];\r\n            delete self.childGrids[rowIndex];\r\n            self.dispatchEvent('resizerow', {\r\n                cellHeight: self.style.cellHeight\r\n            });\r\n            self.resize(true);\r\n            self.draw(true);\r\n        };\r\n        /**\r\n         * Expands a tree grid by row index.\r\n         * @memberof canvasDatagrid\r\n         * @name expandTree\r\n         * @method\r\n         * @param {number} index The index of the row to expand.\r\n         */\r\n        self.expandTree = function (rowIndex) {\r\n            var trArgs = self.args.treeGridAttributes || {},\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n                rowHeaderCellWidth = self.sizes.columns.cornerCell || self.style.rowHeaderCellWidth,\r\n                h = self.sizes.trees[rowIndex] || self.style.treeGridHeight,\r\n                treeGrid;\r\n            if (!self.childGrids[rowIndex]) {\r\n                trArgs.debug = self.attributes.debug;\r\n                trArgs.name = self.attributes.saveAppearance ? self.attributes.name + 'tree' + rowIndex : undefined;\r\n                trArgs.style = trArgs.style || self.style;\r\n                trArgs.parentNode = {\r\n                    parentGrid: self.intf,\r\n                    nodeType: 'canvas-datagrid-tree',\r\n                    offsetHeight: h,\r\n                    offsetWidth: self.width - rowHeaderCellWidth,\r\n                    header: { width: self.width - rowHeaderCellWidth },\r\n                    offsetLeft: rowHeaderCellWidth,\r\n                    offsetTop: columnHeaderCellHeight,\r\n                    offsetParent: self.intf.parentNode,\r\n                    parentNode: self.intf.parentNode,\r\n                    style: 'tree',\r\n                    data: self.data[rowIndex]\r\n                };\r\n                treeGrid = self.createGrid(trArgs);\r\n                self.childGrids[rowIndex] = treeGrid;\r\n            }\r\n            treeGrid = self.childGrids[rowIndex];\r\n            treeGrid.visible = true;\r\n            self.dispatchEvent('expandtree', {\r\n                treeGrid: treeGrid,\r\n                data: self.data[rowIndex],\r\n                rowIndex: rowIndex\r\n            });\r\n            self.openChildren[rowIndex] = treeGrid;\r\n            self.sizes.trees[rowIndex] = h;\r\n            self.dispatchEvent('resizerow', {height: self.style.cellHeight});\r\n            self.resize(true);\r\n        };\r\n        /**\r\n         * Toggles tree grid open and close by row index.\r\n         * @memberof canvasDatagrid\r\n         * @name toggleTree\r\n         * @method\r\n         * @param {number} index The index of the row to toggle.\r\n         */\r\n        self.toggleTree = function (rowIndex) {\r\n            var i = self.openChildren[rowIndex];\r\n            if (i) {\r\n                return self.collapseTree(rowIndex);\r\n            }\r\n            self.expandTree(rowIndex);\r\n        };\r\n        /**\r\n         * Returns a header from the schema by name.\r\n         * @memberof canvasDatagrid\r\n         * @name getHeaderByName\r\n         * @tutorial schema\r\n         * @method\r\n         * @returns {header} header with the selected name, or undefined.\r\n         * @param {string} name The name of the column to resize.\r\n         */\r\n        self.getHeaderByName = function (name) {\r\n            var x, i = self.getSchema();\r\n            for (x = 0; x < i.length; x += 1) {\r\n                if (i[x].name === name) {\r\n                    return i[x];\r\n                }\r\n            }\r\n        };\r\n        /**\r\n         * Resizes a column to fit the longest value in the column. Call without a value to resize all columns.\r\n         * Warning, can be slow on very large record sets (1m records ~3-5 seconds on an i7).\r\n         * @memberof canvasDatagrid\r\n         * @name fitColumnToValues\r\n         * @method\r\n         * @param {string} name The name of the column to resize.\r\n         */\r\n        self.fitColumnToValues = function (name, internal) {\r\n            if (!self.canvas) { return; }\r\n            self.sizes.columns[name === 'cornerCell' ? -1 : self.getHeaderByName(name).index]\r\n                = Math.max(self.findColumnMaxTextLength(name), self.style.minColumnWidth);\r\n            if (!internal) {\r\n                self.resize();\r\n                self.draw(true);\r\n            }\r\n        };\r\n        /**\r\n         * Checks if a cell is currently visible.\r\n         * @memberof canvasDatagrid\r\n         * @name isCellVisible\r\n         * @overload\r\n         * @method\r\n         * @returns {boolean} when true, the cell is visible, when false the cell is not currently drawn.\r\n         * @param {number} columnIndex The column index of the cell to check.\r\n         * @param {number} rowIndex The row index of the cell to check.\r\n         */\r\n        /**\r\n         * Checks if a cell is currently visible.\r\n         * @memberof canvasDatagrid\r\n         * @name isCellVisible\r\n         * @method\r\n         * @returns {boolean} when true, the cell is visible, when false the cell is not currently drawn.\r\n         * @param {cell} cell The cell to check for.  Alternatively you can pass an object { x: <x-pixel-value>, y: <y-pixel-value> }.\r\n         */\r\n        self.isCellVisible = function (cell, rowIndex) {\r\n            // overload\r\n            if (rowIndex !== undefined) {\r\n                return self.visibleCells.filter(function (c) {\r\n                    return c.columnIndex === cell && c.rowIndex === rowIndex;\r\n                }).length > 0;\r\n            }\r\n            var x, l = self.visibleCells.length;\r\n            for (x = 0; x < l; x += 1) {\r\n                if (cell.x === self.visibleCells[x].x && cell.y === self.visibleCells[x].y) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        /**\r\n         * Sets the order of the data.\r\n         * @memberof canvasDatagrid\r\n         * @name order\r\n         * @method\r\n         * @param {number} columnName Name of the column to be sorted.\r\n         * @param {string} direction `asc` for ascending or `desc` for descending.\r\n         * @param {function} [sortFunction] When defined, override the default sorting method defined in the column's schema and use this one.\r\n         * @param {bool} [dontSetStorageData] Don't store this setting for future use.\r\n         */\r\n        self.order = function (columnName, direction, sortFunction, dontSetStorageData) {\r\n            var f,\r\n                c = self.getSchema().filter(function (col) {\r\n                    return col.name === columnName;\r\n                });\r\n            if (self.dispatchEvent('beforesortcolumn', {name: columnName, direction: direction})) { return; }\r\n            self.orderBy = columnName;\r\n            self.orderDirection = direction;\r\n            if (!self.data || self.data.length === 0) { return; }\r\n            if (c.length === 0) {\r\n                throw new Error('Cannot sort.  No such column name');\r\n            }\r\n            f = sortFunction || c[0].sorter || self.sorters[c[0].type];\r\n            if (!f && c[0].type !== undefined) {\r\n                console.warn('Cannot sort type \"%s\" falling back to string sort.', c[0].type);\r\n            }\r\n            self.orderings.add(columnName, direction, (typeof f === 'function' ? f : self.sorters.string));\r\n            self.orderings.sort();\r\n            self.dispatchEvent('sortcolumn', {name: columnName, direction: direction});\r\n            self.draw(true);\r\n            if (dontSetStorageData) { return; }\r\n            self.setStorageData();\r\n        };\r\n        self.isInGrid = function (e) {\r\n            if (e.x < 0\r\n                    || e.x > self.width\r\n                    || e.y < 0\r\n                    || e.y > self.height) {\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n        /**\r\n         * Moves the current selection relative to the its current position.  Note: this method does not move the selected data, just the selection itself.\r\n         * @memberof canvasDatagrid\r\n         * @name moveSelection\r\n         * @method\r\n         * @param {number} offsetX The number of columns to offset the selection.\r\n         * @param {number} offsetY The number of rows to offset the selection.\r\n         */\r\n        self.moveSelection = function (offsetX, offsetY) {\r\n            var sel = [];\r\n            self.selections.forEach(function (row, rowIndex) {\r\n                sel[rowIndex + offsetY] = [];\r\n                row.forEach(function (colIndex) {\r\n                    sel[rowIndex + offsetY].push(colIndex + offsetX);\r\n                });\r\n            });\r\n            self.selections = sel;\r\n        };\r\n        /**\r\n         * Moves data in the provided selection to another position in the grid.  Moving data off the edge of the schema (columns/x) will truncate data.\r\n         * @memberof canvasDatagrid\r\n         * @name moveTo\r\n         * @method\r\n         * @param {array} sel 2D array representing selected rows and columns.  `canvasDatagrid.selections` is in this format and can be used here.\r\n         * @param {number} x The column index to start inserting the selection at.\r\n         * @param {number} y The row index to start inserting the selection at.\r\n         */\r\n        self.moveTo = function (sel, x, y) {\r\n            var d = self.getSelectedData(),\r\n                s = self.getVisibleSchema(),\r\n                l = sel.length,\r\n                xi,\r\n                maxRowLength = -Infinity,\r\n                minXi = Infinity,\r\n                yi = y - 1;\r\n            sel.forEach(function (row, index) {\r\n                if (index === l) { return; }\r\n                if (row.length === 0) { return; }\r\n                minXi = Math.min(self.getVisibleColumnIndexOf(x), minXi);\r\n                maxRowLength = Math.max(maxRowLength, row.length);\r\n                row.forEach(function (colIndex) {\r\n                    // intentional redef of colIndex\r\n                    colIndex = self.getVisibleColumnIndexOf(colIndex);\r\n                    if (!s[colIndex]) { return; }\r\n                    if (!self.data[index]) { self.data[index] = {}; }\r\n                    self.data[index][s[colIndex].name] = null;\r\n                });\r\n            });\r\n            sel.forEach(function (row, index) {\r\n                var lastSourceIndex;\r\n                yi += 1;\r\n                xi = self.getVisibleColumnIndexOf(x);\r\n                row.forEach(function (colIndex, cidx) {\r\n                    colIndex = self.getVisibleColumnIndexOf(colIndex);\r\n                    if (cidx > 0) {\r\n                        // this confusing bit of nonsense figures out\r\n                        // if the selection has skipped cells\r\n                        xi += colIndex - lastSourceIndex;\r\n                    }\r\n                    lastSourceIndex = colIndex;\r\n                    if (colIndex === -1\r\n                            || !s[xi]\r\n                            || !s[colIndex]\r\n                            || self.data.length - 1 < yi\r\n                            || yi < 0) { return; }\r\n                    if (!self.data[yi]) { self.data[yi] = {}; }\r\n                    self.data[yi][s[xi].name] = d[index][s[colIndex].name];\r\n                });\r\n            });\r\n        };\r\n        /**\r\n         * Checks if a given column is visible.\r\n         * @memberof canvasDatagrid\r\n         * @name isColumnVisible\r\n         * @method\r\n         * @returns {boolean} When true, the column is visible.\r\n         * @param {number} columnIndex Column index.\r\n         */\r\n        self.isColumnVisible = function (columnIndex) {\r\n            return self.visibleCells.filter(function (c) {\r\n                return c.columnIndex === columnIndex;\r\n            }).length > 0;\r\n        };\r\n        /**\r\n         * Checks if a given row is visible.\r\n         * @memberof canvasDatagrid\r\n         * @name isRowVisible\r\n         * @method\r\n         * @returns {boolean} When true, the row is visible.\r\n         * @param {number} rowIndex Row index.\r\n         */\r\n        self.isRowVisible = function (rowIndex) {\r\n            return self.visibleCells.filter(function (c) {\r\n                return c.rowIndex === rowIndex;\r\n            }).length > 0;\r\n        };\r\n        /**\r\n         * Gets the cell at columnIndex and rowIndex.\r\n         * @memberof canvasDatagrid\r\n         * @name getVisibleCellByIndex\r\n         * @method\r\n         * @returns {cell} cell at the selected location.\r\n         * @param {number} x Column index.\r\n         * @param {number} y Row index.\r\n         */\r\n        self.getVisibleCellByIndex = function (x, y) {\r\n            return self.visibleCells.filter(function (c) {\r\n                return c.columnIndex === x && c.rowIndex === y;\r\n            })[0];\r\n        };\r\n        /**\r\n         * Gets the cell at grid pixel coordinate x and y.  Author's note.  This function ties drawing and events together.  This is a very complex function and is core to the component.\r\n         * @memberof canvasDatagrid\r\n         * @name getCellAt\r\n         * @method\r\n         * @returns {cell} cell at the selected location.\r\n         * @param {number} x Number of pixels from the left.\r\n         * @param {number} y Number of pixels from the top.\r\n         */\r\n        self.getCellAt = function (x, y, useTouchScrollZones) {\r\n            function getBorder(entitiy) {\r\n                if (entitiy.x + entitiy.width - (self.attributes.borderResizeZone * 0.4) < x && entitiy.x + entitiy.width + (self.attributes.borderResizeZone * 0.6) > x) {\r\n                    return 'r';\r\n                }\r\n                if (entitiy.x - (self.attributes.borderResizeZone * 0.4) < x && entitiy.x + (self.attributes.borderResizeZone * 0.6) > x) {\r\n                    return 'l';\r\n                }\r\n                if (entitiy.y + entitiy.height - (self.attributes.borderResizeZone * 0.4) < y && entitiy.y + entitiy.height + (self.attributes.borderResizeZone * 0.6) > y) {\r\n                    return 'b';\r\n                }\r\n                if (entitiy.y - (self.attributes.borderResizeZone * 0.4) < y && entitiy.y + (self.attributes.borderResizeZone * 0.6) > y) {\r\n                    return 't';\r\n                }\r\n            }\r\n            if (!self.visibleCells) { return; }\r\n            var border,\r\n                tsz = useTouchScrollZones ? self.attributes.touchScrollZone : 0,\r\n                moveMode = self.attributes.borderDragBehavior === 'move',\r\n                i,\r\n                l = self.visibleCells.length,\r\n                moveBorder,\r\n                xBorderBehavior = moveMode ? self.cursorGrab : 'ew-resize',\r\n                yBorderBehavior = moveMode ? self.cursorGrab : 'ns-resize',\r\n                cell,\r\n                entitiy;\r\n            if (!self.visibleCells || !self.visibleCells.length) { return; }\r\n            self.hasFocus = true;\r\n            if (!(y < self.height\r\n                && y > 0\r\n                && x < self.width\r\n                && x > 0)) {\r\n                self.hasFocus = false;\r\n                return {\r\n                    dragContext: 'inherit',\r\n                    context: 'inherit'\r\n                };\r\n            }\r\n            for (i = 0; i < l; i += 1) {\r\n                cell = self.visibleCells[i];\r\n                // interactive dimensions of the cell.  used for touch \"over size\" zones\r\n                entitiy = {\r\n                    x: cell.x,\r\n                    y: cell.y,\r\n                    height: cell.height,\r\n                    width: cell.width\r\n                };\r\n                if (useTouchScrollZones && /(vertical|horizontal)-scroll-/.test(cell.style)) {\r\n                    entitiy.x -= tsz;\r\n                    entitiy.y -= tsz;\r\n                    entitiy.height += tsz;\r\n                    entitiy.width += tsz;\r\n                }\r\n                if (entitiy.x - self.style.cellBorderWidth < x\r\n                        && entitiy.x + entitiy.width + self.style.cellBorderWidth > x\r\n                        && entitiy.y - self.style.cellBorderWidth < y\r\n                        && entitiy.y + entitiy.height + self.style.cellBorderWidth > y) {\r\n                    if (/frozen-row-marker/.test(cell.style)) {\r\n                        cell.dragContext = cell.style;\r\n                        cell.context = 'row-resize';\r\n                        return cell;\r\n                    }\r\n                    if (/frozen-column-marker/.test(cell.style)) {\r\n                        cell.dragContext = cell.style;\r\n                        cell.context = 'col-resize';\r\n                        return cell;\r\n                    }\r\n                    if (/selection-handle-/.test(cell.style)) {\r\n                        cell.dragContext = cell.style;\r\n                        cell.context = 'crosshair';\r\n                        return cell;\r\n                    }\r\n                    if (/vertical-scroll-(bar|box)/.test(cell.style)) {\r\n                        cell.dragContext = 'vertical-scroll-box';\r\n                        cell.context = 'vertical-scroll-box';\r\n                        cell.isScrollBar = true;\r\n                        cell.isVerticalScrollBar = true;\r\n                        if (y > self.scrollBox.box.v.y + self.scrollBox.scrollBoxHeight) {\r\n                            cell.dragContext = 'vertical-scroll-bottom';\r\n                            cell.context = 'vertical-scroll-bottom';\r\n                        } else if (y < self.scrollBox.box.v.y) {\r\n                            cell.dragContext = 'vertical-scroll-top';\r\n                            cell.context = 'vertical-scroll-top';\r\n                        }\r\n                        self.cursor = 'default';\r\n                        return cell;\r\n                    }\r\n                    if (/horizontal-scroll-(bar|box)/.test(cell.style)) {\r\n                        cell.dragContext = 'horizontal-scroll-box';\r\n                        cell.context = 'horizontal-scroll-box';\r\n                        cell.isScrollBar = true;\r\n                        cell.isHorizontalScrollBar = true;\r\n                        if (x > self.scrollBox.box.h.x + self.scrollBox.scrollBoxWidth) {\r\n                            cell.dragContext = 'horizontal-scroll-right';\r\n                            cell.context = 'horizontal-scroll-right';\r\n                        } else if (x < self.scrollBox.box.h.x) {\r\n                            cell.dragContext = 'horizontal-scroll-left';\r\n                            cell.context = 'horizontal-scroll-left';\r\n                        }\r\n                        self.cursor = 'default';\r\n                        return cell;\r\n                    }\r\n                    border = getBorder(entitiy);\r\n                    // check if the border of this cell is the border of the selection and if so show move cursor in move mode\r\n                    moveBorder = moveMode && cell.selectionBorder && cell.selectionBorder.indexOf(border) !== -1;\r\n                    if (['l', 'r'].indexOf(border) !== -1\r\n                            && (self.attributes.allowColumnResize || moveBorder)\r\n                            && ((self.attributes.allowColumnResizeFromCell && cell.isNormal) || !cell.isNormal || moveBorder)\r\n                            && ((self.attributes.allowRowHeaderResize && (cell.isRowHeader || cell.isCorner)) || !(cell.isRowHeader && cell.isCorner))) {\r\n                        if (((cell.isColumnHeader || cell.isCorner) || (self.attributes.allowColumnResizeFromCell && cell.isNormal)) && border === 'r') {\r\n                            cell.context = 'ew-resize';\r\n                            cell.dragContext = 'ew-resize';\r\n                            return cell;\r\n                        }\r\n                        if (!(cell.isColumnHeader || cell.isCorner) && moveBorder) {\r\n                            cell.context = xBorderBehavior;\r\n                            cell.dragContext = border + '-move';\r\n                            return cell;\r\n                        }\r\n                    }\r\n                    if (['t', 'b'].indexOf(border) !== -1\r\n                            && cell.rowIndex > -1\r\n                            && (self.attributes.allowRowResize || moveBorder)\r\n                            && ((self.attributes.allowRowResizeFromCell && cell.isNormal) || !cell.isNormal || moveBorder)\r\n                            && !cell.isColumnHeader) {\r\n                        if (((cell.isRowHeader || cell.isCorner) || (self.attributes.allowRowResizeFromCell && cell.isNormal)) && border === 'b') {\r\n                            cell.context = 'ns-resize';\r\n                            cell.dragContext = 'ns-resize';\r\n                            return cell;\r\n                        }\r\n                        if (!(cell.isRowHeader || cell.isCorner) && moveBorder) {\r\n                            cell.context = yBorderBehavior;\r\n                            cell.dragContext = border + '-move';\r\n                            return cell;\r\n                        }\r\n                    }\r\n                    if (cell.style === 'columnHeaderCell') {\r\n                        cell.context = 'cell';\r\n                        cell.dragContext = 'column-reorder';\r\n                        return cell;\r\n                    }\r\n                    if (cell.style === 'rowHeaderCell') {\r\n                        if ((self.attributes.rowGrabZoneSize + (cell.y - self.style.cellBorderWidth) < y)\r\n                                || !self.attributes.allowRowReordering) {\r\n                            cell.dragContext = 'cell';\r\n                            cell.context = 'cell';\r\n                        } else {\r\n                            cell.context = self.cursorGrab;\r\n                            cell.dragContext = 'row-reorder';\r\n                        }\r\n                        return cell;\r\n                    }\r\n                    if (cell.isGrid) {\r\n                        self.hasFocus = false;\r\n                        cell.dragContext = 'cell-grid';\r\n                        cell.context = 'cell-grid';\r\n                        return cell;\r\n                    }\r\n                    if (cell.style === 'tree-grid') {\r\n                        self.hasFocus = false;\r\n                        cell.dragContext = 'tree';\r\n                        cell.context = 'tree';\r\n                        return cell;\r\n                    }\r\n                    cell.dragContext = 'cell';\r\n                    cell.context = 'cell';\r\n                    return cell;\r\n                }\r\n            }\r\n            self.hasFocus = true;\r\n            self.cursor = 'default';\r\n            return {\r\n                dragContext: 'background',\r\n                context: 'background',\r\n                style: 'background',\r\n                isBackground: true\r\n            };\r\n        };\r\n        /**\r\n         * Gets the bounds of current selection. \r\n         * @returns {rect} selection.\r\n         * @memberof canvasDatagrid\r\n         * @name getSelectionBounds\r\n         * @method\r\n         */\r\n        self.getSelectionBounds = function () {\r\n            var low = {x: Infinity, y: Infinity},\r\n                high = {x: -Infinity, y: -Infinity};\r\n            self.selections.forEach(function (row, rowIndex) {\r\n                var maxCol, minCol;\r\n                low.y = rowIndex < low.y ? rowIndex : low.y;\r\n                high.y = rowIndex > high.y ? rowIndex : high.y;\r\n                maxCol = Math.max.apply(null, row);\r\n                minCol = Math.min.apply(null, row);\r\n                low.x = minCol < low.x ? minCol : low.x;\r\n                high.x = maxCol > high.x ? maxCol : high.x;\r\n            });\r\n            return {\r\n                top: low.y,\r\n                left: low.x,\r\n                bottom: high.y,\r\n                right: high.x\r\n            };\r\n        };\r\n        /**\r\n         * Returns an auto generated schema based on data structure.\r\n         * @memberof canvasDatagrid\r\n         * @name getSchemaFromData\r\n         * @method\r\n         * @tutorial schema\r\n         * @returns {schema} schema A schema based on the first item in the data array.\r\n         */\r\n        self.getSchemaFromData = function (d) {\r\n            d = d || self.data;\r\n            return Object.keys(d[0] || {' ': ''}).map(function mapEachSchemaColumn(key, index) {\r\n                var type = self.getBestGuessDataType(key, d),\r\n                    i = {\r\n                        name: key,\r\n                        title: isNaN(parseInt(key, 10)) ? key : self.integerToAlpha(key).toUpperCase(),\r\n                        index: index,\r\n                        type: type,\r\n                        filter: self.filter(type)\r\n                    };\r\n                if (self.storedSettings\r\n                        && self.storedSettings.visibility\r\n                        && self.storedSettings.visibility[i.name] !== undefined) {\r\n                    i.hidden = !self.storedSettings.visibility[i.name];\r\n                }\r\n                return i;\r\n            });\r\n        };\r\n        /**\r\n         * Clears the change log grid.changes that keeps track of changes to the data set.\r\n         * This does not undo changes or alter data it is simply a convince array to keep\r\n         * track of changes made to the data since last this method was called.\r\n         * @memberof canvasDatagrid\r\n         * @name clearChangeLog\r\n         * @method\r\n         */\r\n        self.clearChangeLog = function () {\r\n            self.changes = [];\r\n        };\r\n        /**\r\n         * Selects an area of the grid.\r\n         * @memberof canvasDatagrid\r\n         * @name selectArea\r\n         * @method\r\n         * @param {rect} bounds A rect object representing the selected values.\r\n         */\r\n        self.selectArea = function (bounds, ctrl) {\r\n            self.selectionBounds = bounds || self.selectionBounds;\r\n            var ev, x, y, s = self.getSchema();\r\n            if (!ctrl) {\r\n                self.selections = [];\r\n            }\r\n            if (self.selectionBounds.top < -1\r\n                    || self.selectionBounds.bottom > self.data.length\r\n                    || self.selectionBounds.left < -1\r\n                    || self.selectionBounds.right > s.length) {\r\n                throw new Error('Impossible selection area');\r\n            }\r\n            for (x = self.selectionBounds.top; x <= self.selectionBounds.bottom; x += 1) {\r\n                self.selections[x] = [];\r\n                for (y = self.selectionBounds.left; y <= self.selectionBounds.right; y += 1) {\r\n                    if (self.selections[x].indexOf(y) === -1) {\r\n                        self.selections[x].push(y);\r\n                    }\r\n                }\r\n            }\r\n            ev = {\r\n                selections: self.selections,\r\n                selectionBounds: self.selectionBounds\r\n            };\r\n            Object.defineProperty(ev, 'selectedData', {\r\n                get: function () {\r\n                    return self.getSelectedData();\r\n                }\r\n            });\r\n            self.dispatchEvent('selectionchanged', ev);\r\n        };\r\n        /**\r\n         * Returns the maximum text width for a given column by column name.\r\n         * @memberof canvasDatagrid\r\n         * @name findColumnMaxTextLength\r\n         * @method\r\n         * @returns {number} The number of pixels wide the maximum width value in the selected column.\r\n         * @param {string} name The name of the column to calculate the value's width of.\r\n         */\r\n        self.findColumnMaxTextLength = function (name) {\r\n            var m = -Infinity;\r\n            if (name === 'cornerCell') {\r\n                self.ctx.font = self.style.rowHeaderCellFont;\r\n                return self.ctx.measureText((self.data.length + (self.attributes.showNewRow ? 1 : 0)).toString()).width\r\n                    + self.style.autosizePadding + self.style.autosizeHeaderCellPadding\r\n                    + self.style.rowHeaderCellPaddingRight\r\n                    + self.style.rowHeaderCellPaddingLeft\r\n                    + (self.attributes.tree ? self.style.treeArrowWidth\r\n                        + self.style.treeArrowMarginLeft + self.style.treeArrowMarginRight : 0);\r\n            }\r\n            self.getSchema().forEach(function (col) {\r\n                if (col.name !== name) { return; }\r\n                self.ctx.font = self.style.columnHeaderCellFont;\r\n                var t = self.ctx.measureText(col.title || col.name).width\r\n                    + self.style.headerCellPaddingRight\r\n                    + self.style.headerCellPaddingLeft;\r\n                m = t > m ? t : m;\r\n            });\r\n            self.data.forEach(function (row) {\r\n                self.ctx.font = self.style.cellFont;\r\n                var t = self.ctx.measureText(row[name]).width\r\n                    + self.style.cellPaddingRight\r\n                    + self.style.cellPaddingLeft + self.style.cellAutoResizePadding;\r\n                m = t > m ? t : m;\r\n            });\r\n            return m;\r\n        };\r\n        /**\r\n         * Gets the total width of all header columns.\r\n         * @memberof canvasDatagrid\r\n         * @name getHeaderWidth\r\n         * @method\r\n         */\r\n        self.getHeaderWidth = function () {\r\n            return self.getVisibleSchema().reduce(function (total, header) {\r\n                return total + (header.width || self.style.cellWidth);\r\n            }, 0);\r\n        };\r\n        /**\r\n         * Gets the height of a row by index.\r\n         * @memberof canvasDatagrid\r\n         * @name getRowHeight\r\n         * @method\r\n         * @param {number} rowIndex The row index to lookup.\r\n         */\r\n        self.getRowHeight = function (rowIndex) {\r\n            return ((self.sizes.rows[rowIndex]\r\n                    || self.style.cellHeight) * self.scale);\r\n        };\r\n        /**\r\n         * Gets the width of a column by index.\r\n         * @memberof canvasDatagrid\r\n         * @name getColummnWidth\r\n         * @method\r\n         * @param {number} columnIndex The column index to lookup.\r\n         */\r\n        self.getColummnWidth = function (columnIndex) {\r\n            return ((self.sizes.columns[columnIndex]\r\n                    || self.getSchema()[columnIndex].width\r\n                    || self.style.cellWidth) * self.scale);\r\n        };\r\n        self.formatters.string = function cellFormatterString(e) {\r\n            return e.cell.value !== undefined ? e.cell.value : '';\r\n        };\r\n        self.formatters.rowHeaderCell = self.formatters.string;\r\n        self.formatters.headerCell = self.formatters.string;\r\n        self.formatters.number = self.formatters.string;\r\n        self.formatters.int = self.formatters.string;\r\n        self.formatters.html = self.formatters.string;\r\n        self.sorters.string = function (columnName, direction) {\r\n            var asc = direction === 'asc';\r\n            return function (a, b) {\r\n                if (a[columnName] === undefined || a[columnName] === null) {\r\n                    return 1;\r\n                }\r\n                if (b[columnName] === undefined || b[columnName] === null) {\r\n                    return 0;\r\n                }\r\n                if (asc) {\r\n                    if (!a[columnName].localeCompare) { return 1; }\r\n                    return a[columnName].localeCompare(b[columnName]);\r\n                }\r\n                if (!b[columnName].localeCompare) { return 1; }\r\n                return b[columnName].localeCompare(a[columnName]);\r\n            };\r\n        };\r\n        self.sorters.number = function (columnName, direction) {\r\n            var asc = direction === 'asc';\r\n            return function (a, b) {\r\n                if (asc) {\r\n                    return a[columnName] - b[columnName];\r\n                }\r\n                return b[columnName] - a[columnName];\r\n            };\r\n        };\r\n        self.sorters.date = function (columnName, direction) {\r\n            var asc = direction === 'asc';\r\n            return function (a, b) {\r\n                if (asc) {\r\n                    return new Date(a[columnName]).getTime()\r\n                        - new Date(b[columnName]).getTime();\r\n                }\r\n                return new Date(b[columnName]).getTime()\r\n                        - new Date(a[columnName]).getTime();\r\n            };\r\n        };\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/publicMethods.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}