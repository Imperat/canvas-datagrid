{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 6c2621dd6439cddb047d","webpack:///canvas-datagrid.js","webpack:///./lib/defaults.js","webpack:///./lib/main.js","webpack:///./lib/component.js","webpack:///./lib/draw.js","webpack:///./lib/events.js","webpack:///./lib/touch.js","webpack:///./lib/intf.js","webpack:///./lib/contextMenu.js","webpack:///./lib/dom.js","webpack:///./lib/publicMethods.js"],"names":["root","factory","exports","module","define","amd","self","this","__webpack_require__","moduleId","installedModules","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","defaults","attributes","styles","context","component","Grid","args","isComponent","undefined","isChildGrid","parentNode","test","nodeType","intf","eval","document","createElement","applyComponentStyle","hyphenateProperty","dehyphenateProperty","createGrid","forEach","shadowRoot","createShadowRoot","attachShadow","mode","init","Array","slice","arguments","window","HTMLElement","create","customElements","observedAttributes","getObservableAttributes","disconnectedCallback","attributeChangedCallback","connectedCallback","adoptedCallback","canvasDatagrid","require","tKeys","body","keys","argKey","indexOf","tKey","sKey","data","appendChild","getDefaultItem","base","item","filter","toLowerCase","typeMap","prop","replace","nextLetterCap","char","toUpperCase","cust","supressChangeAndDrawEvents","cStyle","getComputedStyle","tagName","canvas","defs","computedStyle","def","val","getPropertyValue","setStyleProperty","dispatchEvent","requestAnimationFrame","resize","style","strData","JSON","parse","e","Error","schema","strSchema","number","strNum","parseInt","isNaN","boolean","strBool","string","str","attrs","attr","push","connected","parentDOMNode","innerHTML","observe","attrName","oldVal","newVal","tfn","dataType","addEventListener","observer","MutationObserver","mutations","checkInnerHTML","checkStyle","mutation","attributeName","target","nodeName","addedNodes","length","type","characterData","childList","subtree","querySelectorAll","el","fillArray","low","high","step","x","drawPerfLine","w","h","y","perfArr","arrIndex","max","color","useAbs","r","canvasOffsetLeft","canvasOffsetTop","ctx","beginPath","moveTo","cx","cy","Math","abs","lineTo","strokeStyle","stroke","drawOnAllImagesLoaded","loaded","htmlImageCache","html","complete","cachedImagesDrawn","draw","drawHtml","cell","img","v","formattedValue","cacheKey","toString","rowIndex","columnIndex","height","width","drawImage","Image","onload","src","btoa","drawOrderByArrow","mt","columnHeaderOrderByArrowMarginTop","scale","ml","columnHeaderOrderByArrowMarginLeft","mr","columnHeaderOrderByArrowMarginRight","aw","columnHeaderOrderByArrowWidth","ah","columnHeaderOrderByArrowHeight","fillStyle","columnHeaderOrderByArrowColor","columnHeaderOrderByArrowBorderColor","orderDirection","fill","drawTreeArrow","treeArrowMarginTop","treeArrowMarginRight","treeArrowMarginLeft","treeArrowWidth","treeArrowHeight","treeArrowColor","treeArrowBorderColor","openChildren","radiusRect","radius","b","quadraticCurveTo","fillRect","strokeRect","fillText","text","fillCircle","arc","PI","strokeCircle","clipFrozenArea","lastFrozenColumnPixel","lastFrozenRowPixel","clip","fillHandle","selectionHandleType","strokeHandle","addselectionHandle","pos","hw","selectionHandleSize","tr","br","tl","bl","addBorderLine","t","wrapText","splitChar","lines","value","calculatedLineHeight","word","elWidth","plWidth","clippedVal","previousLine","words","split","textHeight","wrap","cellWhiteSpace","et","ellipsisText","line","cHeight","paddedHeight","measureText","measure","paddedWidth","splice","originText","stepLength","direction","substr","drawText","fontHeight","lineHeight","vPos","hPos","paddingLeft","orderByArrowWidth","horizontalAlignment","paddingRight","verticalAlignment","paddingBottom","lineSpacing","offsetLeft","offsetTop","debug","active","font","debugFont","debugColor","stringify","pw","idx","idx_ord","sortColumnIndex","map","getFrozenColumnsWidth","column","getSchema","min","frozenColumn","hiddenFrozenColumnCount","hidden","getColummnWidth","perfCounters","drawCount","perfWindowSize","entityCount","scrollDebugCounters","touchPPSCounters","internal","createHandlesOverlayArray","allowMovingSelection","mobile","selectionBorderTop","selectionBorderRight","selectionHandles","selectionHandle","selectionBorderLeft","selectionBorderBottom","selectionHandleBehavior","createBorderOverlayArray","drawArray","propPrefix","offsetPoint","selectionBorder","isRowHeader","selections","isHeader","drawCell","rowOrderIndex","header","headerIndex","columnOrderIndex","cellGridAttributes","cellStyle","isCorner","isColumnHeader","selected","hovered","hovers","activeCell","isColumnHeaderCellCap","rawValue","isGrid","activeHeader","orders","rows","columns","f","formatters","orderByArrowSize","treeArrowSize","cellWidth","sizes","ev","row","cellBorderWidth","visibleRows","paddingTop","whiteSpace","cellLineHeight","cellLineSpacing","scrollTop","scrollBox","scrollLeft","cellHeight","offsetWidth","offsetHeight","offsetParent","rowOpen","sortRowIndex","isNormal","gridId","parentGrid","title","userHeight","rowHeight","userWidth","cornerCell","visibleCells","unshift","lineWidth","cellHeightWithChildGrid","checkScrollHeight","cellWidthWithChildGrid","save","tree","showRowNumbers","childGrids","saveAppearance","cellGridHeight","grid","visible","orderBy","console","warn","columnFilters","filterTextPrefix","aCell","selectionBorders","movingSelection","moveBorders","moveOffset","restore","bc","drawRowHeader","rowData","index","a","showRowHeaders","rowHeaderCell","rowHeaderCellWidth","drawRow","treeHeight","rowSansTreeHeight","g","rd","trees","scrollIndexRight","scrollPixelRight","scrollPixelLeft","treeGrid","scrollBarWidth","rowHeaders","visibleRowHeights","gridBorderCollapse","columnHeaderCellHeight","currentCell","getColumnHeaderCellHeight","getRowHeaderCellWidth","performance","now","createRowOrders","gridBackgroundColor","ln","frozenRow","allowFreezingRows","frozenMarkerBorderWidth","frozenMarkerWidth","snapToRow","scrollPixelTop","scrollIndexTop","scrollIndexBottom","scrollPixelBottom","showNewRow","scrollIndexLeft","newRow","cl","selectionMode","activeCellOverlayBorderWidth","activeCellOverlayBorderColor","getHeaderWidth","drawHeaderColumnRange","start","end","order","columnHeaderCell","nonFrozenHeaderWidth","rArgs","rhIndex","showColumnHeaders","columnHeaderCellBorderWidth","isColumnHeaderCell","endCap","my","mx","xHover","yHover","allowFreezingColumns","frozenMarkerHoverColor","frozenMarkerColor","frozenMarkerHoverBorderColor","frozenMarkerBorderColor","freezeMarkerPosition","frozenMarkerActiveColor","frozenMarkerActiveBorderColor","dragMode","selectionHandleBorderWidth","selectionHandleBorderColor","selectionHandleColor","az","touchSelectHandleZone","ax","ay","reorderObject","dragOffset","reorderMarkerBackgroundColor","reorderMarkerBorderWidth","reorderMarkerBorderColor","reorderMarkerIndexBorderWidth","reorderMarkerIndexBorderColor","reorderTarget","moveOverlayBorderWidth","moveOverlayBorderColor","setLineDash","moveOverlayBorderSegments","gridBorderWidth","gridBorderColor","dsb","selectionOverlayBorderWidth","selectionOverlayBorderColor","showPerformance","pop","perf","reduce","toFixed","perfDelta","frozenColumnsWidth","htmlImages","startScale","scaleDelta","zoomDeltaStart","touchLength","touches","touchPosition","touchPosition1","scrollIndex","scrollPixel","canvasOffset","touchDelta","touchAnimateTo","scrollAnimation","touchPPS","xPPS","yPPS","touchPPST","xPPST","yPPST","touchDuration","pointerLockPosition","size","mouse","touch","touchStart","entities","hasFocus","dragContext","textAlign","debugBackgroundColor","key","dpl","ph","px","py","debugPerfChartTextColor","scrollBarBorderWidth","debugPerfChartBackground","scrollHeight","debugScrollHeightColor","scrollWidth","debugScrollWidthColor","debugPerformanceColor","debugEntitiesColor","debugTouchPPSXColor","debugTouchPPSYColor","apply","wheeling","stopPropagation","fn","events","removeEventListener","sfn","preventDefault","defaultPrevented","getRatio","maxPixelRatio","devicePixelRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","drawAfterResize","checkScrollBoxVisibility","horizontalBarVisible","dataWidth","overflowX","horizontalBoxVisible","verticalBarVisible","dataHeight","overflowY","verticalBoxVisible","setScrollBoxSize","setCanvasSize","dims","cellBorder","dim","appliedInlineStyles","parentNodeStyle","isComponet","vb","nb","co","isScrollBoxCorner","scrollBarBoxMargin","sbw","ratio","bm","columnHeaderCellBorder","ch","scrollCache","accumulator","va","top","left","widthBoxRatio","scrollBoxWidth","heightBoxRatio","scrollBoxHeight","scrollBarBoxMinSize","scrollBarBoxWidth","horizontalBar","horizontalBox","verticalBar","verticalBox","corner","bar","box","page","pageUpDownOverlap","resizeEditInput","scroll","dontDraw","floor","ellipsisCache","mousemove","overridePos","contextMenu","input","getLayerPos","dragBounds","sBounds","delta","ctrl","ctrlKey","metaKey","persistantSelectionMode","getCellAt","NativeEvent","previousCell","clearTimeout","scrollTimer","isInGrid","rowBoundaryCrossed","columnBoundaryCrossed","cellBoundaryCrossed","prefix","draggingItem","scrollModes","dragItem","cursor","selecting","dragStart","dragStartObject","shiftKey","bottom","right","getSelectionBounds","ignoreNextClick","dragAddToSelection","selectRow","selectionBounds","selectArea","autoScrollZone","click","checkSelectionChange","sb","startingBounds","getSelectedData","endEdit","setActiveCell","selectAll","columnHeaderClickBehavior","selectColumn","treeArrowClickRadius","toggleTree","dragResizeColumn","resizingStartingWidth","resizingStartingHeight","minColumnWidth","minRowHeight","resizeScrollZone","resizeChildGrids","globalRowResize","stopDragResize","setStorageData","scrollGrid","scrollPointerLock","scrollStartMode","movementX","movementY","scrollMode","scrollStart","setTimeout","scrollRepeatRate","selectionScrollIncrement","stopScrollGrid","exitPointerLock","dragReorder","columReorder","rowReorder","allowColumnReordering","allowRowReordering","source","reorderDeadZone","stopDragReorder","oIndex","tIndex","cr","dragMove","stopDragMove","moveSelection","freezeMove","stopFreezeMove","startFreezeMove","mousedown","lastMouseDownTarget","button","move","freeze","requestPointerLock","concat","dragging","mouseup","controlInput","focus","getAdjacentCells","first","last","keydown","adjacentCells","cols","keyCode","beginEditAt","Number","scrollIntoView","selectionFollowsActiveCell","selectedData","keyup","keypress","dblclick","fitColumnToValues","autosize","scrollWheel","deltaX","deltaY","deltaMode","touchHaltAnimation","scrollTo","pasteItem","clipData","mimeType","normalizeRowData","importingRow","existingRow","offsetX","isArray","colKey","substring","sel","cellData","colIndex","cName","getVisibleSchema","yi","getNextVisibleColumnIndex","visibleColumnIndex","getVisibleColumnIndexOf","paste","clipboardData","items","dti","getAsString","cut","copy","forEachSelectedCell","colName","htmlSafe","fCopyCell","addHeaders","headers","useHtml","hVal","join","addCellValue","trRow","textRow","outputHeaderKeys","tableRows","textRows","outputHeaders","sData","rowKeys","sSorted","setData","touchMove","touchScroll","rScrollZone","bScrollZone","tScrollZone","lScrollZone","touchScrollTimeout","rw","t1","t2","changedTouches","getTouchPos","touchDeadZone","touchContextTimeout","touchZoomSensitivity","touchZoomMin","touchZoomMax","zoomAltered","selectionScrollZone","calculatePPS","touchScrollStart","stopAnimation","animationFrames","touchSelecting","startingCell","touchSelect","touchMoving","touchIndex","rect","getBoundingClientRect","clientX","clientY","easingFunctions","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easing","touchEasingMethod","calculatePPSTimed","touchSigmaTimed","touchSigma","touchEndAnimation","touchReleaseAnimationDurationMs","touchEditCell","touchCell","clearInterval","calculatePPSTimer","touchingCell","editCell","touchstart","disposeContextMenu","touchStartEvent","touchStart1","contextmenuEvent","touchContextMenuTimeMs","setInterval","touchEndEvents","touchmove","passive","touchend","touchcancel","handleType","bounds","dz","touchReleaseAcceleration","scrollAnimationPPSThreshold","ctor","treeGridAttributes","storageName","invalidSearchExpClass","localStyleLibraryStorageKey","orderings","add","sortFunction","col","sort","filters","currentFilter","sorters","parsers","schemaHashes","changes","componentL1Events","eventNames","expandToRow","orderedIndex","visibility","localStorage","setItem","tempSchema","createColumnOrders","applyDefaultValue","defaultValue","createNewRowData","getSchemaNameHash","applyFilter","refreshFromOrigialData","getHeaderByName","applyDataTransforms","getBestGuessDataType","columnName","drawChildGrids","gridKey","setTimer","originalData","validateColumn","setDefaults","obj1","obj2","setAttributes","setStyle","findColumnMaxTextLength","dispose","removeChild","eventParent","contextmenu","disconnect","tryLoadStoredSettings","reloadStoredValues","storedSettings","getDomRoot","host","getFontName","fontStyle","getFontHeight","parseFloat","parseStyleValue","initProp","propName","getStyleProperty","styleKeys","supressDrawAndEvent","isDim","getItem","message","addStyleKeyIfNoneExists","initialized","publicStyleKeyIntf","initScrollBox","setDom","ie","navigator","userAgent","edge","webKit","moz","cursorGrab","cursorGrabing","cursorGrabbing","appendTo","getVisibleCellByIndex","clearChangeLog","gotoCell","gotoRow","findColumnScrollLeft","findRowScrollTop","isCellVisible","isRowVisible","isColumnVisible","clipElement","getSchemaFromData","setFilter","expandTree","collapseTree","insertRow","deleteRow","addRow","insertColumn","deleteColumn","addColumn","getClippingRect","setRowHeight","setColumnWidth","resetColumnWidths","resetRowHeights","selectNone","assertPxColor","clearPxColorAssertions","integerToAlpha","DOMStyles","set","valueObject","filterFor","String","filterRegExp","regEnd","pattern","exec","flags","flagLength","invalidFilterRegEx","RegExp","toLocaleUpperCase","innerText","textContent","blur","TypeError","currentCursor","find","eventName","RangeError","getTypes","parseInnerHtml","callback","etl","autoGenerateSchema","autoResizeColumns","setScrollTop","preventScrollEvent","setScrollLeft","sHeight","sWidth","supressDrawEvent","applyContextItemStyle","contextItemContainer","createInlineStyle","createContextMenu","parentContextMenu","createItems","removeChildContext","relatedTarget","container","childMenuArrow","contains","children","setAttribute","contextAddCallback","getAttribute","cPos","childContextMenuMarginLeft","childContextMenuMarginTop","createChildContext","addContent","content","childContextMenuArrowHTML","clickIndex","Event","checkArrowVisibility","upArrow","downArrow","startHoverScroll","contextHoverScrollAmount","hoverScrollTimeout","contextHoverScrollRateMs","endHoverScroll","selectedIndex","loc","scrollOffset","zIndexTop","contextMenuZIndex","position","contextMenuArrowColor","zIndex","inputDropdown","maxHeight","innerHeight","autocompleteBottomMargin","minWidth","contextMenuArrowUpHTML","contextMenuArrowDownHTML","contextMenuWindowMargin","innerWidth","isFinite","createFilterContextMenuItems","checkRegExpErrorState","filterInput","background","contextFilterInputBackground","contextFilterInputColor","contextFilterInvalidRegExpBackground","contextFilterInvalidRegExpColor","fillAutoComplete","count","autoCompleteItems","maxAutoCompleteItems","disposeAutocomplete","createAutoCompleteContext","iRect","autoCompleteContext","filterContainer","filterLabel","filterAutoCompleteButton","onclick","en","filterOptionText","contextFilterButtonHTML","cf","removeFilterOptionText","addDefaultContextMenuItem","isNormalCell","isBackground","isScrollBar","showFilter","showCopy","copyText","execCommand","showPaste","clipBoardData","pasteText","showColumnSelector","columnSelectorText","toggleColumnVisibility","columnSelectorHiddenText","columnSelectorVisibleText","hideColumnText","showClearSettingsOption","clearSettingsOptionText","columnWidth","allowSorting","showOrderByOption","showOrderByOptionTextAsc","showOrderByOptionTextDesc","createDiposeEvent","contextPosition","contextMenuMarginLeft","contextMenuMarginTop","mobileContextMenuMargin","ele","boundingRect","eleRect","clipRect","parentRect","Infinity","scrollingElement","borderWidth","mobileEditInputHeight","cellPaddingLeft","ignoreScrollOffset","abort","abortEdit","newValue","oldValue","aborted","editable","enumItems","enu","option","valueInEnum","multiLine","editCellZIndex","fontSize","editCellFontSize","nx","ny","className","css","verticalAlign","marginLeft","padding","border","contextFilterInputBorder","borderRadius","contextFilterInputBorderRadius","fontWeight","fontFamily","contextFilterInputFontFamily","contextFilterInputFontSize","contextMenuBackground","contextMenuColor","contextFilterButtonBorder","contextFilterButtonBorderRadius","contextMenuFilterButtonFontFamily","contextMenuFilterButtonFontSize","cssFloat","childContextMenuArrowColor","contextMenuChildArrowFontSize","contextMenuFontFamily","contextMenuFontSize","contextMenuBorder","contextMenuPadding","contextMenuBorderRadius","opacity","contextMenuOpacity","overflow","contextMenuHoverBackground","contextMenuHoverColor","display","boxSizing","outline","margin","mobileEditFontFamily","mobileEditFontSize","editCellBorder","editCellColor","editCellBackgroundColor","appearance","webkitAppearance","mozAppearance","editCellPaddingLeft","editCellFontFamily","boxShadow","editCellBoxShadow","contextMenuItemMargin","contextMenuItemBorderRadius","contextMenuLabelMargin","contextMenuLabelDisplay","contextMenuLabelMinWidth","maxWidth","contextMenuLabelMaxWidth","contextMenuCursor","contextMenuFilterInvalidExpresion","onblur","parentIsCanvas","getContext","textBaseline","ordA","charCodeAt","ordZ","len","fromCharCode","offsetY","targetX","targetY","sbh","isColumnSelected","colIsSelected","shift","supressEvent","addCol","de","ri","st","dragObject","childGrid","trArgs","treeGridHeight","dontSetStorageData","sorter","xi","maxRowLength","minXi","lastSourceIndex","cidx","useTouchScrollZones","moveBorder","entitiy","tsz","touchScrollZone","moveMode","borderDragBehavior","xBorderBehavior","yBorderBehavior","isVerticalScrollBar","isHorizontalScrollBar","borderResizeZone","allowColumnResize","allowColumnResizeFromCell","allowRowHeaderResize","allowRowResize","allowRowResizeFromCell","rowGrabZoneSize","maxCol","minCol","rowHeaderCellFont","autosizePadding","autosizeHeaderCellPadding","rowHeaderCellPaddingRight","rowHeaderCellPaddingLeft","columnHeaderCellFont","headerCellPaddingRight","headerCellPaddingLeft","cellFont","cellPaddingRight","cellAutoResizePadding","total","getRowHeight","headerCell","int","asc","localeCompare","date","Date","getTime"],"mappings":"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","file":"canvas-datagrid.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"canvasDatagrid\"] = factory();\n\telse\n\t\troot[\"canvasDatagrid\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6c2621dd6439cddb047d","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"canvasDatagrid\"] = factory();\n\telse\n\t\troot[\"canvasDatagrid\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n    'use strict';\r\n    return function (self) {\r\n        self.defaults = {\r\n            attributes: [\r\n                ['allowColumnReordering', true],\r\n                ['allowColumnResize', true],\r\n                ['allowColumnResizeFromCell', false],\r\n                ['allowFreezingRows', false],\r\n                ['allowFreezingColumns', false],\r\n                ['allowMovingSelection', true],\r\n                ['allowRowHeaderResize', true],\r\n                ['allowRowReordering', false],\r\n                ['allowRowResize', true],\r\n                ['allowRowResizeFromCell', false],\r\n                ['allowSorting', true],\r\n                ['autoGenerateSchema', false],\r\n                ['autoResizeColumns', false],\r\n                ['borderDragBehavior', 'none'],\r\n                ['borderResizeZone', 10],\r\n                ['clearSettingsOptionText', 'Clear saved settings'],\r\n                ['columnHeaderClickBehavior', 'sort'],\r\n                ['columnSelectorHiddenText', '&nbsp;&nbsp;&nbsp;'],\r\n                ['columnSelectorText', 'Add/Remove columns'],\r\n                ['columnSelectorVisibleText', '\\u2713'],\r\n                ['contextHoverScrollAmount', 2],\r\n                ['contextHoverScrollRateMs', 5],\r\n                ['copyHeadersOnSelectAll', true],\r\n                ['copyText', 'Copy'],\r\n                ['debug', false],\r\n                ['editable', true],\r\n                ['ellipsisText', '...'],\r\n                ['filterOptionText', 'Filter %s'],\r\n                ['filterTextPrefix', '(filtered) '],\r\n                ['globalRowResize', false],\r\n                ['hideColumnText', 'Hide %s'],\r\n                ['maxAutoCompleteItems', 200],\r\n                ['multiLine', false],\r\n                ['name', ''],\r\n                ['pageUpDownOverlap', 1],\r\n                ['pasteText', 'Paste'],\r\n                ['persistantSelectionMode', false],\r\n                ['removeFilterOptionText', 'Remove filter on %s'],\r\n                ['reorderDeadZone', 3],\r\n                ['resizeScrollZone', 20],\r\n                ['rowGrabZoneSize', 5],\r\n                ['saveAppearance', true],\r\n                ['scrollAnimationPPSThreshold', 0.75],\r\n                ['scrollPointerLock', false],\r\n                ['scrollRepeatRate', 75],\r\n                ['selectionFollowsActiveCell', false],\r\n                ['selectionHandleBehavior', 'none'],\r\n                ['selectionMode', 'cell'],\r\n                ['selectionScrollIncrement', 20],\r\n                ['selectionScrollZone', 20],\r\n                ['showClearSettingsOption', true],\r\n                ['showColumnHeaders', true],\r\n                ['showColumnSelector', true],\r\n                ['showCopy', false],\r\n                ['showFilter', true],\r\n                ['showNewRow', false],\r\n                ['showOrderByOption', true],\r\n                ['showOrderByOptionTextAsc', 'Order by %s ascending'],\r\n                ['showOrderByOptionTextDesc', 'Order by %s descending'],\r\n                ['showPaste', false],\r\n                ['showPerformance', false],\r\n                ['showRowHeaders', true],\r\n                ['showRowNumbers', true],\r\n                ['snapToRow', false],\r\n                ['touchContextMenuTimeMs', 800],\r\n                ['touchDeadZone', 3],\r\n                ['touchEasingMethod', 'easeOutQuad'],\r\n                ['touchReleaseAcceleration', 1000],\r\n                ['touchReleaseAnimationDurationMs', 2000],\r\n                ['touchScrollZone', 20],\r\n                ['touchSelectHandleZone', 20],\r\n                ['touchZoomSensitivity', 0.005],\r\n                ['touchZoomMin', 0.5],\r\n                ['touchZoomMax', 1.75],\r\n                ['maxPixelRatio', 2],\r\n                ['tree', false],\r\n                ['treeHorizontalScroll', false]\r\n            ],\r\n            styles: [\r\n                ['activeCellBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n                ['activeCellBorderColor', 'rgba(110, 168, 255, 1)'],\r\n                ['activeCellBorderWidth', 1],\r\n                ['activeCellColor', 'rgba(0, 0, 0, 1)'],\r\n                ['activeCellFont', '16px sans-serif'],\r\n                ['activeCellHoverBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n                ['activeCellHorizontalAlignment', 'left'],\r\n                ['activeCellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n                ['activeCellOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\r\n                ['activeCellOverlayBorderWidth', 1],\r\n                ['activeCellPaddingBottom', 5],\r\n                ['activeCellPaddingLeft', 5],\r\n                ['activeCellPaddingRight', 5],\r\n                ['activeCellPaddingTop', 5],\r\n                ['activeCellSelectedBackgroundColor', 'rgba(236, 243, 255, 1)'],\r\n                ['activeCellSelectedColor', 'rgba(0, 0, 0, 1)'],\r\n                ['activeCellVerticalAlignment', 'center'],\r\n                ['activeColumnHeaderCellBackgroundColor', 'rgba(225, 225, 225, 1)'],\r\n                ['activeColumnHeaderCellColor', 'rgba(0, 0, 0, 1)'],\r\n                ['activeRowHeaderCellBackgroundColor', 'rgba(225, 225, 225, 1)'],\r\n                ['activeRowHeaderCellColor', 'rgba(0, 0, 0, 1)'],\r\n                ['autocompleteBottomMargin', 60],\r\n                ['autosizeHeaderCellPadding', 8],\r\n                ['autosizePadding', 5],\r\n                ['cellAutoResizePadding', 13],\r\n                ['cellBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n                ['cellBorderColor', 'rgba(195, 199, 202, 1)'],\r\n                ['cellBorderWidth', 1],\r\n                ['cellColor', 'rgba(0, 0, 0, 1)'],\r\n                ['cellFont', '16px sans-serif'],\r\n                ['cellGridHeight', 250],\r\n                ['cellHeight', 24],\r\n                ['cellHeightWithChildGrid', 150],\r\n                ['cellHorizontalAlignment', 'left'],\r\n                ['cellHoverBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n                ['cellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n                ['cellPaddingBottom', 5],\r\n                ['cellPaddingLeft', 5],\r\n                ['cellPaddingRight', 5],\r\n                ['cellPaddingTop', 5],\r\n                ['cellSelectedBackgroundColor', 'rgba(236, 243, 255, 1)'],\r\n                ['cellSelectedColor', 'rgba(0, 0, 0, 1)'],\r\n                ['cellVerticalAlignment', 'center'],\r\n                ['cellWidth', 250],\r\n                ['cellWidthWithChildGrid', 250],\r\n                ['cellWhiteSpace', 'nowrap'],\r\n                ['cellLineHeight', 1],\r\n                ['cellLineSpacing', 3],\r\n                ['childContextMenuArrowColor', 'rgba(43, 48, 43, 1)'],\r\n                ['childContextMenuArrowHTML', '&#x25BA;'],\r\n                ['childContextMenuMarginLeft', -11],\r\n                ['childContextMenuMarginTop', -6],\r\n                ['columnHeaderCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['columnHeaderCellBorderColor', 'rgba(172, 172, 172, 1)'],\r\n                ['columnHeaderCellBorderWidth', 1],\r\n                ['columnHeaderCellCapBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['columnHeaderCellCapBorderColor', 'rgba(172, 172, 172, 1)'],\r\n                ['columnHeaderCellCapBorderWidth', 1],\r\n                ['columnHeaderCellColor', 'rgba(50, 50, 50, 1)'],\r\n                ['columnHeaderCellFont', '16px sans-serif'],\r\n                ['columnHeaderCellHeight', 25],\r\n                ['columnHeaderCellHorizontalAlignment', 'left'],\r\n                ['columnHeaderCellHoverBackgroundColor', 'rgba(235, 235, 235, 1)'],\r\n                ['columnHeaderCellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n                ['columnHeaderCellPaddingBottom', 5],\r\n                ['columnHeaderCellPaddingLeft', 5],\r\n                ['columnHeaderCellPaddingRight', 5],\r\n                ['columnHeaderCellPaddingTop', 5],\r\n                ['columnHeaderCellVerticalAlignment', 'center'],\r\n                ['columnHeaderOrderByArrowBorderColor', 'rgba(195, 199, 202, 1)'],\r\n                ['columnHeaderOrderByArrowBorderWidth', 1],\r\n                ['columnHeaderOrderByArrowColor', 'rgba(155, 155, 155, 1)'],\r\n                ['columnHeaderOrderByArrowHeight', 8],\r\n                ['columnHeaderOrderByArrowMarginLeft', 0],\r\n                ['columnHeaderOrderByArrowMarginRight', 5],\r\n                ['columnHeaderOrderByArrowMarginTop', 6],\r\n                ['columnHeaderOrderByArrowWidth', 13],\r\n                ['contextFilterButtonBorder', 'solid 1px rgba(158, 163, 169, 1)'],\r\n                ['contextFilterButtonBorderRadius', '3px'],\r\n                ['contextFilterButtonHTML', '&#x25BC;'],\r\n                ['contextFilterInputBackground', 'rgba(255,255,255,1)'],\r\n                ['contextFilterInputBorder', 'solid 1px rgba(158, 163, 169, 1)'],\r\n                ['contextFilterInputBorderRadius', '0'],\r\n                ['contextFilterInputColor', 'rgba(0,0,0,1)'],\r\n                ['contextFilterInputFontFamily', 'sans-serif'],\r\n                ['contextFilterInputFontSize', '14px'],\r\n                ['contextFilterInvalidRegExpBackground', 'rgba(180, 6, 1, 1)'],\r\n                ['contextFilterInvalidRegExpColor', 'rgba(255, 255, 255, 1)'],\r\n                ['contextMenuArrowColor', 'rgba(43, 48, 43, 1)'],\r\n                ['contextMenuArrowDownHTML', '&#x25BC;'],\r\n                ['contextMenuArrowUpHTML', '&#x25B2;'],\r\n                ['contextMenuBackground', 'rgba(240, 240, 240, 1)'],\r\n                ['contextMenuBorder', 'solid 1px rgba(158, 163, 169, 1)'],\r\n                ['contextMenuBorderRadius', '3px'],\r\n                ['contextMenuChildArrowFontSize', '12px'],\r\n                ['contextMenuColor', 'rgba(43, 48, 43, 1)'],\r\n                ['contextMenuCursor', 'default'],\r\n                ['contextMenuFilterButtonFontFamily', 'sans-serif'],\r\n                ['contextMenuFilterButtonFontSize', '10px'],\r\n                ['contextMenuFilterInvalidExpresion', 'rgba(237, 155, 156, 1)'],\r\n                ['contextMenuFontFamily', 'sans-serif'],\r\n                ['contextMenuFontSize', '16px'],\r\n                ['contextMenuHoverBackground', 'rgba(182, 205, 250, 1)'],\r\n                ['contextMenuHoverColor', 'rgba(43, 48, 153, 1)'],\r\n                ['contextMenuItemBorderRadius', '3px'],\r\n                ['contextMenuItemMargin', '2px'],\r\n                ['contextMenuLabelDisplay', 'inline-block'],\r\n                ['contextMenuLabelMargin', '0 3px 0 0'],\r\n                ['contextMenuLabelMaxWidth', '700px'],\r\n                ['contextMenuLabelMinWidth', '75px'],\r\n                ['contextMenuMarginLeft', 3],\r\n                ['contextMenuMarginTop', -3],\r\n                ['contextMenuOpacity', '0.98'],\r\n                ['contextMenuPadding', '2px'],\r\n                ['contextMenuWindowMargin', 30],\r\n                ['contextMenuZIndex', 10000],\r\n                ['cornerCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['cornerCellBorderColor', 'rgba(202, 202, 202, 1)'],\r\n                ['debugBackgroundColor', 'rgba(0, 0, 0, .0)'],\r\n                ['debugColor', 'rgba(255, 15, 24, 1)'],\r\n                ['debugEntitiesColor', 'rgba(76, 231, 239, 1.00)'],\r\n                ['debugFont', '11px sans-serif'],\r\n                ['debugPerfChartBackground', 'rgba(29, 25, 26, 1.00)'],\r\n                ['debugPerfChartTextColor', 'rgba(255, 255, 255, 0.8)'],\r\n                ['debugPerformanceColor', 'rgba(252, 255, 37, 1.00)'],\r\n                ['debugScrollHeightColor', 'rgba(248, 33, 103, 1.00)'],\r\n                ['debugScrollWidthColor', 'rgba(66, 255, 27, 1.00)'],\r\n                ['debugTouchPPSXColor', 'rgba(246, 102, 24, 1.00)'],\r\n                ['debugTouchPPSYColor', 'rgba(186, 0, 255, 1.00)'],\r\n                ['display', 'inline-block'],\r\n                ['editCellBackgroundColor', 'white'],\r\n                ['editCellBorder', 'solid 1px rgba(110, 168, 255, 1)'],\r\n                ['editCellBoxShadow', '0 2px 5px rgba(0,0,0,0.4)'],\r\n                ['editCellColor', 'black'],\r\n                ['editCellFontFamily', 'sans-serif'],\r\n                ['editCellFontSize', '16px'],\r\n                ['editCellPaddingLeft', 4],\r\n                ['editCellZIndex', 10000],\r\n                ['frozenMarkerHoverColor', 'rgba(236, 243, 255, 1)'],\r\n                ['frozenMarkerHoverBorderColor', 'rgba(110, 168, 255, 1)'],\r\n                ['frozenMarkerActiveColor', 'rgba(236, 243, 255, 1)'],\r\n                ['frozenMarkerActiveBorderColor', 'rgba(110, 168, 255, 1)'],\r\n                ['frozenMarkerColor', 'rgba(222, 222, 222, 1)'],\r\n                ['frozenMarkerBorderColor', 'rgba(168, 168, 168, 1)'],\r\n                ['frozenMarkerBorderWidth', 1],\r\n                ['frozenMarkerWidth', 2],\r\n                ['gridBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['gridBorderCollapse', 'collapse'],\r\n                ['gridBorderColor', 'rgba(202, 202, 202, 1)'],\r\n                ['gridBorderWidth', 1],\r\n                ['height', 'auto'],\r\n                ['maxHeight', 'inherit'],\r\n                ['maxWidth', 'inherit'],\r\n                ['minColumnWidth', 45],\r\n                ['minHeight', 'inherit'],\r\n                ['minRowHeight', 24],\r\n                ['minWidth', 'inherit'],\r\n                ['mobileContextMenuMargin', 10],\r\n                ['mobileEditInputHeight', 30],\r\n                ['mobileEditFontFamily', 'sans-serif'],\r\n                ['mobileEditFontSize', '16px'],\r\n                ['moveOverlayBorderWidth', 1],\r\n                ['moveOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\r\n                ['moveOverlayBorderSegments', '12, 7'],\r\n                ['name', 'default'],\r\n                ['overflowY', 'auto'],\r\n                ['overflowX', 'auto'],\r\n                ['reorderMarkerBackgroundColor', 'rgba(0, 0, 0, 0.1)'],\r\n                ['reorderMarkerBorderColor', 'rgba(0, 0, 0, 0.2)'],\r\n                ['reorderMarkerBorderWidth', 1.25],\r\n                ['reorderMarkerIndexBorderColor', 'rgba(66, 133, 244, 1)'],\r\n                ['reorderMarkerIndexBorderWidth', 2.75],\r\n                ['rowHeaderCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['rowHeaderCellBorderColor', 'rgba(200, 200, 200, 1)'],\r\n                ['rowHeaderCellBorderWidth', 1],\r\n                ['rowHeaderCellColor', 'rgba(50, 50, 50, 1)'],\r\n                ['rowHeaderCellFont', '16px sans-serif'],\r\n                ['rowHeaderCellHeight', 25],\r\n                ['rowHeaderCellHorizontalAlignment', 'left'],\r\n                ['rowHeaderCellHoverBackgroundColor', 'rgba(235, 235, 235, 1)'],\r\n                ['rowHeaderCellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n                ['rowHeaderCellPaddingBottom', 5],\r\n                ['rowHeaderCellPaddingLeft', 5],\r\n                ['rowHeaderCellPaddingRight', 5],\r\n                ['rowHeaderCellPaddingTop', 5],\r\n                ['rowHeaderCellSelectedBackgroundColor', 'rgba(217, 217, 217, 1)'],\r\n                ['rowHeaderCellSelectedColor', 'rgba(50, 50, 50, 1)'],\r\n                ['rowHeaderCellVerticalAlignment', 'center'],\r\n                ['rowHeaderCellWidth', 57],\r\n                ['scrollBarActiveColor', 'rgba(125, 125, 125, 1)'],\r\n                ['scrollBarBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['scrollBarBorderColor', 'rgba(202, 202, 202, 1)'],\r\n                ['scrollBarBorderWidth', 0.5],\r\n                ['scrollBarBoxBorderRadius', 4.125],\r\n                ['scrollBarBoxColor', 'rgba(192, 192, 192, 1)'],\r\n                ['scrollBarBoxMargin', 2],\r\n                ['scrollBarBoxMinSize', 15],\r\n                ['scrollBarBoxWidth', 8],\r\n                ['scrollBarCornerBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['scrollBarCornerBorderColor', 'rgba(202, 202, 202, 1)'],\r\n                ['scrollBarWidth', 11],\r\n                ['selectionHandleBorderColor', 'rgba(255, 255, 255, 1)'],\r\n                ['selectionHandleBorderWidth', 1.5],\r\n                ['selectionHandleColor', 'rgba(66, 133, 244, 1)'],\r\n                ['selectionHandleSize', 8],\r\n                ['selectionHandleType', 'square'],\r\n                ['selectionOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\r\n                ['selectionOverlayBorderWidth', 1],\r\n                ['treeArrowBorderColor', 'rgba(195, 199, 202, 1)'],\r\n                ['treeArrowBorderWidth', 1],\r\n                ['treeArrowClickRadius', 5],\r\n                ['treeArrowColor', 'rgba(155, 155, 155, 1)'],\r\n                ['treeArrowHeight', 8],\r\n                ['treeArrowMarginLeft', 0],\r\n                ['treeArrowMarginRight', 5],\r\n                ['treeArrowMarginTop', 6],\r\n                ['treeArrowWidth', 13],\r\n                ['treeGridHeight', 250],\r\n                ['width', 'auto']\r\n            ]\r\n        };\r\n    };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true, evil: true*/\r\n/*globals Reflect: false, HTMLElement: true, define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n    __webpack_require__(2),\r\n    __webpack_require__(0),\r\n    __webpack_require__(3),\r\n    __webpack_require__(4),\r\n    __webpack_require__(5),\r\n    __webpack_require__(6),\r\n    __webpack_require__(7),\r\n    __webpack_require__(8),\r\n    __webpack_require__(9)\r\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function context(component) {\r\n    'use strict';\r\n    component = component();\r\n    var modules = Array.prototype.slice.call(arguments);\r\n    function Grid(args) {\r\n        args = args || {};\r\n        var self = {};\r\n        self.isComponent = args.component === undefined;\r\n        self.isChildGrid = args.parentNode && /canvas-datagrid-(cell|tree)/.test(args.parentNode.nodeType);\r\n        if (self.isChildGrid) {\r\n            self.intf = {};\r\n        } else {\r\n            self.intf = self.isComponent ? eval('Reflect.construct(HTMLElement, [], new.target)')\r\n                : document.createElement('canvas');\r\n        }\r\n        self.args = args;\r\n        self.intf.args = args;\r\n        self.applyComponentStyle = component.applyComponentStyle;\r\n        self.hyphenateProperty = component.hyphenateProperty;\r\n        self.dehyphenateProperty = component.dehyphenateProperty;\r\n        self.createGrid = function grid(args) {\r\n            args.component = false;\r\n            return new Grid(args);\r\n        };\r\n        modules.forEach(function (module) {\r\n            module(self);\r\n        });\r\n        if (self.isChildGrid) {\r\n            self.shadowRoot = args.parentNode.shadowRoot;\r\n            self.parentNode = args.parentNode;\r\n        } else if (self.intf.createShadowRoot) {\r\n            self.shadowRoot = self.intf.attachShadow({mode: 'open'});\r\n            self.parentNode = self.shadowRoot;\r\n        } else {\r\n            self.parentNode = self.intf;\r\n        }\r\n        self.init();\r\n        return self.intf;\r\n    }\r\n    if (window.HTMLElement) {\r\n        Grid.prototype = Object.create(window.HTMLElement.prototype);\r\n    }\r\n    // export web component\r\n    if (window.customElements) {\r\n        Grid.observedAttributes = component.getObservableAttributes();\r\n        Grid.prototype.disconnectedCallback = component.disconnectedCallback;\r\n        Grid.prototype.attributeChangedCallback = component.attributeChangedCallback;\r\n        Grid.prototype.connectedCallback = component.connectedCallback;\r\n        Grid.prototype.adoptedCallback = component.adoptedCallback;\r\n        window.customElements.define('canvas-datagrid', Grid);\r\n    }\r\n    // export global\r\n    if (window && !window.canvasDatagrid && !window.require) {\r\n        window.canvasDatagrid = function (args) { return new Grid(args); };\r\n    }\r\n    // export amd loader\r\n    module.exports = function grid(args) {\r\n        args = args || {};\r\n        var i, tKeys = ['style', 'formatters', 'sorters', 'filters',\r\n                    'treeGridAttributes', 'cellGridAttributes', 'data', 'schema'];\r\n        if (window.customElements && document.body.createShadowRoot) {\r\n            i = document.createElement('canvas-datagrid');\r\n            Object.keys(args).forEach(function (argKey) {\r\n                // set data and parentNode after everything else\r\n                if (argKey === 'data') { return; }\r\n                if (argKey === 'parentNode') { return; }\r\n                // top level keys in args\r\n                if (tKeys.indexOf(argKey) !== -1) {\r\n                    tKeys.forEach(function (tKey) {\r\n                        if (args[tKey] === undefined || tKey !== argKey) { return; }\r\n                        if (['formatters', 'sorters', 'filters'].indexOf(argKey) !== -1) {\r\n                            if (typeof args[tKey] === 'object' && args[tKey] !== null) {\r\n                                Object.keys(args[tKey]).forEach(function (sKey) {\r\n                                    i[tKey][sKey] = args[tKey][sKey];\r\n                                });\r\n                            }\r\n                        } else {\r\n                            i[tKey] = args[tKey];\r\n                        }\r\n                    });\r\n                    return;\r\n                }\r\n                // all others are attribute level keys\r\n                i.attributes[argKey] = args[argKey];\r\n            });\r\n            if (args.data) {\r\n                i.data = args.data;\r\n            }\r\n            // add to the dom very last to avoid redraws\r\n            if (args.parentNode) {\r\n                args.parentNode.appendChild(i);\r\n            }\r\n            return i;\r\n        }\r\n        args.component = false;\r\n        i = new Grid(args);\r\n        if (args.parentNode && args.parentNode.appendChild) {\r\n            args.parentNode.appendChild(i);\r\n        }\r\n        return i;\r\n    };\r\n    return module.exports;\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (defaults) {\r\n    'use strict';\r\n    return function () {\r\n        var typeMap, component = {};\r\n        component.dehyphenateProperty = function hyphenateProperty(prop) {\r\n            prop = prop.replace('--cdg-', '');\r\n            var p = '', nextLetterCap;\r\n            Array.prototype.forEach.call(prop, function (char) {\r\n                if (nextLetterCap) {\r\n                    nextLetterCap = false;\r\n                    p += char.toUpperCase();\r\n                    return;\r\n                }\r\n                if (char === '-') {\r\n                    nextLetterCap = true;\r\n                    return;\r\n                }\r\n                p += char;\r\n            });\r\n            return p;\r\n        };\r\n        component.hyphenateProperty = function hyphenateProperty(prop, cust) {\r\n            var p = '';\r\n            Array.prototype.forEach.call(prop, function (char) {\r\n                if (char === char.toUpperCase()) {\r\n                    p += '-' + char.toLowerCase();\r\n                    return;\r\n                }\r\n                p += char;\r\n            });\r\n            return (cust ? '--cdg-' : '') + p;\r\n        };\r\n        function getDefaultItem(base, item) {\r\n            var i = {},\r\n                r;\r\n            defaults(i);\r\n            r = i.defaults[base].filter(function (i) {\r\n                return i[0].toLowerCase() === item.toLowerCase()\r\n                    || component.hyphenateProperty(i[0]) === item.toLowerCase()\r\n                    || component.hyphenateProperty(i[0], true) === item.toLowerCase();\r\n            })[0];\r\n            return r;\r\n        }\r\n        component.applyComponentStyle = function (supressChangeAndDrawEvents, intf) {\r\n            if (!intf.isComponent) { return; }\r\n            var cStyle = window.getComputedStyle(intf.tagName === 'CANVAS-DATAGRID' ? intf : intf.canvas, null),\r\n                defs = {};\r\n            intf.computedStyle = cStyle;\r\n            defaults(defs);\r\n            defs = defs.defaults.styles;\r\n            defs.forEach(function (def) {\r\n                var val;\r\n                val = cStyle.getPropertyValue(component.hyphenateProperty(def[0], true));\r\n                if (val === \"\") {\r\n                    val = cStyle.getPropertyValue(component.hyphenateProperty(def[0], false));\r\n                }\r\n                if (val !== \"\" && typeof val === 'string') {\r\n                    intf.setStyleProperty(def[0], typeMap[typeof def[1]](val\r\n                        .replace(/^\\s+/, '').replace(/\\s+$/, ''), def[1]), true);\r\n                }\r\n            });\r\n            if (!supressChangeAndDrawEvents && intf.dispatchEvent) {\r\n                requestAnimationFrame(function () { intf.resize(true); });\r\n                intf.dispatchEvent('stylechanged', intf.style);\r\n            }\r\n        };\r\n        typeMap = {\r\n            data: function (strData) {\r\n                try {\r\n                    return JSON.parse(strData);\r\n                } catch (e) {\r\n                    throw new Error('Cannot read JSON data in canvas-datagrid data.');\r\n                }\r\n            },\r\n            schema: function (strSchema) {\r\n                try {\r\n                    return JSON.parse(strSchema);\r\n                } catch (e) {\r\n                    throw new Error('Cannot read JSON data in canvas-datagrid schema attribute.');\r\n                }\r\n            },\r\n            number: function (strNum, def) {\r\n                var n = parseInt(strNum, 10);\r\n                return isNaN(n) ? def : n;\r\n            },\r\n            boolean: function (strBool) {\r\n                return (/true/i).test(strBool);\r\n            },\r\n            string: function (str) {\r\n                return str;\r\n            }\r\n        };\r\n        component.getObservableAttributes = function () {\r\n            var i = {}, attrs = ['data', 'schema', 'style', 'className', 'name'];\r\n            defaults(i);\r\n            i.defaults.attributes.forEach(function (attr) {\r\n                attrs.push(attr[0].toLowerCase());\r\n            });\r\n            return attrs;\r\n        };\r\n        component.disconnectedCallback = function () {\r\n            this.connected = false;\r\n        };\r\n        component.connectedCallback = function () {\r\n            var intf = this;\r\n            intf.parentDOMNode.innerHTML = \"\";\r\n            intf.parentDOMNode.appendChild(intf.canvas);\r\n            intf.connected = true;\r\n            component.observe(intf);\r\n            component.applyComponentStyle(true, intf);\r\n            intf.resize(true);\r\n        };\r\n        component.adoptedCallback = function () {\r\n            this.resize();\r\n        };\r\n        component.attributeChangedCallback = function (attrName, oldVal, newVal) {\r\n            var tfn, intf = this, def;\r\n            if (attrName === 'style') {\r\n                component.applyComponentStyle(false, intf);\r\n                return;\r\n            }\r\n            if (attrName === 'data') {\r\n                if (intf.dataType === 'application/x-canvas-datagrid') {\r\n                    intf.dataType = 'application/json+x-canvas-datagrid';\r\n                }\r\n                intf.args.data = newVal;\r\n                return;\r\n            }\r\n            if (attrName === 'schema') {\r\n                intf.args.schema = typeMap.schema(newVal);\r\n                return;\r\n            }\r\n            if (attrName === 'name') {\r\n                intf.name = newVal;\r\n                return;\r\n            }\r\n            if (attrName === 'class' || attrName === 'className') {\r\n                return;\r\n            }\r\n            def = getDefaultItem('attributes', attrName);\r\n            if (def) {\r\n                tfn = typeMap[typeof def[1]];\r\n                intf.attributes[def[0]] = tfn(newVal);\r\n                return;\r\n            }\r\n            if (/^on/.test(attrName)) {\r\n                intf.addEventListener('on' + attrName, function (e) {\r\n                    eval(newVal);\r\n                });\r\n            }\r\n            return;\r\n        };\r\n        component.observe = function (intf) {\r\n            var observer;\r\n            if (!window.MutationObserver) { return; }\r\n            intf.applyComponentStyle = function () { component.applyComponentStyle(false, intf); intf.resize(); };\r\n            /**\r\n             * Applies the computed css styles to the grid.  In some browsers, changing directives in attached style sheets does not automatically update the styles in this component.  It is necessary to call this method to update in these cases.\r\n             * @memberof canvasDatagrid\r\n             * @name applyComponentStyle\r\n             * @method\r\n             */\r\n            observer = new window.MutationObserver(function (mutations) {\r\n                var checkInnerHTML, checkStyle;\r\n                Array.prototype.forEach.call(mutations, function (mutation) {\r\n                    if (mutation.attributeName === 'class'\r\n                            || mutation.attributeName === 'style') {\r\n                        checkStyle = true;\r\n                        return;\r\n                    }\r\n                    if (mutation.target.nodeName === 'STYLE') {\r\n                        checkStyle = true;\r\n                        return;\r\n                    }\r\n                    if (mutation.target.parentNode\r\n                            && mutation.target.parentNode.nodeName === 'STYLE') {\r\n                        checkStyle = true;\r\n                        return;\r\n                    }\r\n                    if (mutation.target === intf && (mutation.addedNodes.length > 0 || mutation.type === 'characterData')) {\r\n                        checkInnerHTML = true;\r\n                    }\r\n                });\r\n                if (checkStyle) {\r\n                    intf.applyComponentStyle(false, intf);\r\n                }\r\n                if (checkInnerHTML) {\r\n                    if (intf.dataType === 'application/x-canvas-datagrid') {\r\n                        intf.dataType = 'application/json+x-canvas-datagrid';\r\n                    }\r\n                    intf.data = intf.innerHTML;\r\n                }\r\n            });\r\n            observer.observe(intf, { characterData: true, childList: true, attributes: true, subtree: true });\r\n            Array.prototype.forEach.call(document.querySelectorAll('style'), function (el) {\r\n                observer.observe(el, { characterData: true, childList: true, attributes: true, subtree: true });\r\n            });\r\n        };\r\n        return component;\r\n    };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals XMLSerializer: false, define: true, Blob: false, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n    'use strict';\r\n    return function (self) {\r\n        var perfCounters = [],\r\n            cachedImagesDrawn = false,\r\n            drawCount = 0,\r\n            perfWindowSize = 300,\r\n            entityCount = [],\r\n            hiddenFrozenColumnCount = 0,\r\n            scrollDebugCounters = [],\r\n            touchPPSCounters = [];\r\n        self.htmlImageCache = {};\r\n        // more heavyweight version than fillArray defined in intf.js\r\n        function fillArray(low, high, step, def) {\r\n            step = step || 1;\r\n            var i = [], x;\r\n            for (x = low; x <= high; x += step) {\r\n                i[x] = def === undefined ? x : (typeof def === 'function' ? def(x) : def);\r\n            }\r\n            return i;\r\n        }\r\n        function drawPerfLine(w, h, x, y, perfArr, arrIndex, max, color, useAbs) {\r\n            var i = w / perfArr.length,\r\n                r = h / max;\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.beginPath();\r\n            self.ctx.moveTo(x, y + h);\r\n            perfArr.forEach(function (n) {\r\n                var val = (arrIndex === undefined ? n : n[arrIndex]),\r\n                    cx,\r\n                    cy;\r\n                if (useAbs) {\r\n                    val = Math.abs(val);\r\n                }\r\n                cx = x + i;\r\n                cy = y + h - (val * r);\r\n                self.ctx.lineTo(cx, cy);\r\n                x += i;\r\n            });\r\n            self.ctx.moveTo(x + w, y + h);\r\n            self.ctx.strokeStyle = color;\r\n            self.ctx.stroke();\r\n        }\r\n        function drawOnAllImagesLoaded() {\r\n            var loaded = true;\r\n            Object.keys(self.htmlImageCache).forEach(function (html) {\r\n                if (!self.htmlImageCache[html].complete) {\r\n                    loaded = false;\r\n                }\r\n            });\r\n            if (loaded && !cachedImagesDrawn) {\r\n                cachedImagesDrawn = true;\r\n                self.draw();\r\n            }\r\n        }\r\n        function drawHtml(cell) {\r\n            var img,\r\n                v = cell.innerHTML || cell.formattedValue,\r\n                cacheKey = v.toString() + cell.rowIndex.toString() + cell.columnIndex.toString(), \r\n                x = cell.x + self.canvasOffsetLeft,\r\n                y = cell.y + self.canvasOffsetTop;\r\n            if (self.htmlImageCache[cacheKey]) {\r\n                img = self.htmlImageCache[cacheKey];\r\n                if (img.height !== cell.height || img.width !== cell.width) {\r\n                    // height and width of the cell has changed, invalidate cache\r\n                    self.htmlImageCache[cacheKey] = undefined;\r\n                } else {\r\n                    if (!img.complete) {\r\n                        return;\r\n                    }\r\n                    return self.ctx.drawImage(img, x, y);\r\n                }\r\n            } else {\r\n                cachedImagesDrawn = false;\r\n            }\r\n            img = new Image(cell.width, cell.height);\r\n            self.htmlImageCache[cacheKey] = img;\r\n            img.onload = function () {\r\n                self.ctx.drawImage(img, x, y);\r\n                drawOnAllImagesLoaded();\r\n            };\r\n            img.src = 'data:image/svg+xml;base64,' + btoa(\r\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' + cell.width + '\" height=\"' + cell.height + '\">\\n' +\r\n                    '<foreignObject class=\"node\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">\\n' +\r\n                    '<body xmlns=\"http://www.w3.org/1999/xhtml\" style=\"margin:0;padding:0;\">\\n' +\r\n                    v + '\\n' +\r\n                    '</body>' +\r\n                    '</foreignObject>\\n' +\r\n                    '</svg>\\n'\r\n            );\r\n        }\r\n        function drawOrderByArrow(x, y) {\r\n            var mt = self.style.columnHeaderOrderByArrowMarginTop * self.scale,\r\n                ml = self.style.columnHeaderOrderByArrowMarginLeft * self.scale,\r\n                mr = self.style.columnHeaderOrderByArrowMarginRight * self.scale,\r\n                aw = self.style.columnHeaderOrderByArrowWidth * self.scale,\r\n                ah = self.style.columnHeaderOrderByArrowHeight * self.scale;\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.fillStyle = self.style.columnHeaderOrderByArrowColor;\r\n            self.ctx.strokeStyle = self.style.columnHeaderOrderByArrowBorderColor;\r\n            self.ctx.beginPath();\r\n            x = x + ml;\r\n            y = y + mt;\r\n            if (self.orderDirection === 'asc') {\r\n                self.ctx.moveTo(x, y);\r\n                self.ctx.lineTo(x + aw, y);\r\n                self.ctx.lineTo(x + (aw * 0.5), y + ah);\r\n                self.ctx.moveTo(x, y);\r\n            } else {\r\n                self.ctx.lineTo(x, y + ah);\r\n                self.ctx.lineTo(x + aw, y + ah);\r\n                self.ctx.lineTo(x + (aw * 0.5), y);\r\n                self.ctx.lineTo(x, y + ah);\r\n            }\r\n            self.ctx.stroke();\r\n            self.ctx.fill();\r\n            return ml + aw + mr;\r\n        }\r\n        function drawTreeArrow(cell, x, y) {\r\n            var mt = self.style.treeArrowMarginTop * self.scale,\r\n                mr = self.style.treeArrowMarginRight * self.scale,\r\n                ml = self.style.treeArrowMarginLeft * self.scale,\r\n                aw = self.style.treeArrowWidth * self.scale,\r\n                ah = self.style.treeArrowHeight * self.scale;\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.fillStyle = self.style.treeArrowColor;\r\n            self.ctx.strokeStyle = self.style.treeArrowBorderColor;\r\n            self.ctx.beginPath();\r\n            x = x + ml;\r\n            y = y + mt;\r\n            if (self.openChildren[cell.rowIndex]) {\r\n                self.ctx.moveTo(x, y);\r\n                self.ctx.lineTo(x + aw, y);\r\n                self.ctx.lineTo(x + (aw * 0.5), y + ah);\r\n                self.ctx.moveTo(x, y);\r\n            } else {\r\n                self.ctx.lineTo(x, y);\r\n                self.ctx.lineTo(x + ah, y + (aw * 0.5));\r\n                self.ctx.lineTo(x, y + aw);\r\n                self.ctx.lineTo(x, y);\r\n            }\r\n            self.ctx.stroke();\r\n            self.ctx.fill();\r\n            return ml + aw + mr;\r\n        }\r\n        function radiusRect(x, y, w, h, radius) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            var r = x + w, b = y + h;\r\n            self.ctx.beginPath();\r\n            self.ctx.moveTo(x + radius, y);\r\n            self.ctx.lineTo(r - radius, y);\r\n            self.ctx.quadraticCurveTo(r, y, r, y + radius);\r\n            self.ctx.lineTo(r, y + h - radius);\r\n            self.ctx.quadraticCurveTo(r, b, r - radius, b);\r\n            self.ctx.lineTo(x + radius, b);\r\n            self.ctx.quadraticCurveTo(x, b, x, b - radius);\r\n            self.ctx.lineTo(x, y + radius);\r\n            self.ctx.quadraticCurveTo(x, y, x + radius, y);\r\n        }\r\n        function fillRect(x, y, w, h) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.fillRect(x, y, w, h);\r\n        }\r\n        function strokeRect(x, y, w, h) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.strokeRect(x, y, w, h);\r\n        }\r\n        function fillText(text, x, y) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.fillText(text, x, y);\r\n        }\r\n        function fillCircle(x, y, r) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.beginPath();\r\n            self.ctx.arc(x, y, r, 0, 2 * Math.PI);\r\n            self.ctx.fill();\r\n        }\r\n        function strokeCircle(x, y, r) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.beginPath();\r\n            self.ctx.arc(x, y, r, 0, 2 * Math.PI);\r\n            self.ctx.stroke();\r\n        }\r\n        function clipFrozenArea(mode) {\r\n            // 0 both, 1 rows, 2 cols\r\n            // self.lastFrozenColumnPixel;\r\n            // self.lastFrozenRowPixel;\r\n            self.ctx.beginPath();\r\n            if (mode === 0) {\r\n                self.ctx.moveTo(self.lastFrozenColumnPixel, self.lastFrozenRowPixel);\r\n                self.ctx.lineTo(self.lastFrozenColumnPixel, self.height);\r\n                self.ctx.lineTo(self.width, self.height);\r\n                self.ctx.lineTo(self.width, self.lastFrozenRowPixel);\r\n            }\r\n            if (mode === 1) {\r\n                self.ctx.moveTo(0, self.lastFrozenRowPixel);\r\n                self.ctx.lineTo(0, self.height);\r\n                self.ctx.lineTo(self.width, self.height);\r\n                self.ctx.lineTo(self.width, self.lastFrozenRowPixel);\r\n            }\r\n            if (mode === 2) {\r\n                self.ctx.moveTo(self.lastFrozenColumnPixel, 0);\r\n                self.ctx.lineTo(self.width, 0);\r\n                self.ctx.lineTo(self.width, self.height);\r\n                self.ctx.lineTo(self.lastFrozenColumnPixel, self.height);\r\n            }\r\n            self.ctx.clip();\r\n        }\r\n        function fillHandle(x, y, r) {\r\n            if (self.style.selectionHandleType === 'circle') {\r\n                return fillCircle(x, y, r * 0.5);\r\n            }\r\n            fillRect(x - r * 0.5, y - r * 0.5, r, r);\r\n        }\r\n        function strokeHandle(x, y, r) {\r\n            if (self.style.selectionHandleType === 'circle') {\r\n                return strokeCircle(x, y, r * 0.5);\r\n            }\r\n            strokeRect(x - r * 0.5, y - r * 0.5, r, r);\r\n        }\r\n        function addselectionHandle(c, pos) {\r\n            var hw = self.style.selectionHandleSize,\r\n                p = {\r\n                    tr: function () {\r\n                        fillHandle(c.x + c.width, c.y, hw);\r\n                        strokeHandle(c.x + c.width, c.y, hw);\r\n                    },\r\n                    br: function () {\r\n                        fillHandle(c.x + c.width, c.y + c.height, hw);\r\n                        strokeHandle(c.x + c.width, c.y + c.height, hw);\r\n                    },\r\n                    tl: function () {\r\n                        fillHandle(c.x, c.y, hw);\r\n                        strokeHandle(c.x, c.y, hw);\r\n                    },\r\n                    bl: function () {\r\n                        fillHandle(c.x, c.y + c.height, hw);\r\n                        strokeHandle(c.x, c.y + c.height, hw);\r\n                    }\r\n                };\r\n            p[pos]();\r\n        }\r\n        function addBorderLine(c, pos) {\r\n            self.ctx.beginPath();\r\n            var p = {\r\n                t: function () {\r\n                    self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop);\r\n                    self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop);\r\n                },\r\n                r: function () {\r\n                    self.ctx.moveTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop);\r\n                    self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop + c.height);\r\n                },\r\n                b: function () {\r\n                    self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop + c.height);\r\n                    self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop + c.height);\r\n                },\r\n                l: function () {\r\n                    self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop);\r\n                    self.ctx.lineTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop + c.height);\r\n                }\r\n            };\r\n            p[pos]();\r\n            self.ctx.stroke();\r\n        }\r\n        function addEllipsis(text, width) {\r\n            var c, w = 0;\r\n            if (self.ellipsisCache[text] && self.ellipsisCache[text][width]) {\r\n                return self.ellipsisCache[text][width];\r\n            }\r\n            //TODO Add ellipsis back when there is a fast way to do it\r\n            w = self.ctx.measureText(text).width;\r\n            self.ellipsisCache[text] = self.ellipsisCache[text] || {};\r\n            c = {value: text, width: w};\r\n            self.ellipsisCache[text][width] = c;\r\n            return c;\r\n        }\r\n        function wrapText(cell, splitChar) {\r\n            if (!cell.formattedValue) {\r\n                return { lines: [{width: 0, value: ''}], width: 0, height: cell.calculatedLineHeight };\r\n            }\r\n            var max = 0,\r\n                n = '\\n',\r\n                x,\r\n                word,\r\n                words = cell.formattedValue.split(splitChar),\r\n                textHeight = cell.calculatedLineHeight,\r\n                lines = [],\r\n                out = [],\r\n                wrap = self.style.cellWhiteSpace !== 'nowrap',\r\n                elWidth,\r\n                et = self.attributes.ellipsisText,\r\n                elClipLength,\r\n                plWidth,\r\n                clippedVal,\r\n                ogWordWidth,\r\n                previousLine,\r\n                line = {\r\n                    width: 0,\r\n                    value: ''\r\n                },\r\n                cHeight = wrap ? cell.paddedHeight : cell.calculatedLineHeight;\r\n            lines.push(line);\r\n            elWidth = self.ctx.measureText(' ' + et).width;\r\n            for (x = 0; x < words.length; x += 1) {\r\n                word = words[x];\r\n                var measure = self.ctx.measureText(word + splitChar);\r\n                if (line.width + measure.width + elWidth < cell.paddedWidth) {\r\n                    line.value += word + splitChar;\r\n                    line.width += measure.width;\r\n                    continue;\r\n                }\r\n                // if there is a hyphenated word that is too long\r\n                // split it and add the split set to the array\r\n                // then back up and re-read new split set\r\n                // this behavior seems right, it might not be\r\n                if (/\\w-\\w/.test(word) && cell.paddedWidth < measure.width) {\r\n                    words.splice(x, 1, word.split('-')[0] + '-', word.split('-')[1]);\r\n                    x -= 1;\r\n                    continue;\r\n                }\r\n                line = {\r\n                    width: measure.width,\r\n                    value: word + splitChar\r\n                };\r\n                if (x === 0) {\r\n                    lines = [];\r\n                    lines.push(line);\r\n                }\r\n                textHeight += cell.calculatedLineHeight;\r\n                if (textHeight > cHeight) {\r\n                    if (lines.length === 0) { break; }\r\n                    elClipLength = 1;\r\n                    previousLine = lines[lines.length - 1];\r\n                    if (previousLine.width < cell.paddedWidth && words.length === 1) { break; }\r\n                    clippedVal = previousLine.value + word;\r\n                    plWidth = self.ctx.measureText(clippedVal + et).width;\r\n                    var originText = clippedVal;\r\n                    if (plWidth > cell.paddedWidth) {\r\n                        var stepLength = parseInt(clippedVal.length / 2);\r\n                        var direction = -1;\r\n                        while (stepLength > 0) {\r\n                            clippedVal = originText.substr(0, stepLength * direction + clippedVal.length);\r\n                            plWidth = self.ctx.measureText(clippedVal + et).width;\r\n                            direction = plWidth > cell.paddedWidth ? -1 : 1;\r\n                            stepLength = parseInt(stepLength / 2);\r\n                        }\r\n                    }\r\n                    clippedVal = clippedVal + (originText.length != clippedVal.length ? et : '');\r\n                    previousLine.value = clippedVal;\r\n                    previousLine.width = plWidth;\r\n                    break;\r\n                }\r\n                if (x > 0) {\r\n                    lines.push(line);\r\n                }\r\n            }\r\n            return {\r\n                lines: lines,\r\n                width: max,\r\n                height: cell.calculatedLineHeight * lines.length\r\n            }\r\n        }\r\n        function drawText(cell) {\r\n            var ll = cell.text.lines.length,\r\n                h = (cell.fontHeight * cell.lineHeight),\r\n                x,\r\n                line,\r\n                wrap = self.style.cellWhiteSpace !== 'nowrap',\r\n                textHeight = 0;\r\n            for (x = 0; x < cell.text.lines.length; x += 1) {\r\n                line = cell.text.lines[x];\r\n                var vPos = Math.max((cell.height - (wrap ? cell.text.height : cell.calculatedLineHeight)) * 0.5, 0) + h,\r\n                    hPos = cell.paddingLeft + cell.treeArrowWidth + cell.orderByArrowWidth;\r\n                if (cell.horizontalAlignment === 'right') {\r\n                    hPos = cell.paddingLeft + cell.paddedWidth - line.width;\r\n                } else if (cell.horizontalAlignment === 'center') {\r\n                    hPos = cell.paddingLeft + ((cell.paddedWidth + cell.paddingRight) / 2) - (line.width / 2);\r\n                }\r\n                if (cell.verticalAlignment === 'top') {\r\n                    vPos = cell.calculatedLineHeight;\r\n                } else if (cell.verticalAlignment === 'bottom') {\r\n                    vPos = cell.height - cell.paddingBottom - cell.text.height;\r\n                }\r\n                line.height = h + cell.lineSpacing;\r\n                line.offsetLeft = hPos;\r\n                line.offsetTop = vPos;\r\n                line.x = cell.x + hPos;\r\n                line.y = cell.y + textHeight + vPos;\r\n                textHeight += line.height;\r\n                fillText(line.value, line.x, line.y);\r\n            }\r\n            if (self.attributes.debug && cell.active) {\r\n                requestAnimationFrame(function () {\r\n                    self.ctx.font = self.style.debugFont;\r\n                    self.ctx.fillStyle = self.style.debugColor;\r\n                    fillText(JSON.stringify({\r\n                        x: cell.x,\r\n                        y: cell.y,\r\n                        h: cell.height,\r\n                        w: cell.width,\r\n                        pw: cell.paddedWidth,\r\n                        idx: cell.columnIndex,\r\n                        idx_ord: cell.sortColumnIndex\r\n                    }, null, '\\t'),\r\n                        cell.x + 14, cell.y + 14);\r\n                    fillText(JSON.stringify(cell.text.lines.map(function (l) { return {w: l.width, v: l.value.length }; }), null, '\\t'),\r\n                        cell.x + 14, cell.y + 30);\r\n                });\r\n            }\r\n        }\r\n        function getFrozenColumnsWidth() {\r\n            var w = 0,\r\n                s = self.getSchema(),\r\n                x = 0,\r\n                n = Math.min(self.frozenColumn, s.length),\r\n                column;\r\n            hiddenFrozenColumnCount = 0;\r\n            while (x < n) {\r\n                column = s[x];\r\n                if (column.hidden) {\r\n                    hiddenFrozenColumnCount += 1;\r\n                } else {\r\n                    w += self.getColummnWidth(x);\r\n                }\r\n                x += 1;\r\n            }\r\n            return w;\r\n        }\r\n        /**\r\n         * Redraws the grid. No matter what the change, this is the only method required to refresh everything.\r\n         * @memberof canvasDatagrid\r\n         * @name draw\r\n         * @method\r\n         */\r\n         // r = literal row index\r\n         // rd = row data array\r\n         // i = user order index\r\n         // o = literal data index\r\n         // y = y drawing cursor\r\n         // x = x drawing cursor\r\n         // s = visible schema array\r\n         // cx = current x drawing cursor sub calculation var\r\n         // cy = current y drawing cursor sub calculation var\r\n         // a = static cell (like corner cell)\r\n         // p = perf counter\r\n         // l = data length\r\n         // u = current cell\r\n         // h = current height\r\n         // w = current width\r\n        self.draw = function (internal) {\r\n            if (self.dispatchEvent('beforedraw', {})) { return; }\r\n            if (!self.isChildGrid && (!self.height || !self.width)) {\r\n                return;\r\n            }\r\n            if (self.isChildGrid && internal) {\r\n                requestAnimationFrame(self.parentGrid.draw);\r\n                return;\r\n            }\r\n            if (self.intf.visible === false) {\r\n                return;\r\n            }\r\n            // initial values\r\n            var checkScrollHeight, rowHeaderCell, p, cx, cy, treeGrid, rowOpen,\r\n                rowHeight, cornerCell, y, x, c, h, w, s, r, rd, aCell,\r\n                data = (self.data || []),\r\n                bc = self.style.gridBorderCollapse === 'collapse',\r\n                selectionBorders = [],\r\n                moveBorders = [],\r\n                selectionHandles = [],\r\n                rowHeaders = [],\r\n                l = data.length,\r\n                u = self.currentCell || {},\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n                rowHeaderCellWidth = self.getRowHeaderCellWidth(),\r\n                cellHeight = self.style.cellHeight;\r\n            drawCount += 1;\r\n            p = performance.now();\r\n            self.visibleRowHeights = [];\r\n            // if data length has changed, there is no way to know\r\n            if (data.length > self.orders.rows.length) {\r\n                self.createRowOrders();\r\n            }\r\n            function createHandlesOverlayArray(cell) {\r\n                if (self.attributes.allowMovingSelection || self.mobile) {\r\n                    if (cell.selectionBorderTop && cell.selectionBorderRight && self.mobile) {\r\n                        selectionHandles.push([cell, 'tr']);\r\n                        cell.selectionHandle = 'tr';\r\n                    }\r\n                    if (cell.selectionBorderTop && cell.selectionBorderLeft && self.mobile) {\r\n                        selectionHandles.push([cell, 'tl']);\r\n                        cell.selectionHandle = 'tl';\r\n                    }\r\n                    if (cell.selectionBorderBottom && cell.selectionBorderLeft && self.mobile) {\r\n                        selectionHandles.push([cell, 'bl']);\r\n                        cell.selectionHandle = 'bl';\r\n                    }\r\n                    if (cell.selectionBorderBottom && cell.selectionBorderRight\r\n                            && (self.attributes.selectionHandleBehavior !== 'none' || self.mobile)) {\r\n                        selectionHandles.push([cell, 'br']);\r\n                        cell.selectionHandle = 'br';\r\n                    }\r\n                }\r\n            }\r\n            function createBorderOverlayArray(cell, drawArray, propPrefix, offsetPoint) {\r\n                offsetPoint = offsetPoint || {x: 0, y: 0};\r\n                cell.selectionBorder = '';\r\n                if (!cell.isRowHeader\r\n                        && self.selections[cell.rowIndex + -offsetPoint.y]\r\n                        && self.selections[cell.rowIndex + -offsetPoint.y].indexOf(cell.columnIndex + -offsetPoint.x) !== -1) {\r\n                    if ((!self.selections[cell.rowIndex - 1 + -offsetPoint.y]\r\n                            || self.selections[cell.rowIndex - 1 + -offsetPoint.y].indexOf(cell.columnIndex + -offsetPoint.x) === -1\r\n                            || cell.rowIndex === 0)\r\n                            && !cell.isHeader) {\r\n                        drawArray.push([cell, 't']);\r\n                        cell[propPrefix + 'BorderTop'] = true;\r\n                        cell[propPrefix + 'Border'] += 't';\r\n                    }\r\n                    if (!self.selections[cell.rowIndex + 1 + -offsetPoint.y]\r\n                            || self.selections[cell.rowIndex + 1 + -offsetPoint.y].indexOf(cell.columnIndex + -offsetPoint.x) === -1) {\r\n                        drawArray.push([cell, 'b']);\r\n                        cell[propPrefix + 'BorderBottom'] = true;\r\n                        cell[propPrefix + 'Border'] += 'b';\r\n                    }\r\n                    if (!self.selections[cell.rowIndex + -offsetPoint.y] || cell.columnIndex === 0\r\n                            || self.selections[cell.rowIndex + -offsetPoint.y].indexOf(cell.columnIndex - 1 + -offsetPoint.x) === -1) {\r\n                        drawArray.push([cell, 'l']);\r\n                        cell[propPrefix + 'BorderLeft'] = true;\r\n                        cell[propPrefix + 'Border'] += 'l';\r\n                    }\r\n                    if (!self.selections[cell.rowIndex + -offsetPoint.y] || cell.columnIndex === s.length\r\n                            || self.selections[cell.rowIndex + -offsetPoint.y].indexOf(cell.columnIndex + 1 + -offsetPoint.x) === -1) {\r\n                        drawArray.push([cell, 'r']);\r\n                        cell[propPrefix + 'BorderRight'] = true;\r\n                        cell[propPrefix + 'Border'] += 'r';\r\n                    }\r\n                }\r\n            }\r\n            function drawCell(d, rowOrderIndex, rowIndex) {\r\n                return function drawEach(header, headerIndex, columnOrderIndex) {\r\n                    if (header.hidden) { return 0; }\r\n                    var cellStyle = header.style || 'cell',\r\n                        cellGridAttributes,\r\n                        cell,\r\n                        isHeader = /HeaderCell/.test(cellStyle),\r\n                        isCorner = /cornerCell/.test(cellStyle),\r\n                        isRowHeader = 'rowHeaderCell' === cellStyle,\r\n                        isColumnHeader = 'columnHeaderCell' === cellStyle,\r\n                        selected = self.selections[rowOrderIndex] && self.selections[rowOrderIndex].indexOf(columnOrderIndex) !== -1,\r\n                        hovered = self.hovers.rowIndex === rowOrderIndex && self.hovers.columnIndex === columnOrderIndex,\r\n                        active = self.activeCell.rowIndex === rowOrderIndex && self.activeCell.columnIndex === columnOrderIndex,\r\n                        isColumnHeaderCellCap = cellStyle === 'columnHeaderCellCap',\r\n                        rawValue = d ? d[header.name] : undefined,\r\n                        isGrid = header.type === 'canvas-datagrid',\r\n                        activeHeader = (self.orders.rows[self.activeCell.rowIndex] === rowOrderIndex\r\n                                || self.orders.columns[self.activeCell.columnIndex] === headerIndex)\r\n                            && (columnOrderIndex === -1 || rowOrderIndex === -1)\r\n                            ? (isRowHeader ? 'activeRowHeaderCell' : 'activeColumnHeaderCell') : false,\r\n                        val,\r\n                        f = self.formatters[header.type || 'string'],\r\n                        orderByArrowSize = 0,\r\n                        treeArrowSize = 0,\r\n                        cellWidth = self.sizes.columns[headerIndex] || header.width,\r\n                        ev = {\r\n                            value: rawValue,\r\n                            row: d,\r\n                            header: header\r\n                        };\r\n                    if (isColumnHeaderCellCap) {\r\n                        cellWidth = w - x;\r\n                    }\r\n                    // if no data or schema are defined, a width is provided to the stub column\r\n                    if (cellWidth === undefined) {\r\n                        cellWidth = self.style.cellWidth;\r\n                    }\r\n                    cellWidth = cellWidth * self.scale;\r\n                    if (x + cellWidth + self.style.cellBorderWidth < 0) {\r\n                        x += cellWidth + self.style.cellBorderWidth;\r\n                    }\r\n                    if (active && cellStyle !== 'cornerCell') {\r\n                        cellStyle = 'activeCell';\r\n                    }\r\n                    if (self.visibleRows.indexOf(rowIndex) === -1 && !isHeader) {\r\n                        self.visibleRows.push(rowIndex);\r\n                    }\r\n                    val = self.dispatchEvent('formatcellvalue', ev);\r\n                    cx = x;\r\n                    cy = y;\r\n                    if (cellStyle === 'cornerCell') {\r\n                        cx = 0;\r\n                        cy = 0;\r\n                    } else if (isRowHeader) {\r\n                        cx = 0;\r\n                    } else if (isHeader) {\r\n                        cy = 0;\r\n                    }\r\n                    cell = {\r\n                        type: isGrid ? 'canvas-datagrid-cell' : header.type,\r\n                        style: cellStyle,\r\n                        nodeType: 'canvas-datagrid-cell',\r\n                        x: cx,\r\n                        y: cy,\r\n                        fontHeight: (self.style[cellStyle + 'FontHeight'] || 0) * self.scale,\r\n                        horizontalAlignment: self.style[cellStyle + 'HorizontalAlignment'],\r\n                        verticalAlignment: self.style[cellStyle + 'VerticalAlignment'],\r\n                        paddingLeft: (self.style[cellStyle + 'PaddingLeft'] || 0) * self.scale,\r\n                        paddingTop: (self.style[cellStyle + 'PaddingTop'] || 0) * self.scale,\r\n                        paddingRight: (self.style[cellStyle + 'PaddingRight'] || 0) * self.scale,\r\n                        paddingBottom: (self.style[cellStyle + 'PaddingBottom'] || 0) * self.scale,\r\n                        whiteSpace: self.style.cellWhiteSpace,\r\n                        lineHeight: self.style.cellLineHeight,\r\n                        lineSpacing: self.style.cellLineSpacing,\r\n                        offsetTop: self.canvasOffsetTop + cy,\r\n                        offsetLeft: self.canvasOffsetLeft + cx,\r\n                        scrollTop: self.scrollBox.scrollTop,\r\n                        scrollLeft: self.scrollBox.scrollLeft,\r\n                        active: active || activeHeader,\r\n                        hovered: hovered,\r\n                        selected: selected,\r\n                        width: cellWidth,\r\n                        height: cellHeight,\r\n                        offsetWidth: cellWidth,\r\n                        offsetHeight: cellHeight,\r\n                        parentNode: self.intf.parentNode,\r\n                        offsetParent: self.intf.parentNode,\r\n                        data: d,\r\n                        isCorner: isCorner,\r\n                        isHeader: isHeader,\r\n                        isColumnHeader: isColumnHeader,\r\n                        isColumnHeaderCellCap: isColumnHeaderCellCap,\r\n                        isRowHeader: isRowHeader,\r\n                        rowOpen: rowOpen,\r\n                        header: header,\r\n                        columnIndex: columnOrderIndex,\r\n                        rowIndex: rowOrderIndex,\r\n                        sortColumnIndex: headerIndex,\r\n                        sortRowIndex: rowIndex,\r\n                        isGrid: isGrid,\r\n                        isNormal: !isGrid && !isCorner && !isHeader,\r\n                        gridId: (self.attributes.name || '') + rowIndex + ':' + headerIndex,\r\n                        parentGrid: self.intf,\r\n                        innerHTML: '',\r\n                        activeHeader: activeHeader,\r\n                        value: isHeader && !isRowHeader ? (header.title || header.name) : rawValue\r\n                    };\r\n                    cell.calculatedLineHeight = (cell.fontHeight * cell.lineHeight) + cell.lineSpacing;\r\n                    cell.paddedWidth = cell.width - cell.paddingRight - cell.paddingLeft;\r\n                    cell.paddedHeight = cell.height - cell.paddingTop - cell.paddingBottom;\r\n                    ev.cell = cell;\r\n                    cell.userHeight = cell.isHeader ? self.sizes.rows[-1] : rowHeight;\r\n                    cell.userWidth = cell.isHeader ? self.sizes.columns.cornerCell : self.sizes.columns[headerIndex];\r\n                    self.visibleCells.unshift(cell);\r\n                    if (self.dispatchEvent('beforerendercell', ev)) { return; }\r\n                    self.ctx.fillStyle = self.style[cellStyle + 'BackgroundColor'];\r\n                    self.ctx.strokeStyle = self.style[cellStyle + 'BorderColor'];\r\n                    self.ctx.lineWidth = self.style[cellStyle + 'BorderWidth'];\r\n                    if (hovered) {\r\n                        self.ctx.fillStyle = self.style[cellStyle + 'HoverBackgroundColor'];\r\n                        self.ctx.strokeStyle = self.style[cellStyle + 'HoverBorderColor'];\r\n                    }\r\n                    if (selected) {\r\n                        self.ctx.fillStyle = self.style[cellStyle + 'SelectedBackgroundColor'];\r\n                        self.ctx.strokeStyle = self.style[cellStyle + 'SelectedBorderColor'];\r\n                    }\r\n                    if (activeHeader) {\r\n                        self.ctx.fillStyle = self.style[activeHeader + 'BackgroundColor'];\r\n                    }\r\n                    self.dispatchEvent('rendercell', ev);\r\n                    if (cell.isGrid) {\r\n                        if (cell.height !== rowHeight) {\r\n                            cell.height = rowHeight || self.style.cellHeightWithChildGrid;\r\n                            checkScrollHeight = true;\r\n                        }\r\n                        cell.width = self.sizes.columns[headerIndex] || self.style.cellWidthWithChildGrid;\r\n                    }\r\n                    if (rowOpen && !cell.isRowHeader) {\r\n                        cell.height = self.sizes.rows[rowIndex] || self.style.cellHeight;\r\n                    }\r\n                    if (!cell.isGrid) {\r\n                        fillRect(cx, cy, cell.width, cell.height);\r\n                        strokeRect(cx, cy, cell.width, cell.height);\r\n                    }\r\n                    self.ctx.save();\r\n                    radiusRect(cell.x, cell.y, cell.width, cell.height, 0);\r\n                    self.ctx.clip();\r\n                    self.dispatchEvent('afterrendercell', ev);\r\n                    if (cell.height !== cellHeight && !(rowOpen && !cell.isRowHeader)) {\r\n                        self.sizes.rows[isHeader ? -1 : rowIndex] = cell.height;\r\n                        checkScrollHeight = true;\r\n                    }\r\n                    if (cell.width !== cellWidth) {\r\n                        self.sizes.columns[headerIndex] = cell.width;\r\n                        checkScrollHeight = true;\r\n                    }\r\n                    if (isRowHeader && self.attributes.tree) {\r\n                        if (!self.dispatchEvent('rendertreearrow', ev)) {\r\n                            treeArrowSize = drawTreeArrow(cell, self.style[cellStyle + 'PaddingLeft'], cy, 0);\r\n                        }\r\n                    }\r\n                    if ((self.attributes.showRowNumbers && isRowHeader)\r\n                            || !isRowHeader) {\r\n                        if (cell.isGrid && !self.dispatchEvent('beforerendercellgrid', ev)) {\r\n                            if (!self.childGrids[cell.gridId]) {\r\n                                // HACK: this only allows setting of the child grids styles if data is set _after_\r\n                                // this is less than desirable.  An interface needs to be made to effect the\r\n                                // style of all cell grids.  One for individual grids already exists.\r\n                                cellGridAttributes = self.cellGridAttributes;\r\n                                cellGridAttributes.name = self.attributes.saveAppearance ? cell.gridId : undefined;\r\n                                cellGridAttributes.component = false;\r\n                                cellGridAttributes.parentNode = cell;\r\n                                cellGridAttributes.data = rawValue;\r\n                                ev.cellGridAttributes = cellGridAttributes;\r\n                                if (self.dispatchEvent('beforecreatecellgrid', ev)) { return; }\r\n                                self.childGrids[cell.gridId] = self.createGrid(cellGridAttributes);\r\n                                self.sizes.rows[rowIndex]\r\n                                    = self.sizes.rows[rowIndex] || self.style.cellGridHeight;\r\n                                checkScrollHeight = true;\r\n                            }\r\n                            cell.grid = self.childGrids[cell.gridId];\r\n                            cell.grid.parentNode = cell;\r\n                            cell.grid.visible = true;\r\n                            cell.grid.draw();\r\n                            self.dispatchEvent('rendercellgrid', ev);\r\n                        } else if (!cell.isGrid) {\r\n                            if (self.childGrids[cell.gridId]) {\r\n                                self.childGrids[cell.gridId].parentNode.offsetHeight = 0;\r\n                            }\r\n                            if (isHeader && self.orderBy === header.name) {\r\n                                if (!self.dispatchEvent('renderorderbyarrow', ev)) {\r\n                                    orderByArrowSize = drawOrderByArrow(cx + self.style[cellStyle + 'PaddingLeft'], 0);\r\n                                }\r\n                            }\r\n                            self.ctx.fillStyle = self.style[cellStyle + 'Color'];\r\n                            if (hovered) {\r\n                                self.ctx.fillStyle = self.style[cellStyle + 'HoverColor'];\r\n                            }\r\n                            if (selected) {\r\n                                self.ctx.fillStyle = self.style[cellStyle + 'SelectedColor'];\r\n                            }\r\n                            if (activeHeader) {\r\n                                self.ctx.fillStyle = self.style[activeHeader + 'Color'];\r\n                            }\r\n                            cell.treeArrowWidth = treeArrowSize;\r\n                            cell.orderByArrowWidth = orderByArrowSize;\r\n                            // create text ref to see if height needs to expand\r\n                            val = val !== undefined ? val : f\r\n                                ? f(ev) : '';\r\n                            if (val === undefined && !f) {\r\n                                val = '';\r\n                                console.warn('canvas-datagrid: Unknown format '\r\n                                    + header.type + ' add a cellFormater');\r\n                            }\r\n                            cell.formattedValue = ((val !== undefined && val !== null) ? val : '').toString();\r\n                            if (self.columnFilters && self.columnFilters[val] !== undefined && isHeader) {\r\n                                cell.formattedValue = self.attributes.filterTextPrefix + val;\r\n                            }\r\n                            self.ctx.font = (self.style[cellStyle + 'FontHeight'] * self.scale) + 'px ' + self.style[cellStyle + 'FontName'];\r\n                            if (!self.dispatchEvent('formattext', ev)) {\r\n                                cell.text = wrapText(cell, ' ');\r\n                            }\r\n                            if (!self.dispatchEvent('rendertext', ev)) {\r\n                                if (cell.innerHTML || header.type === 'html') {\r\n                                    drawHtml(cell);\r\n                                } else {\r\n                                    drawText(cell);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (active) {\r\n                        aCell = cell;\r\n                    }\r\n                    createBorderOverlayArray(cell, selectionBorders, 'selection');\r\n                    // createBorderOverlayArray calculates data for createHandlesOverlayArray so it must go 2nd\r\n                    createHandlesOverlayArray(cell);\r\n                    if (self.movingSelection) {\r\n                        createBorderOverlayArray(cell, moveBorders, 'move', self.moveOffset);\r\n                    }\r\n                    self.ctx.restore();\r\n                    x += cell.width + (bc ? 0 : self.style.cellBorderWidth);\r\n                    return cell.width;\r\n                };\r\n            }\r\n            function drawRowHeader(rowData, index, rowOrderIndex) {\r\n                var a, i;\r\n                if (self.attributes.showRowHeaders) {\r\n                    x = 0;\r\n                    i = index + 1;\r\n                    rowHeaderCell = {'rowHeaderCell': i };\r\n                    a = {\r\n                        name: 'rowHeaderCell',\r\n                        width: self.sizes.columns[-1] || self.style.rowHeaderCellWidth,\r\n                        style: 'rowHeaderCell',\r\n                        type: 'string',\r\n                        data: i,\r\n                        index: -1\r\n                    };\r\n                    rowOpen = self.openChildren[index];\r\n                    drawCell(rowHeaderCell, index, rowOrderIndex)(a, -1, -1);\r\n                }\r\n            }\r\n            function drawHeaders() {\r\n                var d, g = s.length, i, o, columnHeaderCell, header, nonFrozenHeaderWidth;\r\n                function drawHeaderColumnRange(start, end) {\r\n                    end = Math.min(end, g);\r\n                    for (o = start; o < end; o += 1) {\r\n                        i = self.orders.columns[o];\r\n                        header = s[i];\r\n                        if (!header.hidden) {\r\n                            d = {\r\n                                title: header.title,\r\n                                name: header.name,\r\n                                width: header.width || self.style.cellWidth,\r\n                                style: 'columnHeaderCell',\r\n                                type: 'string',\r\n                                index: o,\r\n                                order: i\r\n                            };\r\n                            columnHeaderCell = {'columnHeaderCell': header.title || header.name};\r\n                            x += drawCell(columnHeaderCell, -1, -1)(d, i, o);\r\n                            if (x > self.width + self.scrollBox.scrollLeft) {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                rowHeaders.forEach(function (rArgs, rhIndex) {\r\n                    y = rArgs[3];\r\n                    cellHeight = rArgs[4];\r\n                    if (rhIndex === self.frozenRow) {\r\n                        self.ctx.save();\r\n                        radiusRect(0, self.lastFrozenRowPixel, self.width, self.height - self.lastFrozenRowPixel, 0);\r\n                        self.ctx.clip();\r\n                    }\r\n                    drawRowHeader(rArgs[0], rArgs[1], rArgs[2]);\r\n                });\r\n                self.ctx.restore();\r\n                if (self.attributes.showColumnHeaders) {\r\n                    x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.columnHeaderCellBorderWidth;\r\n                    if (self.attributes.showRowHeaders) {\r\n                        x += rowHeaderCellWidth;\r\n                    }\r\n                    y = 0;\r\n                    // cell height might have changed during drawing\r\n                    cellHeight = self.getColumnHeaderCellHeight();\r\n                    drawHeaderColumnRange(self.scrollIndexLeft, g);\r\n                    nonFrozenHeaderWidth = x;\r\n                    x = self.style.columnHeaderCellBorderWidth;\r\n                    if (self.attributes.showRowHeaders) {\r\n                        x += rowHeaderCellWidth;\r\n                    }\r\n                    drawHeaderColumnRange(0, self.frozenColumn);\r\n                    // fill in the space right of the headers\r\n                    x = nonFrozenHeaderWidth;\r\n                    if (x < w) {\r\n                        c = {\r\n                            name: '',\r\n                            width: self.style.scrollBarWidth,\r\n                            style: 'columnHeaderCellCap',\r\n                            isColumnHeaderCell: true,\r\n                            isColumnHeaderCellCap: true,\r\n                            type: 'string',\r\n                            index: s.length\r\n                        };\r\n                        drawCell({endCap: ''}, -1, -1)(c, -1, -1);\r\n                    }\r\n                    // fill in the space right of the headers\r\n                    if (self.attributes.showRowHeaders) {\r\n                        cornerCell = {'cornerCell': '' };\r\n                        x = 0;\r\n                        c = {\r\n                            name: 'cornerCell',\r\n                            width: self.style.rowHeaderCellWidth,\r\n                            style: 'cornerCell',\r\n                            type: 'string',\r\n                            index: -1\r\n                        };\r\n                        drawCell(cornerCell, -1, -1)(c, -1, -1);\r\n                    }\r\n                }\r\n            }\r\n            function drawRow(r, d) {\r\n                var i, treeHeight, rowSansTreeHeight, o, g = s.length;\r\n                if (y - (cellHeight * 2) > h) {\r\n                    return false;\r\n                }\r\n                rd = data[r];\r\n                rowOpen = self.openChildren[r];\r\n                rowSansTreeHeight = (self.sizes.rows[r] || self.style.cellHeight) * self.scale;\r\n                treeHeight = (rowOpen ? self.sizes.trees[r] : 0) * self.scale;\r\n                rowHeight = (rowSansTreeHeight + treeHeight);\r\n                if (y < -rowHeight) {\r\n                    return false;\r\n                }\r\n                if (self.attributes.showRowHeaders) {\r\n                    x += rowHeaderCellWidth;\r\n                }\r\n                cellHeight = rowHeight;\r\n                //draw normal columns\r\n                for (o = (self.scrollIndexLeft); o < g; o += 1) {\r\n                    i = self.orders.columns[o];\r\n                    x += drawCell(rd, r, d)(s[i], i, o);\r\n                    if (x > self.width) {\r\n                        self.scrollIndexRight = o;\r\n                        self.scrollPixelRight = x;\r\n                        break;\r\n                    }\r\n                }\r\n                //draw frozen columns\r\n                x = 0;\r\n                if (self.attributes.showRowHeaders) {\r\n                    x += rowHeaderCellWidth;\r\n                }\r\n                for (o = 0; o < self.frozenColumn; o += 1) {\r\n                    i = self.orders.columns[o];\r\n                    x += drawCell(rd, r, d)(s[i], i, o);\r\n                    if (x > self.width) {\r\n                        break;\r\n                    }\r\n                }\r\n                self.lastFrozenColumnPixel = x;\r\n                // cell height might have changed during drawing\r\n                cellHeight = rowHeight;\r\n                x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.cellBorderWidth;\r\n                // don't draw a tree for the new row\r\n                treeGrid = self.childGrids[r];\r\n                if (r !== data.length && rowOpen) {\r\n                    treeGrid.visible = true;\r\n                    treeGrid.parentNode = {\r\n                        offsetTop: y + rowSansTreeHeight + self.canvasOffsetTop,\r\n                        offsetLeft: rowHeaderCellWidth - 1 + self.canvasOffsetLeft,\r\n                        offsetHeight: treeHeight,\r\n                        offsetWidth: self.width - rowHeaderCellWidth - self.style.scrollBarWidth - 1,\r\n                        offsetParent: self.intf.parentNode,\r\n                        parentNode: self.intf.parentNode,\r\n                        style: self.style,\r\n                        nodeType: 'canvas-datagrid-tree',\r\n                        scrollTop: self.scrollBox.scrollTop,\r\n                        scrollLeft: self.scrollBox.scrollLeft,\r\n                        rowIndex: r\r\n                    };\r\n                    self.visibleCells.unshift({\r\n                        rowIndex: r,\r\n                        columnIndex: 0,\r\n                        y: treeGrid.parentNode.offsetTop,\r\n                        x: treeGrid.parentNode.offsetLeft,\r\n                        height: treeGrid.height,\r\n                        width: treeGrid.width,\r\n                        style: 'tree-grid',\r\n                        type: treeGrid.parentNode.nodeType\r\n                    });\r\n                    treeGrid.draw();\r\n                } else if (treeGrid) {\r\n                    treeGrid.parentNode.offsetHeight = 0;\r\n                    delete self.sizes.trees[r];\r\n                }\r\n                rowHeaders.push([rd, r, d, y, rowHeight]);\r\n                self.visibleRowHeights[r] = rowHeight;\r\n                y += cellHeight + (bc ? 0 : self.style.cellBorderWidth);\r\n                return true;\r\n            }\r\n            function initDraw() {\r\n                self.visibleRows = [];\r\n                s = self.getSchema();\r\n                self.visibleCells = [];\r\n                self.canvasOffsetTop = self.isChildGrid ? self.parentNode.offsetTop : 0;\r\n                self.canvasOffsetLeft = self.isChildGrid ? self.parentNode.offsetLeft : 0;\r\n                h = self.height;\r\n                w = self.width;\r\n            }\r\n            function drawBackground() {\r\n                radiusRect(0, 0, w, h, 0);\r\n                self.ctx.clip();\r\n                self.ctx.fillStyle = self.style.gridBackgroundColor;\r\n                fillRect(0, 0, w, h);\r\n            }\r\n            function drawFrozenRows() {\r\n                var n, ln = Math.min(data.length, self.frozenRow);\r\n                x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.cellBorderWidth;\r\n                y = columnHeaderCellHeight;\r\n                for (r = 0; r < ln; r += 1) {\r\n                    n = self.orders.rows[r];\r\n                    if (!drawRow(n, r)) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (self.attributes.allowFreezingRows) {\r\n                    // HACK great, another stupid magic number.\r\n                    // Background will appear as a 0.5px artifact behind the row freeze bar without this hack\r\n                    y += self.style.frozenMarkerBorderWidth + self.style.frozenMarkerWidth - 0.4999999999;\r\n                }\r\n                self.lastFrozenRowPixel = y;\r\n            }\r\n            function drawRows() {\r\n                self.ctx.save();\r\n                if (self.frozenRow > 0) {\r\n                    radiusRect(0, self.lastFrozenRowPixel, self.width, self.height - self.lastFrozenRowPixel, 0);\r\n                    self.ctx.clip();\r\n                }\r\n                var o, n, i, g = s.length;\r\n                x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.cellBorderWidth;\r\n                if (!self.attributes.snapToRow) {\r\n                    y += -self.scrollBox.scrollTop + self.scrollPixelTop + self.style.cellBorderWidth;\r\n                }\r\n                for (r = self.frozenRow + self.scrollIndexTop; r < l; r += 1) {\r\n                    n = self.orders.rows[r];\r\n                    self.scrollIndexBottom = r;\r\n                    self.scrollPixelBottom = y;\r\n                    if (!drawRow(n, r)) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (self.attributes.showNewRow) {\r\n                    if (self.attributes.showRowHeaders) {\r\n                        x += rowHeaderCellWidth;\r\n                    }\r\n                    rowHeight = cellHeight = self.style.cellHeight;\r\n                    rowOpen = false;\r\n                    for (o = self.scrollIndexLeft; o < g; o += 1) {\r\n                        i = self.orders.columns[o];\r\n                        x += drawCell(self.newRow, data.length, data.length)(s[i], i, o);\r\n                        if (x > self.width + self.scrollBox.scrollLeft) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    rowHeaders.push([self.newRow, data.length, data.length, y, rowHeight]);\r\n                }\r\n                self.ctx.restore();\r\n            }\r\n            function drawMoveMarkers() {\r\n                if (!self.movingSelection) { return; }\r\n                self.ctx.lineWidth = self.style.moveOverlayBorderWidth;\r\n                self.ctx.strokeStyle = self.style.moveOverlayBorderColor;\r\n                self.ctx.setLineDash(self.style.moveOverlayBorderSegments);\r\n                moveBorders.forEach(function (c) {\r\n                    addBorderLine(c[0], c[1]);\r\n                });\r\n                self.ctx.setLineDash([]);\r\n            }\r\n            function drawReorderMarkers() {\r\n                if (!self.reorderObject) { return; }\r\n                var b = {\r\n                        height: self.reorderObject.height,\r\n                        width: self.reorderObject.width,\r\n                        x: self.reorderObject.x + self.reorderObject.dragOffset.x,\r\n                        y: self.reorderObject.y + self.reorderObject.dragOffset.y\r\n                    },\r\n                    m = {\r\n                        width: w,\r\n                        height: h,\r\n                        x: 0,\r\n                        y: 0\r\n                    };\r\n                self.ctx.fillStyle = self.style.reorderMarkerBackgroundColor;\r\n                self.ctx.lineWidth = self.style.reorderMarkerBorderWidth;\r\n                self.ctx.strokeStyle = self.style.reorderMarkerBorderColor;\r\n                if (self.dragMode === 'row-reorder') {\r\n                    b.width = w;\r\n                    b.x = 0;\r\n                    m.width = w;\r\n                    m.height = self.currentCell.height;\r\n                    m.y = self.currentCell.y;\r\n                    fillRect(b.x, b.y, b.width, b.height);\r\n                    strokeRect(b.x, b.y, b.width, b.height);\r\n                    self.ctx.lineWidth = self.style.reorderMarkerIndexBorderWidth;\r\n                    self.ctx.strokeStyle = self.style.reorderMarkerIndexBorderColor;\r\n                    if (self.currentCell.rowIndex !== self.reorderObject.rowIndex\r\n                            && self.currentCell.rowIndex > -1\r\n                            && self.currentCell.rowIndex < l) {\r\n                        addBorderLine(m, self.reorderTarget.sortRowIndex > self.reorderObject.sortRowIndex ? 'b' : 't');\r\n                    }\r\n                } else if (self.dragMode === 'column-reorder' && self.reorderObject) {\r\n                    b.height = h;\r\n                    b.y = 0;\r\n                    m.height = h;\r\n                    m.width = self.currentCell.width;\r\n                    m.y = 0;\r\n                    m.x = self.currentCell.x;\r\n                    fillRect(b.x, b.y, b.width, b.height);\r\n                    strokeRect(b.x, b.y, b.width, b.height);\r\n                    self.ctx.lineWidth = self.style.reorderMarkerIndexBorderWidth;\r\n                    self.ctx.strokeStyle = self.style.reorderMarkerIndexBorderColor;\r\n                    if (self.currentCell.sortColumnIndex !== self.reorderObject.sortColumnIndex\r\n                            && self.currentCell.sortColumnIndex > -1\r\n                            && self.currentCell.sortColumnIndex < s.length) {\r\n                        addBorderLine(m, self.reorderTarget.columnIndex > self.reorderObject.columnIndex ? 'r' : 'l');\r\n                    }\r\n                }\r\n            }\r\n            function drawBorder() {\r\n                self.ctx.lineWidth = self.style.gridBorderWidth;\r\n                self.ctx.strokeStyle = self.style.gridBorderColor;\r\n                strokeRect(0, 0, self.width, self.height);\r\n            }\r\n            function drawSelectionBorders() {\r\n                self.ctx.lineWidth = self.style.selectionOverlayBorderWidth;\r\n                self.ctx.strokeStyle = self.style.selectionOverlayBorderColor;\r\n                function dsb(c) {\r\n                    addBorderLine(c[0], c[1]);\r\n                }\r\n                selectionBorders.filter(function (c) {\r\n                    return c[0].rowIndex < self.frozenRow && c[0].columnIndex < self.frozenColumn;\r\n                }).forEach(dsb);\r\n                self.ctx.save();\r\n                clipFrozenArea(0);\r\n                selectionBorders.filter(function (c) {\r\n                    return c[0].rowIndex >= self.frozenRow && c[0].columnIndex >= self.frozenColumn;\r\n                }).forEach(dsb);\r\n                self.ctx.restore();\r\n                self.ctx.save();\r\n                clipFrozenArea(1);\r\n                selectionBorders.filter(function (c) {\r\n                    return c[0].rowIndex >= self.frozenRow && c[0].columnIndex < self.frozenColumn;\r\n                }).forEach(dsb);\r\n                self.ctx.restore();\r\n                self.ctx.save();\r\n                clipFrozenArea(2);\r\n                selectionBorders.filter(function (c) {\r\n                    return c[0].rowIndex < self.frozenRow && c[0].columnIndex >= self.frozenColumn;\r\n                }).forEach(dsb);\r\n                self.ctx.restore();\r\n            }\r\n            function drawSelectionHandles() {\r\n                if (self.mobile || self.attributes.allowMovingSelection) {\r\n                    self.ctx.lineWidth = self.style.selectionHandleBorderWidth;\r\n                    self.ctx.strokeStyle = self.style.selectionHandleBorderColor;\r\n                    self.ctx.fillStyle = self.style.selectionHandleColor;\r\n                    selectionHandles.forEach(function (c) {\r\n                        addselectionHandle(c[0], c[1]);\r\n                        var az = self.attributes.touchSelectHandleZone / 2,\r\n                            ax = c[0].x + (c[1] === 'tl' || c[1] === 'bl' ? 0 : c[0].width) - az,\r\n                            ay = c[0].y + (c[1] === 'bl' || c[1] === 'br' ? c[0].height : 0) - az;\r\n                        self.visibleCells.unshift({\r\n                            x: ax,\r\n                            y: ay,\r\n                            height: self.style.selectionHandleSize + az,\r\n                            width: self.style.selectionHandleSize + az,\r\n                            style: 'selection-handle-' + c[1]\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n            function drawActiveCell() {\r\n                if (!aCell) { return; }\r\n                self.ctx.save();\r\n                var cl = self.activeCell.columnIndex + 1 > self.frozenColumn || self.activeCell.rowIndex + 1 > self.frozenRow,\r\n                    acx = cl ? self.lastFrozenColumnPixel : 0,\r\n                    acy = cl ? self.lastFrozenRowPixel : 0,\r\n                    acw = cl ? self.width - self.lastFrozenColumnPixel : self.width,\r\n                    ach = cl ? self.height - self.lastFrozenRowPixel : self.height;\r\n                radiusRect(acx, acy, acw, ach, 0);\r\n                self.ctx.clip();\r\n                if (self.attributes.selectionMode === 'row') {\r\n                    if (self.activeCell && self.activeCell.rowIndex === aCell.rowIndex) {\r\n                        self.ctx.lineWidth = self.style.activeCellOverlayBorderWidth;\r\n                        self.ctx.strokeStyle = self.style.activeCellOverlayBorderColor;\r\n                        strokeRect(0, aCell.y, self.getHeaderWidth() + rowHeaderCellWidth, self.visibleRowHeights[aCell.rowIndex]);\r\n                    }\r\n                } else {\r\n                    self.ctx.lineWidth = self.style.activeCellOverlayBorderWidth;\r\n                    self.ctx.strokeStyle = self.style.activeCellOverlayBorderColor;\r\n                    strokeRect(aCell.x, aCell.y, aCell.width, aCell.height);\r\n                }\r\n                self.ctx.restore();\r\n            }\r\n            function drawFrozenMarkers() {\r\n                var my = self.lastFrozenRowPixel - self.style.frozenMarkerWidth,\r\n                    mx = self.lastFrozenColumnPixel - self.style.frozenMarkerBorderWidth,\r\n                    xHover = self.currentCell && self.currentCell.style === 'frozen-row-marker',\r\n                    yHover = self.currentCell && self.currentCell.style === 'frozen-column-marker';\r\n                self.ctx.lineWidth = self.style.frozenMarkerBorderWidth;\r\n                if (self.attributes.allowFreezingColumns) {\r\n                    self.ctx.fillStyle = yHover ? self.style.frozenMarkerHoverColor : self.style.frozenMarkerColor;\r\n                    self.ctx.strokeStyle = yHover ? self.style.frozenMarkerHoverBorderColor : self.style.frozenMarkerBorderColor;\r\n                    fillRect(mx, 0, self.style.frozenMarkerWidth, self.height);\r\n                    strokeRect(mx, 0, self.style.frozenMarkerWidth, self.height);\r\n                    self.visibleCells.unshift({\r\n                        x: mx,\r\n                        y: 0,\r\n                        height: self.height,\r\n                        width: self.style.frozenMarkerWidth + self.style.frozenMarkerBorderWidth,\r\n                        style: 'frozen-column-marker'\r\n                    });\r\n                }\r\n                if (self.attributes.allowFreezingRows) {\r\n                    self.ctx.fillStyle = xHover ? self.style.frozenMarkerHoverColor : self.style.frozenMarkerColor;\r\n                    self.ctx.strokeStyle = xHover ? self.style.frozenMarkerHoverBorderColor : self.style.frozenMarkerBorderColor;\r\n                    fillRect(0, my, self.width, self.style.frozenMarkerWidth);\r\n                    strokeRect(0, my, self.width, self.style.frozenMarkerWidth);\r\n                    self.visibleCells.unshift({\r\n                        x: 0,\r\n                        y: my,\r\n                        height: self.style.frozenMarkerWidth + self.style.frozenMarkerBorderWidth,\r\n                        width: self.width,\r\n                        style: 'frozen-row-marker'\r\n                    });\r\n                }\r\n                if (self.freezeMarkerPosition) {\r\n                    self.ctx.fillStyle = self.style.frozenMarkerActiveColor;\r\n                    self.ctx.strokeStyle = self.style.frozenMarkerActiveBorderColor;\r\n                    if (self.dragMode === 'frozen-column-marker') {\r\n                        fillRect(self.freezeMarkerPosition.x, 0, self.style.frozenMarkerWidth, self.height);\r\n                        strokeRect(self.freezeMarkerPosition.x, 0, self.style.frozenMarkerWidth, self.height);\r\n                    } else {\r\n                        fillRect(0, self.freezeMarkerPosition.y, self.width, self.style.frozenMarkerWidth);\r\n                        strokeRect(0, self.freezeMarkerPosition.y, self.width, self.style.frozenMarkerWidth);\r\n                    }\r\n                }\r\n            }\r\n            function drawPerfLines() {\r\n                if (!self.attributes.showPerformance) { return; }\r\n                var pw = 250,\r\n                    px = self.width - pw - self.style.scrollBarWidth - (self.style.scrollBarBorderWidth * 2),\r\n                    py = columnHeaderCellHeight,\r\n                    ph = 100;\r\n                if (scrollDebugCounters.length === 0) { scrollDebugCounters = fillArray(0, perfWindowSize, 1, function () { return [0, 0]; }); }\r\n                if (touchPPSCounters.length === 0) { touchPPSCounters = fillArray(0, perfWindowSize, 1, function () { return [0, 0]; }); }\r\n                if (entityCount.length === 0) { entityCount = fillArray(0, perfWindowSize, 1, 0); }\r\n                self.ctx.lineWidth = 0.5;\r\n                function dpl(name, perfArr, arrIndex, max, color, useAbs, rowIndex) {\r\n                    var v;\r\n                    drawPerfLine(pw, ph, px, py, perfArr, arrIndex, max, color, useAbs);\r\n                    self.ctx.fillStyle = color;\r\n                    fillRect(3 + px, py + 9 + (rowIndex * 11), 8, 8);\r\n                    self.ctx.fillStyle = self.style.debugPerfChartTextColor;\r\n                    v = arrIndex !== undefined ? perfArr[0][arrIndex] : perfArr[0];\r\n                    fillText(name + ' ' + (isNaN(v) ? 0 : v).toFixed(3), 14 + px, py + 16 + (rowIndex * 11));\r\n                }\r\n                self.ctx.textAlign = 'left';\r\n                self.ctx.font = self.style.debugFont;\r\n                self.ctx.fillStyle = self.style.debugPerfChartBackground;\r\n                fillRect(px, py, pw, ph);\r\n                [['Scroll Height', scrollDebugCounters, 0, self.scrollBox.scrollHeight, self.style.debugScrollHeightColor, false],\r\n                    ['Scroll Width', scrollDebugCounters, 1, self.scrollBox.scrollWidth, self.style.debugScrollWidthColor, false],\r\n                    ['Performance', perfCounters, undefined, 200, self.style.debugPerformanceColor, false],\r\n                    ['Entities', entityCount, undefined, 1500, self.style.debugEntitiesColor, false],\r\n                    ['TouchPPSX', touchPPSCounters, 0, 1000, self.style.debugTouchPPSXColor, true],\r\n                    ['TouchPPSY', touchPPSCounters, 1, 1000, self.style.debugTouchPPSYColor, true]\r\n                    ].forEach(function (i, index) {\r\n                    i.push(index);\r\n                    dpl.apply(null, i);\r\n                });\r\n                self.ctx.fillStyle = self.style.debugPerfChartBackground;\r\n                entityCount.pop();\r\n                entityCount.unshift(self.visibleCells.length);\r\n                scrollDebugCounters.pop();\r\n                scrollDebugCounters.unshift([self.scrollBox.scrollTop, self.scrollBox.scrollLeft]);\r\n                touchPPSCounters.pop();\r\n                touchPPSCounters.unshift([self.yPPS, self.xPPS]);\r\n            }\r\n            function drawDebug() {\r\n                self.ctx.save();\r\n                var d;\r\n                if (self.attributes.showPerformance || self.attributes.debug) {\r\n                    if (perfCounters.length === 0) { perfCounters = fillArray(0, perfWindowSize, 1, 0); }\r\n                    perfCounters.pop();\r\n                    perfCounters.unshift(performance.now() - p);\r\n                }\r\n                if (!self.attributes.debug) {\r\n                    self.ctx.restore();\r\n                    return;\r\n                }\r\n                self.ctx.font = self.style.debugFont;\r\n                d = {};\r\n                d.perf = (perfCounters.reduce(function (a, b) {\r\n                    return a + b;\r\n                }, 0) / Math.min(drawCount, perfCounters.length)).toFixed(1);\r\n                d.perfDelta = perfCounters[0].toFixed(1);\r\n                d.frozenColumnsWidth = getFrozenColumnsWidth();\r\n                d.htmlImages = Object.keys(self.htmlImageCache).length;\r\n                d.reorderObject = 'x: ' + (self.reorderObject || {columnIndex: 0}).columnIndex + ', y: ' + (self.reorderObject || {rowIndex: 0}).rowIndex;\r\n                d.reorderTarget = 'x: ' + (self.reorderTarget || {columnIndex: 0}).columnIndex + ', y: ' + (self.reorderTarget || {rowIndex: 0}).rowIndex;\r\n                d.scale = self.scale;\r\n                d.startScale = self.startScale;\r\n                d.scaleDelta = self.scaleDelta;\r\n                d.zoomDeltaStart = self.zoomDeltaStart;\r\n                d.touchLength = self.touchLength;\r\n                d.touches = 'y0: ' + (self.touchPosition || {y: 0}).y + ' y1: ' + (self.touchPosition1 || {y: 0}).y;\r\n                d.scrollBox = self.scrollBox.toString();\r\n                d.scrollIndex = 'x: ' + self.scrollIndexLeft + ', y: ' + self.scrollIndexTop;\r\n                d.scrollPixel = 'x: ' + self.scrollPixelLeft + ', y: ' + self.scrollPixelTop;\r\n                d.canvasOffset = 'x: ' + self.canvasOffsetLeft + ', y: ' + self.canvasOffsetTop;\r\n                d.touchDelta = 'x: ' + self.touchDelta.x + ', y: ' + self.touchDelta.y;\r\n                d.touchAnimateTo = 'x: ' + self.touchAnimateTo.x + ', y: ' + self.touchAnimateTo.y;\r\n                d.scrollAnimation = 'x: ' + self.scrollAnimation.x + ', y: ' + self.scrollAnimation.y;\r\n                d.touchPPS = 'x: ' + self.xPPS + ', y: ' + self.yPPS;\r\n                d.touchPPST = 'x: ' + self.xPPST + ', y: ' + self.yPPST;\r\n                d.touchDuration = self.touchDuration;\r\n                d.pointerLockPosition =  self.pointerLockPosition ?\r\n                        self.pointerLockPosition.x + ', ' + self.pointerLockPosition.y : '';\r\n                d.size = 'w: ' + self.width + ', h: ' + self.height;\r\n                d.mouse = 'x: ' + self.mouse.x + ', y: ' + self.mouse.y;\r\n                d.touch = !self.touchStart\r\n                    ? '' : 'x: ' + self.touchStart.x + ', y: ' + self.touchStart.y;\r\n                d.entities = self.visibleCells.length;\r\n                d.hasFocus = self.hasFocus;\r\n                d.dragMode = self.dragMode;\r\n                if (self.currentCell) {\r\n                    d.columnIndex = self.currentCell.columnIndex;\r\n                    d.rowIndex = self.currentCell.rowIndex;\r\n                    d.sortColumnIndex = self.currentCell.sortColumnIndex;\r\n                    d.sortRowIndex = self.currentCell.sortRowIndex;\r\n                    d.context = self.currentCell.context;\r\n                    d.dragContext = self.currentCell.dragContext;\r\n                    d.style = self.currentCell.style;\r\n                    d.type = self.currentCell.type;\r\n                }\r\n                self.ctx.textAlign = 'right';\r\n                self.ctx.fillStyle = self.style.debugBackgroundColor;\r\n                fillRect(0, 0, self.width, self.height);\r\n                Object.keys(d).forEach(function (key, index) {\r\n                    var m = key + ': ' + d[key],\r\n                        lh = 14;\r\n                    self.ctx.fillStyle = self.style.debugColor;\r\n                    fillText(m, w - 20, (self.attributes.showPerformance ? 140 : 24) + (index * lh));\r\n                });\r\n                self.ctx.restore();\r\n            }\r\n            self.ctx.save();\r\n            initDraw();\r\n            drawBackground();\r\n            drawFrozenRows();\r\n            drawRows();\r\n            drawActiveCell();\r\n            drawHeaders();\r\n            drawFrozenMarkers();\r\n            drawSelectionHandles();\r\n            drawReorderMarkers();\r\n            drawMoveMarkers();\r\n            drawBorder();\r\n            drawSelectionBorders();\r\n            if (checkScrollHeight) {\r\n                self.resize(true);\r\n            }\r\n            drawDebug();\r\n            drawPerfLines();\r\n            if (self.dispatchEvent('afterdraw', {})) { return; }\r\n            self.ctx.restore();\r\n        };\r\n    };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true, plusplus: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n    'use strict';\r\n    return function (self) {\r\n        var wheeling;\r\n        self.stopPropagation = function (e) { e.stopPropagation(); };\r\n        /**\r\n         * Adds an event listener to the given event.\r\n         * @memberof canvasDatagrid\r\n         * @name addEventListener\r\n         * @method\r\n         * @param {string} ev The name of the event to subscribe to.\r\n         * @param {function} fn The event procedure to execute when the event is raised.\r\n         */\r\n        self.addEventListener = function (ev, fn) {\r\n            self.events[ev] = self.events[ev] || [];\r\n            self.events[ev].unshift(fn);\r\n        };\r\n        /**\r\n         * Removes the given listener function from the given event.  Must be an actual reference to the function that was bound.\r\n         * @memberof canvasDatagrid\r\n         * @name removeEventListener\r\n         * @method\r\n         * @param {string} ev The name of the event to unsubscribe from.\r\n         * @param {function} fn The event procedure to execute when the event is raised.\r\n         */\r\n        self.removeEventListener = function (ev, fn) {\r\n            (self.events[ev] || []).forEach(function removeEachListener(sfn, idx) {\r\n                if (fn === sfn) {\r\n                    self.events[ev].splice(idx, 1);\r\n                }\r\n            });\r\n        };\r\n        /**\r\n         * Fires the given event, padding an event object to the event subscribers.\r\n         * @memberof canvasDatagrid\r\n         * @name dispatchEvent\r\n         * @method\r\n         * @param {number} ev The name of the event to dispatch.\r\n         * @param {number} e The event object.\r\n         */\r\n        self.dispatchEvent = function (ev, e) {\r\n            e = ev.type ? ev : (e || {});\r\n            ev = ev.type || ev;\r\n            var defaultPrevented;\r\n            function preventDefault() {\r\n                defaultPrevented = true;\r\n            }\r\n            if (!self.events[ev]) { return; }\r\n            self.events[ev].forEach(function dispatchEachEvent(fn) {\r\n                e.ctx = self.ctx;\r\n                e.preventDefault = preventDefault;\r\n                fn.apply(self.intf, [e]);\r\n            });\r\n            return defaultPrevented;\r\n        };\r\n        self.getRatio = function () {\r\n            return Math.min(self.attributes.maxPixelRatio, (window.devicePixelRatio || 1) /\r\n                (self.ctx.webkitBackingStorePixelRatio ||\r\n                    self.ctx.mozBackingStorePixelRatio ||\r\n                    self.ctx.msBackingStorePixelRatio ||\r\n                    self.ctx.oBackingStorePixelRatio ||\r\n                    self.ctx.backingStorePixelRatio || 1));\r\n        };\r\n        self.resize = function (drawAfterResize) {\r\n            if (!self.canvas) { return; }\r\n            var x,\r\n                v = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    height: 0,\r\n                    width: 0,\r\n                    style: 'vertical-scroll-bar'\r\n                },\r\n                n = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    height: 0,\r\n                    width: 0,\r\n                    style: 'horizontal-scroll-bar'\r\n                },\r\n                vb = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    height: 0,\r\n                    width: 0,\r\n                    style: 'vertical-scroll-box'\r\n                },\r\n                nb = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    height: 0,\r\n                    width: 0,\r\n                    style: 'horizontal-scroll-box'\r\n                },\r\n                co = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    height: 0,\r\n                    width: 0,\r\n                    isCorner: true,\r\n                    isScrollBoxCorner: true,\r\n                    style: 'scroll-box-corner'\r\n                },\r\n                m = (self.style.scrollBarBoxMargin * 2),\r\n                b = (self.style.scrollBarBorderWidth * 2),\r\n                d = self.style.scrollBarBoxMargin * 0.5,\r\n                sbw = self.style.scrollBarWidth + (self.style.scrollBarBorderWidth * 2),\r\n                ratio = self.getRatio(),\r\n                bm = self.style.gridBorderCollapse === 'collapse' ? 1 : 2,\r\n                cellBorder = self.style.cellBorderWidth * bm,\r\n                columnHeaderCellBorder = self.style.columnHeaderCellBorderWidth * bm,\r\n                dataHeight = 0,\r\n                dataWidth = 0,\r\n                dims,\r\n                l = (self.data || []).length,\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n                rowHeaderCellWidth = self.getRowHeaderCellWidth(),\r\n                ch = self.style.cellHeight,\r\n                s = self.getSchema();\r\n            // sets actual DOM canvas element\r\n            function checkScrollBoxVisibility() {\r\n                self.scrollBox.horizontalBarVisible = (self.style.width !== 'auto' && dataWidth > self.scrollBox.width && self.style.overflowX !== 'hidden')\r\n                    || self.style.overflowX === 'scroll';\r\n                self.scrollBox.horizontalBoxVisible = dataWidth > self.scrollBox.width;\r\n                self.scrollBox.verticalBarVisible = (self.style.height !== 'auto' && dataHeight > self.scrollBox.height && self.style.overflowY !== 'hidden')\r\n                    || self.style.overflowY === 'scroll';\r\n                self.scrollBox.verticalBoxVisible = dataHeight > self.scrollBox.height;\r\n            }\r\n            function setScrollBoxSize() {\r\n                self.scrollBox.width = self.width - rowHeaderCellWidth;\r\n                self.scrollBox.height = self.height - columnHeaderCellHeight;\r\n            }\r\n            function setCanvasSize() {\r\n                if (self.isChildGrid) {\r\n                    return;\r\n                }\r\n                dims = {\r\n                    // HACK +1 ? maybe it's a magic cell border?  Required to line up properly in auto height mode.\r\n                    height: columnHeaderCellHeight + dataHeight + cellBorder + 1,\r\n                    width: dataWidth + rowHeaderCellWidth + cellBorder\r\n                };\r\n                ['width', 'height'].forEach(function (dim) {\r\n                    //TODO: support inherit\r\n                    if (['auto', undefined].indexOf(self.style[dim]) !== -1\r\n                            && ['auto', undefined].indexOf(self.appliedInlineStyles[dim]) !== -1) {\r\n                        self.parentNodeStyle[dim] = dims[dim] + 'px';\r\n                    } else {\r\n                        self.parentNodeStyle[dim] = self.style[dim];\r\n                        if (self.isComponet) {\r\n                            self.canvas.style[dim] = self.style[dim];\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            self.scrollCache.x = [];\r\n            self.scrollCache.y = [];\r\n            for (x = 0; x < l; x += 1) {\r\n                self.scrollCache.y[x] = dataHeight;\r\n                dataHeight += (((self.sizes.rows[x] || ch) + (self.sizes.trees[x] || 0)) * self.scale)\r\n                    // HACK? if an expanded tree row is frozen it is necessary to add the tree row's height a second time.\r\n                    + (self.frozenRow > x ? (self.sizes.trees[x] || 0) : 0);\r\n            }\r\n            if (l > 1) {\r\n                self.scrollCache.y[x] = dataHeight;\r\n            }\r\n            dataWidth = s.reduce(function reduceSchema(accumulator, column, columnIndex) {\r\n                // intentional redefintion of column.  This causes scrollCache to be in the correct order\r\n                column = s[self.orders.columns[columnIndex]];\r\n                if (column.hidden) {\r\n                    self.scrollCache.x[columnIndex] = accumulator;\r\n                    return accumulator;\r\n                }\r\n                var va = accumulator + self.getColummnWidth(self.orders.columns[columnIndex]);\r\n                self.scrollCache.x[columnIndex] = va;\r\n                return va;\r\n            }, 0) || 0;\r\n            if (self.attributes.showNewRow) {\r\n                dataHeight += ch;\r\n            }\r\n            if (self.attributes.snapToRow) {\r\n              dataHeight += self.style.cellHeight;\r\n            }\r\n            setCanvasSize();\r\n            if (self.isChildGrid) {\r\n                self.width = self.parentNode.offsetWidth;\r\n                self.height = self.parentNode.offsetHeight;\r\n            } else if (self.height !== self.canvas.offsetHeight || self.width !== self.canvas.offsetWidth) {\r\n                self.height = self.canvas.offsetHeight;\r\n                self.width = self.canvas.offsetWidth;\r\n                self.canvasOffsetLeft = self.args.canvasOffsetLeft || 0;\r\n                self.canvasOffsetTop = self.args.canvasOffsetTop || 0;\r\n            }\r\n            /// calculate scroll bar dimensions\r\n            // non-controversial\r\n            self.scrollBox.top = columnHeaderCellHeight + columnHeaderCellBorder;\r\n            self.scrollBox.left = rowHeaderCellWidth;\r\n            // width and height of scroll box\r\n            setScrollBoxSize();\r\n            // is the data larger than the scroll box\r\n            checkScrollBoxVisibility();\r\n            // if the scroll box is visible, make room for it by expanding the size of the element\r\n            // if the other dimension is set to auto\r\n            if (self.scrollBox.horizontalBarVisible) {\r\n                if (self.style.height === 'auto' && !self.isChildGrid) {\r\n                    self.height += sbw;\r\n                }\r\n                dataHeight += sbw;\r\n                setCanvasSize();\r\n                setScrollBoxSize();\r\n                checkScrollBoxVisibility();\r\n            }\r\n            if (self.scrollBox.verticalBarVisible) {\r\n                if (self.style.width === 'auto' && !self.isChildGrid) {\r\n                    self.width += sbw;\r\n                }\r\n                dataWidth += sbw;\r\n                setCanvasSize();\r\n                setScrollBoxSize();\r\n                checkScrollBoxVisibility();\r\n            }\r\n            // set again after bar visibility checks\r\n            setScrollBoxSize();\r\n            self.scrollBox.scrollWidth = dataWidth - self.scrollBox.width;\r\n            self.scrollBox.scrollHeight = dataHeight - self.scrollBox.height;\r\n            self.scrollBox.widthBoxRatio = self.scrollBox.width / dataWidth;\r\n            self.scrollBox.scrollBoxWidth = self.scrollBox.width\r\n                * self.scrollBox.widthBoxRatio\r\n                - self.style.scrollBarWidth - b - d;\r\n            // TODO: This heightBoxRatio number is terribly wrong.\r\n            // They should be a result of the size of the grid/canvas?\r\n            // it being off causes the scroll bar to \"slide\" under\r\n            // the dragged mouse.\r\n            // https://github.com/TonyGermaneri/canvas-datagrid/issues/97\r\n            self.scrollBox.heightBoxRatio = (self.scrollBox.height - columnHeaderCellHeight) / dataHeight;\r\n            self.scrollBox.scrollBoxHeight = self.scrollBox.height\r\n                * self.scrollBox.heightBoxRatio\r\n                - self.style.scrollBarWidth - b - d;\r\n            self.scrollBox.scrollBoxWidth = Math.max(self.scrollBox.scrollBoxWidth, self.style.scrollBarBoxMinSize);\r\n            self.scrollBox.scrollBoxHeight = Math.max(self.scrollBox.scrollBoxHeight, self.style.scrollBarBoxMinSize);\r\n            // horizontal\r\n            n.x += rowHeaderCellWidth;\r\n            n.y += self.height - self.style.scrollBarWidth - d;\r\n            n.width = self.width - self.style.scrollBarWidth - rowHeaderCellWidth - d - m;\r\n            n.height = self.style.scrollBarWidth + self.style.scrollBarBorderWidth + d;\r\n            // horizontal box\r\n            nb.y = n.y + self.style.scrollBarBoxMargin;\r\n            nb.width = self.scrollBox.scrollBoxWidth;\r\n            nb.height = self.style.scrollBarBoxWidth;\r\n            // vertical\r\n            v.x += self.width - self.style.scrollBarWidth - self.style.scrollBarBorderWidth - d;\r\n            v.y += columnHeaderCellHeight;\r\n            v.width = self.style.scrollBarWidth + self.style.scrollBarBorderWidth + d;\r\n            v.height = self.height - columnHeaderCellHeight - self.style.scrollBarWidth - d - m;\r\n            // vertical box\r\n            vb.x = v.x + self.style.scrollBarBoxMargin;\r\n            vb.width = self.style.scrollBarBoxWidth;\r\n            vb.height = self.scrollBox.scrollBoxHeight;\r\n            // corner\r\n            co.x = n.x + n.width + m;\r\n            co.y = v.y + v.height + m;\r\n            co.width = self.style.scrollBarWidth + self.style.scrollBarBorderWidth;\r\n            co.height = self.style.scrollBarWidth + self.style.scrollBarBorderWidth;\r\n            self.scrollBox.entities = {\r\n                horizontalBar: n,\r\n                horizontalBox: nb,\r\n                verticalBar: v,\r\n                verticalBox: vb,\r\n                corner: co\r\n            };\r\n            self.scrollBox.bar = {\r\n                v: v,\r\n                h: n\r\n            };\r\n            self.scrollBox.box = {\r\n                v: vb,\r\n                h: nb\r\n            };\r\n            /// calculate page and dom elements\r\n            self.page = Math.max(1, self.visibleRows.length - 3 - self.attributes.pageUpDownOverlap);\r\n            // set canvas drawing related items\r\n            if (!self.isChildGrid) {\r\n                self.canvas.width = self.width * ratio;\r\n                self.canvas.height = self.height * ratio;\r\n                self.ctx.scale(ratio, ratio);\r\n            }\r\n            // resize any open dom elements (input/textarea)\r\n            self.resizeEditInput();\r\n            self.scroll(true);\r\n            if (drawAfterResize) {\r\n                self.draw(true);\r\n            }\r\n            self.dispatchEvent('resize', {});\r\n            return true;\r\n        };\r\n        self.scroll = function (dontDraw) {\r\n            var s = self.getSchema(),\r\n                l = (self.data || []).length,\r\n                ch = self.style.cellHeight;\r\n            // go too far in leaps, then get focused\r\n            self.scrollIndexTop = Math.floor((l * (self.scrollBox.scrollTop / self.scrollBox.scrollHeight)) - 100);\r\n            self.scrollIndexTop = Math.max(self.scrollIndexTop, 0);\r\n            self.scrollPixelTop = self.scrollCache.y[self.scrollIndexTop];\r\n            // sometimes the grid is rendered but the height is zero\r\n            if (self.scrollBox.scrollHeight === 0) {\r\n                self.scrollIndexTop = 0;\r\n            }\r\n            self.scrollPixelTop = 0;\r\n            self.scrollIndexLeft = self.frozenColumn;\r\n            self.scrollPixelLeft = 0;\r\n            while (self.scrollPixelTop < self.scrollBox.scrollTop && self.scrollIndexTop < self.data.length) {\r\n                // start on index +1 since index 0 was used in \"go too far\" section above\r\n                self.scrollIndexTop += 1;\r\n                self.scrollPixelTop = self.scrollCache.y[self.scrollIndexTop];\r\n            }\r\n            while (self.scrollPixelLeft < (self.scrollBox.scrollLeft + 1) && self.scrollIndexLeft < s.length) {\r\n                self.scrollPixelLeft = self.scrollCache.x[self.scrollIndexLeft];\r\n                self.scrollIndexLeft += 1;\r\n            }\r\n            if (s.length > 0) {\r\n                self.scrollIndexLeft = Math.max(self.scrollIndexLeft - 1, 0);\r\n                self.scrollPixelLeft -= self.getColummnWidth(self.orders.columns[self.scrollIndexLeft]);\r\n            }\r\n            if ((self.data || []).length > 0) {\r\n                self.scrollIndexTop = Math.max(self.scrollIndexTop - 1, 0);\r\n                self.scrollPixelTop = Math.max((self.scrollPixelTop\r\n                    - (\r\n                        self.data[self.scrollIndexTop] ? (self.sizes.rows[self.scrollIndexTop] || ch)\r\n                                + (self.sizes.trees[self.scrollIndexTop] || 0)\r\n                        : ch\r\n                    ) * self.scale), 0);\r\n            }\r\n            self.ellipsisCache = {};\r\n            if (!dontDraw) {\r\n                self.draw(true);\r\n            }\r\n            //TODO: figure out why this has to be delayed for child grids\r\n            //BUG: wheeling event on 3rd level hierarchy fails to move input box\r\n            requestAnimationFrame(self.resizeEditInput);\r\n            self.dispatchEvent('scroll', {top: self.scrollBox.scrollTop, left: self.scrollBox.scrollLeft});\r\n        };\r\n        self.mousemove = function (e, overridePos) {\r\n            if (self.contextMenu || self.input) {\r\n                return;\r\n            }\r\n            self.mouse = overridePos || self.getLayerPos(e);\r\n            var ctrl = (e.ctrlKey || e.metaKey || self.attributes.persistantSelectionMode),\r\n                i,\r\n                s = self.getSchema(),\r\n                dragBounds,\r\n                sBounds,\r\n                x = self.mouse.x,\r\n                y = self.mouse.y,\r\n                o = self.getCellAt(x, y),\r\n                delta,\r\n                ev = {NativeEvent: e, cell: o, x: x, y: y},\r\n                previousCell = self.currentCell;\r\n            clearTimeout(self.scrollTimer);\r\n            if (!self.isInGrid({x: x, y: y})) {\r\n                self.hasFocus = false;\r\n            }\r\n            if (self.dispatchEvent('mousemove', ev)) {\r\n                return;\r\n            }\r\n            if (o && self.currentCell) {\r\n                self.rowBoundaryCrossed = self.currentCell.rowIndex !== o.rowIndex;\r\n                self.columnBoundaryCrossed = self.currentCell.columnIndex !== o.columnIndex;\r\n                self.cellBoundaryCrossed = self.rowBoundaryCrossed || self.columnBoundaryCrossed;\r\n                ['row', 'column', 'cell'].forEach(function (prefix) {\r\n                    if (self[prefix + 'BoundaryCrossed']) {\r\n                        ev.cell = previousCell;\r\n                        self.dispatchEvent(prefix + 'mouseout', ev);\r\n                        ev.cell = o;\r\n                        self.dispatchEvent(prefix + 'mouseover', ev);\r\n                    }\r\n                });\r\n            }\r\n            self.currentCell = o;\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            self.hovers = {};\r\n            if (!self.draggingItem\r\n                    && o\r\n                    && self.scrollModes.indexOf(o.context) === -1) {\r\n                self.dragItem = o;\r\n                self.dragMode = o.dragContext;\r\n                self.cursor = o.context;\r\n                if (o.context === 'cell') {\r\n                    self.cursor = 'default';\r\n                    self.hovers = { rowIndex: o.rowIndex, columnIndex: o.columnIndex };\r\n                }\r\n                if ((self.selecting || self.reorderObject)\r\n                        && o.context === 'cell') {\r\n                    delta = {\r\n                        x: Math.abs(self.dragStart.x - x),\r\n                        y: Math.abs(self.dragStart.y - y)\r\n                    };\r\n                    if (self.dragStartObject.columnIndex !== -1 && e.shiftKey) {\r\n                        self.dragStartObject = {\r\n                            rowIndex: self.activeCell.rowIndex,\r\n                            columnIndex: self.activeCell.columnIndex\r\n                        };\r\n                    }\r\n                    dragBounds = {\r\n                        top: Math.min(self.dragStartObject.rowIndex, o.rowIndex),\r\n                        left: Math.min(self.dragStartObject.columnIndex, o.columnIndex),\r\n                        bottom: Math.max(self.dragStartObject.rowIndex, o.rowIndex),\r\n                        right: Math.max(self.dragStartObject.columnIndex, o.columnIndex)\r\n                    };\r\n                    if (self.dragStartObject.columnIndex === -1) {\r\n                        sBounds = self.getSelectionBounds();\r\n                        dragBounds.left = -1;\r\n                        dragBounds.right = s.length - 1;\r\n                        dragBounds.top = Math.min(sBounds.top, o.rowIndex);\r\n                        dragBounds.bottom = Math.max(sBounds.bottom, o.rowIndex);\r\n                    }\r\n                    if (self.dragStartObject.rowIndex !== o.rowIndex\r\n                                || self.dragStartObject.columnIndex !== o.columnIndex) {\r\n                        self.ignoreNextClick = true;\r\n                    }\r\n                    if (self.cellBoundaryCrossed || (delta.x === 0 && delta.y === 0) || (self.attributes.selectionMode === 'row')) {\r\n                        if (((self.attributes.selectionMode === 'row') || self.dragStartObject.columnIndex === -1)\r\n                                && self.rowBoundaryCrossed) {\r\n                            self.selectRow(o.rowIndex, ctrl, null, true);\r\n                        } else if (self.attributes.selectionMode !== 'row') {\r\n                            if (!self.dragAddToSelection && o.rowIndex !== undefined) {\r\n                                if (self.selections[o.rowIndex] && self.selections[o.rowIndex].indexOf(o.columnIndex) !== -1) {\r\n                                    self.selections[o.rowIndex].splice(self.selections[o.rowIndex].indexOf(o.columnIndex), 1);\r\n                                }\r\n                            } else {\r\n                                self.selections[o.rowIndex] = self.selections[o.rowIndex] || [];\r\n                                if (self.selections[o.rowIndex].indexOf(o.columnIndex) === -1) {\r\n                                    self.selections[o.rowIndex].push(o.columnIndex);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if ((!self.selectionBounds || (dragBounds.top !== self.selectionBounds.top\r\n                            || dragBounds.left !== self.selectionBounds.left\r\n                            || dragBounds.bottom !== self.selectionBounds.bottom\r\n                            || dragBounds.right !== self.selectionBounds.right)) && !ctrl) {\r\n                        self.selections = [];\r\n                        sBounds = dragBounds;\r\n                        if (self.attributes.selectionMode === 'row') {\r\n                            for (i = sBounds.top; i <= sBounds.bottom; i += 1) {\r\n                                self.selectRow(i, true, null, true);\r\n                            }\r\n                        } else if (dragBounds.top !== -1) {\r\n                            self.selectArea(sBounds, true);\r\n                        }\r\n                    }\r\n                    self.autoScrollZone(e, x, y, ctrl);\r\n                }\r\n            }\r\n            self.cellBoundaryCrossed = false;\r\n            self.rowBoundaryCrossed = false;\r\n            self.columnBoundaryCrossed = false;\r\n            self.draw(true);\r\n        };\r\n        self.click = function (e, overridePos) {\r\n            var i,\r\n                startingBounds = JSON.stringify(self.getSelectionBounds()),\r\n                ctrl = (e.ctrlKey || e.metaKey || self.attributes.persistantSelectionMode),\r\n                pos = overridePos || self.getLayerPos(e);\r\n            self.currentCell = self.getCellAt(pos.x, pos.y);\r\n            if (self.currentCell.grid !== undefined) {\r\n                return;\r\n            }\r\n            function checkSelectionChange() {\r\n                var ev, sb = self.getSelectionBounds();\r\n                if (startingBounds === JSON.stringify(sb)) {\r\n                    return;\r\n                }\r\n                ev = {\r\n                    selections: self.selections,\r\n                    selectionBounds: self.getSelectionBounds()\r\n                };\r\n                Object.defineProperty(ev, 'selectedData', {\r\n                    get: function () {\r\n                        return self.getSelectedData();\r\n                    }\r\n                });\r\n                self.dispatchEvent('selectionchanged', ev);\r\n            }\r\n            if (self.input) {\r\n                self.endEdit();\r\n            }\r\n            if (self.ignoreNextClick) {\r\n                self.ignoreNextClick = false;\r\n                return;\r\n            }\r\n            i = self.currentCell;\r\n            if (self.dispatchEvent('click', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            if (['rowHeaderCell', 'columnHeaderCell'].indexOf(self.currentCell.style) === -1 && !ctrl) {\r\n                self.setActiveCell(i.columnIndex, i.rowIndex);\r\n            }\r\n            if (self.currentCell.context === 'cell') {\r\n                if (self.currentCell.style === 'cornerCell') {\r\n                    self.selectAll();\r\n                    self.draw();\r\n                    checkSelectionChange();\r\n                    return;\r\n                }\r\n                if (self.currentCell.style === 'columnHeaderCell') {\r\n                    if (self.attributes.columnHeaderClickBehavior === 'sort') {\r\n                        if (self.orderBy === i.header.name) {\r\n                            self.orderDirection = self.orderDirection === 'asc' ? 'desc' : 'asc';\r\n                        } else {\r\n                            self.orderDirection = 'asc';\r\n                        }\r\n                        self.order(i.header.name, self.orderDirection);\r\n                        checkSelectionChange();\r\n                        return;\r\n                    }\r\n                    if (self.attributes.columnHeaderClickBehavior === 'select') {\r\n                        self.selectColumn(i.header.index, ctrl, e.shiftKey);\r\n                        self.draw();\r\n                        return;\r\n                    }\r\n                }\r\n                self.selections[i.rowIndex] = self.selections[i.rowIndex] || [];\r\n                if (((self.attributes.selectionMode === 'row') || self.currentCell.style === 'rowHeaderCell')) {\r\n                    if (self.currentCell.style === 'rowHeaderCell'\r\n                            && self.attributes.tree && pos.x > 0\r\n                            && pos.x - self.currentCell.x < self.style.treeArrowWidth\r\n                            + self.style.treeArrowMarginLeft\r\n                            + self.style.treeArrowMarginRight + self.style.treeArrowClickRadius\r\n                            && pos.y - self.currentCell.y < self.style.treeArrowHeight\r\n                            + self.style.treeArrowMarginTop + self.style.treeArrowClickRadius\r\n                            && pos.y > 0) {\r\n                        self.toggleTree(i.rowIndex);\r\n                        return;\r\n                    }\r\n                }\r\n                if (e.shiftKey && !ctrl) {\r\n                    self.selectionBounds = self.getSelectionBounds();\r\n                    self.selectArea(undefined, false);\r\n                }\r\n            }\r\n            checkSelectionChange();\r\n            self.draw(true);\r\n        };\r\n        self.dragResizeColumn = function (e) {\r\n            var pos, x, y;\r\n            pos = self.getLayerPos(e);\r\n            x = self.resizingStartingWidth + pos.x - self.dragStart.x;\r\n            y = self.resizingStartingHeight + pos.y - self.dragStart.y;\r\n            if (x < self.style.minColumnWidth) {\r\n                x = self.style.minColumnWidth;\r\n            }\r\n            if (y < self.style.minRowHeight) {\r\n                y = self.style.minRowHeight;\r\n            }\r\n            if (self.dispatchEvent('resizecolumn', {x: x, y: y, draggingItem: self.draggingItem})) { return false; }\r\n            if (self.scrollBox.scrollLeft > self.scrollBox.scrollWidth - self.attributes.resizeScrollZone\r\n                    && self.dragMode === 'ew-resize') {\r\n                self.resize(true);\r\n                self.scrollBox.scrollLeft += x;\r\n            }\r\n            if (self.dragMode === 'ew-resize') {\r\n                self.sizes.columns[self.draggingItem.header.style === 'rowHeaderCell'\r\n                       ? 'cornerCell' : self.draggingItem.sortColumnIndex] = x;\r\n                if (['rowHeaderCell', 'cornerCell'].indexOf(self.draggingItem.header.style) !== -1) {\r\n                    self.resize(true);\r\n                }\r\n                self.resizeChildGrids();\r\n                return;\r\n            }\r\n            if (self.dragMode === 'ns-resize') {\r\n                if (self.draggingItem.rowOpen) {\r\n                    self.sizes.trees[self.draggingItem.rowIndex] = y;\r\n                } else if (self.attributes.globalRowResize) {\r\n                    self.style.cellHeight = y;\r\n                } else {\r\n                    self.sizes.rows[self.draggingItem.rowIndex] = y;\r\n                }\r\n                self.dispatchEvent('resizerow', {row: y});\r\n                self.resizeChildGrids();\r\n                return;\r\n            }\r\n            self.ellipsisCache = {};\r\n        };\r\n        self.stopDragResize = function () {\r\n            self.resize();\r\n            document.body.removeEventListener('mousemove', self.dragResizeColumn, false);\r\n            document.body.removeEventListener('mouseup', self.stopDragResize, false);\r\n            self.setStorageData();\r\n            self.draw(true);\r\n            self.ignoreNextClick = true;\r\n        };\r\n        self.scrollGrid = function (e) {\r\n            var pos = self.getLayerPos(e);\r\n            if (self.attributes.scrollPointerLock && self.pointerLockPosition\r\n                    && ['horizontal-scroll-box', 'vertical-scroll-box'].indexOf(self.scrollStartMode) !== -1) {\r\n                self.pointerLockPosition.x += e.movementX;\r\n                self.pointerLockPosition.y += e.movementY;\r\n                self.pointerLockPosition.x = Math.min(self.width - self.style.scrollBarWidth, Math.max(0, self.pointerLockPosition.x));\r\n                self.pointerLockPosition.y = Math.min(self.height - self.style.scrollBarWidth, Math.max(0, self.pointerLockPosition.y));\r\n                pos = self.pointerLockPosition;\r\n            }\r\n            self.scrollMode = self.getCellAt(pos.x, pos.y).context;\r\n            if (self.scrollMode === 'horizontal-scroll-box' && self.scrollStartMode !== 'horizontal-scroll-box') {\r\n                self.scrollStartMode = 'horizontal-scroll-box';\r\n                self.dragStart = pos;\r\n                self.scrollStart.left = self.scrollBox.scrollLeft;\r\n                clearTimeout(self.scrollTimer);\r\n                return;\r\n            }\r\n            if (self.scrollMode === 'vertical-scroll-box' && self.scrollStartMode !== 'vertical-scroll-box') {\r\n                self.scrollStartMode = 'vertical-scroll-box';\r\n                self.dragStart = pos;\r\n                self.scrollStart.top = self.scrollBox.scrollTop;\r\n                clearTimeout(self.scrollTimer);\r\n                return;\r\n            }\r\n            if (self.scrollStartMode === 'vertical-scroll-box'\r\n                    && self.scrollMode !== 'vertical-scroll-box') {\r\n                self.scrollMode = 'vertical-scroll-box';\r\n            }\r\n            if (self.scrollStartMode === 'horizontal-scroll-box'\r\n                    && self.scrollMode !== 'horizontal-scroll-box') {\r\n                self.scrollMode = 'horizontal-scroll-box';\r\n            }\r\n            clearTimeout(self.scrollTimer);\r\n            if (self.scrollModes.indexOf(self.scrollMode) === -1) {\r\n                return;\r\n            }\r\n            if (self.scrollMode === 'vertical-scroll-box') {\r\n                self.scrollBox.scrollTop = self.scrollStart.top + ((pos.y - self.dragStart.y)\r\n                    / self.scrollBox.heightBoxRatio);\r\n            } else if (self.scrollMode === 'vertical-scroll-top') {\r\n                self.scrollBox.scrollTop -= (self.page * self.style.cellHeight);\r\n                self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n            } else if (self.scrollMode === 'vertical-scroll-bottom') {\r\n                self.scrollBox.scrollTop += (self.page * self.style.cellHeight);\r\n                self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n            }\r\n            if (self.scrollMode === 'horizontal-scroll-box') {\r\n                self.scrollBox.scrollLeft = self.scrollStart.left + ((pos.x - self.dragStart.x)\r\n                    / self.scrollBox.widthBoxRatio);\r\n            } else if (self.scrollMode === 'horizontal-scroll-right') {\r\n                self.scrollBox.scrollLeft += self.attributes.selectionScrollIncrement;\r\n                self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n            } else if (self.scrollMode === 'horizontal-scroll-left') {\r\n                self.scrollBox.scrollLeft -= self.attributes.selectionScrollIncrement;\r\n                self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n            }\r\n        };\r\n        self.stopScrollGrid = function () {\r\n            clearTimeout(self.scrollTimer);\r\n            if (document.exitPointerLock) {\r\n                document.exitPointerLock();\r\n            }\r\n            document.removeEventListener('mousemove', self.scrollGrid, false);\r\n        };\r\n        self.dragReorder = function (e) {\r\n            var pos, x, y,\r\n                columReorder = self.dragMode === 'column-reorder',\r\n                rowReorder = self.dragMode === 'row-reorder';\r\n            pos = self.getLayerPos(e);\r\n            x = pos.x - self.dragStart.x;\r\n            y = pos.y - self.dragStart.y;\r\n            if (!self.attributes.allowColumnReordering && columReorder) {\r\n                return;\r\n            }\r\n            if (!self.attributes.allowRowReordering && rowReorder) {\r\n                return;\r\n            }\r\n            if (self.dispatchEvent('reordering', {\r\n                    NativeEvent: e,\r\n                    source: self.dragStartObject,\r\n                    target: self.currentCell,\r\n                    dragMode: self.dragMode\r\n                })) {\r\n                return;\r\n            }\r\n            if (Math.abs(x) > self.attributes.reorderDeadZone || Math.abs(y) > self.attributes.reorderDeadZone) {\r\n                self.reorderObject = self.draggingItem;\r\n                self.reorderTarget = self.currentCell;\r\n                self.reorderObject.dragOffset = {\r\n                    x: x,\r\n                    y: y\r\n                };\r\n                self.autoScrollZone(e, columReorder ? pos.x : -1, rowReorder ? pos.y : -1, false);\r\n            }\r\n        };\r\n        self.stopDragReorder = function (e) {\r\n            var oIndex,\r\n                tIndex,\r\n                cr = {\r\n                    'row-reorder': self.orders.rows,\r\n                    'column-reorder': self.orders.columns\r\n                },\r\n                i = {\r\n                    'row-reorder': 'rowIndex',\r\n                    'column-reorder': 'sortColumnIndex'\r\n                }[self.dragMode];\r\n            document.body.removeEventListener('mousemove', self.dragReorder, false);\r\n            document.body.removeEventListener('mouseup', self.stopDragReorder, false);\r\n            if (self.reorderObject\r\n                    && self.reorderTarget\r\n                    && ((self.dragMode === 'column-reorder' && self.reorderTarget.sortColumnIndex > -1\r\n                        && self.reorderTarget.sortColumnIndex < self.getSchema().length)\r\n                    || (self.dragMode === 'row-reorder' && self.reorderTarget.rowIndex > -1\r\n                        && self.reorderTarget.rowIndex < self.data.length))\r\n                    && self.reorderObject[i] !== self.reorderTarget[i]\r\n                    && !self.dispatchEvent('reorder', {\r\n                        NativeEvent: e,\r\n                        source: self.reorderObject,\r\n                        target: self.reorderTarget,\r\n                        dragMode: self.dragMode\r\n                    })) {\r\n                self.ignoreNextClick = true;\r\n                oIndex = cr[self.dragMode].indexOf(self.reorderObject[i]);\r\n                tIndex = cr[self.dragMode].indexOf(self.reorderTarget[i]);\r\n                cr[self.dragMode].splice(oIndex, 1);\r\n                cr[self.dragMode].splice(tIndex, 0, self.reorderObject[i]);\r\n                if(self.dragMode === 'column-reorder') {\r\n                  self.orders.columns = cr[self.dragMode];\r\n                } else {\r\n                  self.orders.rows = cr[self.dragMode];\r\n                }\r\n                self.resize();\r\n                self.setStorageData();\r\n            }\r\n            self.reorderObject = undefined;\r\n            self.reorderTarget = undefined;\r\n            self.draw(true);\r\n        };\r\n        self.dragMove = function (e) {\r\n            if (self.dispatchEvent('moving', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            var pos = self.getLayerPos(e);\r\n            self.moveOffset = {\r\n                x: self.currentCell.columnIndex - self.dragStartObject.columnIndex,\r\n                y: self.currentCell.rowIndex - self.dragStartObject.rowIndex\r\n            };\r\n            if (Math.abs(pos.x) > self.attributes.reorderDeadZone || Math.abs(pos.y) > self.attributes.reorderDeadZone) {\r\n                setTimeout(function () {\r\n                    self.autoScrollZone(e, pos.x, pos.y, false);\r\n                }, 1);\r\n            }\r\n        };\r\n        self.stopDragMove = function (e) {\r\n            document.body.removeEventListener('mousemove', self.dragMove, false);\r\n            document.body.removeEventListener('mouseup', self.stopDragMove, false);\r\n            var b = self.getSelectionBounds();\r\n            if (self.dispatchEvent('endmove', {NativeEvent: e, cell: self.currentCell})) {\r\n                self.movingSelection = undefined;\r\n                self.moveOffset = undefined;\r\n                self.draw(true);\r\n                return;\r\n            }\r\n            if (self.moveOffset) {\r\n                self.moveTo(self.movingSelection, b.left + self.moveOffset.x, b.top + self.moveOffset.y);\r\n                self.moveSelection(self.moveOffset.x, self.moveOffset.y);\r\n            }\r\n            self.movingSelection = undefined;\r\n            self.moveOffset = undefined;\r\n            self.draw(true);\r\n        };\r\n        self.freezeMove = function (e) {\r\n            if (self.dispatchEvent('freezemoving', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            var pos = self.getLayerPos(e);\r\n            self.ignoreNextClick = true;\r\n            self.freezeMarkerPosition = pos;\r\n            if (self.currentCell && self.currentCell.rowIndex !== undefined && self.dragMode === 'frozen-row-marker') {\r\n                self.scrollBox.scrollTop = 0;\r\n                self.frozenRow = self.currentCell.rowIndex + 1;\r\n            }\r\n            if (self.currentCell && self.currentCell.columnIndex !== undefined && self.dragMode === 'frozen-column-marker') {\r\n                self.scrollBox.scrollLeft = 0;\r\n                self.frozenColumn = self.currentCell.columnIndex + 1;\r\n            }\r\n            if (Math.abs(pos.x) > self.attributes.reorderDeadZone || Math.abs(pos.y) > self.attributes.reorderDeadZone) {\r\n                setTimeout(function () {\r\n                    self.autoScrollZone(e, pos.x, pos.y, false);\r\n                }, 1);\r\n            }\r\n        };\r\n        self.stopFreezeMove = function (e) {\r\n            document.body.removeEventListener('mousemove', self.freezeMove, false);\r\n            document.body.removeEventListener('mouseup', self.stopFreezeMove, false);\r\n            self.freezeMarkerPosition = undefined;\r\n            if (self.dispatchEvent('endfreezemove', {NativeEvent: e, cell: self.currentCell})) {\r\n                self.frozenRow = self.startFreezeMove.x;\r\n                self.frozenColumn = self.startFreezeMove.y;\r\n                self.draw(true);\r\n                return;\r\n            }\r\n            self.draw(true);\r\n        };\r\n        self.mousedown = function (e, overridePos) {\r\n            self.lastMouseDownTarget = e.target;\r\n            if (self.dispatchEvent('mousedown', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            if (e.button === 2 || self.input) { return; }\r\n            var ctrl = (e.ctrlKey || e.metaKey),\r\n                move = /-move/.test(self.dragMode),\r\n                freeze = /frozen-row-marker|frozen-column-marker/.test(self.dragMode),\r\n                resize = /-resize/.test(self.dragMode);\r\n            self.dragStart = overridePos || self.getLayerPos(e);\r\n            self.scrollStart = {\r\n                left: self.scrollBox.scrollLeft,\r\n                top: self.scrollBox.scrollTop\r\n            };\r\n            self.dragStartObject = self.getCellAt(self.dragStart.x, self.dragStart.y);\r\n            self.dragAddToSelection = !self.dragStartObject.selected;\r\n            if (!ctrl && !e.shiftKey && !/(vertical|horizontal)-scroll-(bar|box)/\r\n                    .test(self.dragStartObject.context)\r\n                    && self.currentCell\r\n                    && !self.currentCell.isColumnHeader\r\n                    && !move\r\n                    && !freeze\r\n                    && !resize) {\r\n                self.selections = [];\r\n            }\r\n            if (self.dragStartObject.isGrid) {\r\n                return;\r\n            }\r\n            if (self.scrollModes.indexOf(self.dragStartObject.context) !== -1) {\r\n                self.scrollMode = self.dragStartObject.context;\r\n                self.scrollStartMode = self.dragStartObject.context;\r\n                self.scrollGrid(e);\r\n                if (self.attributes.scrollPointerLock\r\n                        && ['horizontal-scroll-box', 'vertical-scroll-box'].indexOf(self.scrollStartMode) !== -1) {\r\n                    self.pointerLockPosition = {\r\n                        x: self.dragStart.x,\r\n                        y: self.dragStart.y\r\n                    };\r\n                    self.canvas.requestPointerLock();\r\n                }\r\n                document.addEventListener('mousemove', self.scrollGrid, false);\r\n                document.addEventListener('mouseup', self.stopScrollGrid, false);\r\n                self.ignoreNextClick = true;\r\n                return;\r\n            }\r\n            if (self.dragMode === 'cell') {\r\n                self.selecting = true;\r\n                if ((self.attributes.selectionMode === 'row' || self.dragStartObject.columnIndex === -1)\r\n                        && self.dragStartObject.rowIndex > -1) {\r\n                    self.selectRow(self.dragStartObject.rowIndex, ctrl, null);\r\n                } else if (self.attributes.selectionMode !== 'row') {\r\n                    self.mousemove(e);\r\n                }\r\n                return;\r\n            }\r\n            if (move) {\r\n                self.draggingItem = self.dragItem;\r\n                self.movingSelection = self.selections.concat([]);\r\n                self.dragging = self.dragStartObject;\r\n                if (self.dispatchEvent('beginmove', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n                document.body.addEventListener('mousemove', self.dragMove, false);\r\n                document.body.addEventListener('mouseup', self.stopDragMove, false);\r\n                return self.mousemove(e);\r\n            }\r\n            if (freeze) {\r\n                self.draggingItem = self.dragItem;\r\n                self.startFreezeMove = {\r\n                    x: self.frozenRow,\r\n                    y: self.frozenColumn\r\n                };\r\n                if (self.dispatchEvent('beginfreezemove', {NativeEvent: e})) { return; }\r\n                document.body.addEventListener('mousemove', self.freezeMove, false);\r\n                document.body.addEventListener('mouseup', self.stopFreezeMove, false);\r\n                return self.mousemove(e);\r\n            }\r\n            if (resize) {\r\n                self.draggingItem = self.dragItem;\r\n                if (self.draggingItem.rowOpen) {\r\n                    self.resizingStartingHeight = self.sizes.trees[self.draggingItem.rowIndex];\r\n                } else {\r\n                    self.resizingStartingHeight = self.sizes.rows[self.draggingItem.rowIndex] || self.style.cellHeight;\r\n                }\r\n                self.resizingStartingWidth = self.sizes.columns[self.draggingItem.header.style === 'rowHeaderCell'\r\n                       ? 'cornerCell' : self.draggingItem.sortColumnIndex] || self.draggingItem.width;\r\n                document.body.addEventListener('mousemove', self.dragResizeColumn, false);\r\n                document.body.addEventListener('mouseup', self.stopDragResize, false);\r\n                return;\r\n            }\r\n            if (['row-reorder', 'column-reorder'].indexOf(self.dragMode) !== -1) {\r\n                self.draggingItem = self.dragStartObject;\r\n                document.body.addEventListener('mousemove', self.dragReorder, false);\r\n                document.body.addEventListener('mouseup', self.stopDragReorder, false);\r\n                return;\r\n            }\r\n        };\r\n        self.mouseup = function (e) {\r\n            clearTimeout(self.scrollTimer);\r\n            self.cellBoundaryCrossed = true;\r\n            self.rowBoundaryCrossed = true;\r\n            self.columnBoundaryCrossed = true;\r\n            self.selecting = undefined;\r\n            self.draggingItem = undefined;\r\n            self.dragStartObject = undefined;\r\n            if (self.dispatchEvent('mouseup', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus && e.target !== self.canvas) {\r\n                return;\r\n            }\r\n            if (self.currentCell && self.currentCell.grid !== undefined) {\r\n                return;\r\n            }\r\n            if (self.contextMenu || self.input) { return; }\r\n            if (self.dragStart && self.isInGrid(self.dragStart)) {\r\n                self.controlInput.focus();\r\n            }\r\n            e.preventDefault();\r\n        };\r\n        // gets the horizontal adjacent cells as well as first/last based on column visibility\r\n        self.getAdjacentCells = function () {\r\n            var x,\r\n                i,\r\n                s = self.getSchema(),\r\n                o = {};\r\n            for (x = 0; x < s.length; x += 1) {\r\n                i = self.orders.columns[x];\r\n                if (!s[i].hidden) {\r\n                    if (o.first === undefined) {\r\n                        o.first = x;\r\n                        o.left = x;\r\n                    }\r\n                    o.last = x;\r\n                    if (x > self.activeCell.columnIndex && o.right === undefined) {\r\n                        o.right = x;\r\n                    }\r\n                    if (x < self.activeCell.columnIndex) {\r\n                        o.left = x;\r\n                    }\r\n                }\r\n            }\r\n            if (o.right === undefined) {\r\n                o.right = o.last;\r\n            }\r\n            return o;\r\n        };\r\n        self.keydown = function (e) {\r\n            var i,\r\n                ev,\r\n                adjacentCells = self.getAdjacentCells(),\r\n                x = self.activeCell.columnIndex,\r\n                y = self.activeCell.rowIndex,\r\n                ctrl = (e.ctrlKey || e.metaKey),\r\n                last = self.data.length - 1,\r\n                s = self.getSchema(),\r\n                cols = s.length - 1;\r\n            if (self.dispatchEvent('keydown', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            if (self.attributes.showNewRow) {\r\n                last += 1;\r\n            }\r\n            if (e.keyCode === 9) {\r\n                e.preventDefault();\r\n            }\r\n            // esc\r\n            if (e.keyCode === 27) {\r\n                self.selections = [];\r\n                self.draw(true);\r\n            // ctrl + a\r\n            } else if (ctrl && e.keyCode === 65) {\r\n                self.selectAll();\r\n            //ArrowDown\r\n            } else if (e.keyCode === 40) {\r\n                y += 1;\r\n            //ArrowUp\r\n            } else if (e.keyCode === 38) {\r\n                y -= 1;\r\n            //ArrowLeft Tab\r\n            } else if (e.keyCode === 37 || (e.shiftKey && e.keyCode === 9)) {\r\n                x = adjacentCells.left;\r\n            //ArrowRight Tab\r\n            } else if (e.keyCode === 39 || (!e.shiftKey && e.keyCode === 9)) {\r\n                x = adjacentCells.right;\r\n            //PageUp\r\n            } else if (e.keyCode === 33) {\r\n                y -= self.page;\r\n                e.preventDefault();\r\n            //PageDown\r\n            } else if (e.keyCode === 34) {\r\n                y += self.page;\r\n                e.preventDefault();\r\n            //Home ArrowUp\r\n            } else if (e.keyCode === 36 || (ctrl && e.keyCode === 38)) {\r\n                y = 0;\r\n            //End ArrowDown\r\n            } else if (e.keyCode === 35 || (ctrl && e.keyCode === 40)) {\r\n                y = self.data.length - 1;\r\n            //ArrowRight\r\n            } else if (ctrl && e.keyCode === 39) {\r\n                x = adjacentCells.last;\r\n            //ArrowLeft\r\n            } else if (ctrl && e.keyCode === 37) {\r\n                x = adjacentCells.first;\r\n            }\r\n            //Enter\r\n            if (e.keyCode === 13) {\r\n                return self.beginEditAt(x, y, e);\r\n            }\r\n            //Space\r\n            if (e.keyCode === 32) {\r\n                self.selections = [];\r\n                self.selections[Math.max(y, 0)] = [];\r\n                self.selections[Math.max(y, 0)].push(x);\r\n                self.selectionBounds = self.getSelectionBounds();\r\n                if (self.attributes.selectionMode === 'row') {\r\n                    for (i = self.selectionBounds.top; i <= self.selectionBounds.bottom; i += 1) {\r\n                        self.selectRow(i, ctrl, null, true);\r\n                    }\r\n                } else {\r\n                    self.selectArea(undefined, ctrl);\r\n                }\r\n                e.preventDefault();\r\n                self.draw(true);\r\n                return;\r\n            }\r\n            if (x < 0 || Number.isNaN(x)) {\r\n                x = adjacentCells.first;\r\n            }\r\n            if (y > last) {\r\n                y = last;\r\n            }\r\n            if (y < 0 || Number.isNaN(y)) {\r\n                y = 0;\r\n            }\r\n            if (x > cols) {\r\n                x = adjacentCells.last;\r\n            }\r\n            // TODO - most likley some column order related bugs in key based selection\r\n            // Arrows\r\n            if (e.shiftKey && [37, 38, 39, 40].indexOf(e.keyCode) !== -1) {\r\n                self.selections[Math.max(y, 0)] = self.selections[Math.max(y, 0)] || [];\r\n                self.selections[Math.max(y, 0)].push(x);\r\n                self.selectionBounds = self.getSelectionBounds();\r\n                self.selectArea(undefined, ctrl);\r\n                self.draw(true);\r\n            }\r\n            if (x !== self.activeCell.columnIndex || y !== self.activeCell.rowIndex) {\r\n                self.scrollIntoView(\r\n                  x !== self.activeCell.columnIndex ? x : undefined,\r\n                  y !== self.activeCell.rowIndex && !Number.isNaN(y) ? y : undefined\r\n                );\r\n\r\n                self.setActiveCell(x, y);\r\n                if (!e.shiftKey && self.attributes.selectionFollowsActiveCell) {\r\n                    if (!ctrl) {\r\n                        self.selections = [];\r\n                    }\r\n                    self.selections[y] = self.selections[y] || [];\r\n                    self.selections[y].push(x);\r\n                    ev = {\r\n                        selectedData: self.getSelectedData(),\r\n                        selections: self.selections,\r\n                        selectionBounds: self.getSelectionBounds()\r\n                    };\r\n                    Object.defineProperty(ev, 'selectedData', {\r\n                        get: function () {\r\n                            return self.getSelectedData();\r\n                        }\r\n                    });\r\n                    self.dispatchEvent('selectionchanged', ev);\r\n                }\r\n                self.draw(true);\r\n            }\r\n        };\r\n        self.keyup = function (e) {\r\n            if (self.dispatchEvent('keyup', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n        };\r\n        self.keypress = function (e) {\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            if (self.dispatchEvent('keypress', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n        };\r\n        self.dblclick = function (e) {\r\n            if (self.dispatchEvent('dblclick', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            if (self.currentCell.context === 'ew-resize'\r\n                    && self.currentCell.style === 'columnHeaderCell') {\r\n                self.fitColumnToValues(self.currentCell.header.name);\r\n            } else if (self.currentCell.context === 'ew-resize'\r\n                    && self.currentCell.style === 'cornerCell') {\r\n                self.autosize();\r\n            } else if (['cell', 'activeCell'].indexOf(self.currentCell.style) !== -1) {\r\n                self.beginEditAt(self.currentCell.columnIndex, self.currentCell.rowIndex);\r\n            }\r\n        };\r\n        self.scrollWheel = function (e) {\r\n            var l,\r\n                t,\r\n                ev = e,\r\n                deltaX = e.deltaX === undefined ? e.NativeEvent.deltaX : e.deltaX,\r\n                deltaY = e.deltaY === undefined ? e.NativeEvent.deltaY : e.deltaY,\r\n                deltaMode = e.deltaMode === undefined ? e.NativeEvent.deltaMode : e.deltaMode;\r\n            if (wheeling) {\r\n                return;\r\n            }\r\n            if (self.dispatchEvent('wheel', {NativeEvent: e})) {\r\n                return;\r\n            }\r\n            var e = e.NativeEvent || e;\r\n            self.touchHaltAnimation = true;\r\n            l = self.scrollBox.scrollLeft;\r\n            t = self.scrollBox.scrollTop;\r\n            if (self.hasFocus) {\r\n                //BUG Issue 42: https://github.com/TonyGermaneri/canvas-datagrid/issues/42\r\n                //https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n                if (deltaMode === 1) {\r\n                    // line mode = 17 pixels per line\r\n                    deltaY = deltaY * 17;\r\n                }\r\n                if ((self.scrollBox.scrollTop  < self.scrollBox.scrollHeight && deltaY > 0)\r\n                        || (self.scrollBox.scrollLeft < self.scrollBox.scrollWidth && deltaX > 0)\r\n                        || (self.scrollBox.scrollTop > 0 && deltaY < 0)\r\n                        || (self.scrollBox.scrollLeft > 0 && deltaX < 0)) {\r\n                    ev.preventDefault(e);\r\n                }\r\n                wheeling = setTimeout(function () {\r\n                    wheeling = undefined;\r\n                    self.scrollBox.scrollTo(deltaX + l, deltaY + t);\r\n                }, 1);\r\n            }\r\n        };\r\n        self.pasteItem = function (clipData, x, y, mimeType) {\r\n            var l, s = self.getVisibleSchema(), yi = y - 1, sel = [];\r\n            function normalizeRowData(importingRow, existingRow, offsetX, schema, mimeType, rowIndex) {\r\n                var r = existingRow;\r\n                if (!Array.isArray(importingRow) && importingRow !== null && typeof importingRow === 'object') {\r\n                    importingRow = Object.keys(importingRow).map(function (colKey) {\r\n                        return importingRow[colKey];\r\n                    });\r\n                }\r\n                if (/^text\\/html/.test(mimeType)) {\r\n                    importingRow = importingRow.substring(4, importingRow.length - 5).split('</td><td>');\r\n                }\r\n                if (typeof importingRow === 'string') {\r\n                    importingRow = [importingRow];\r\n                }\r\n                sel[rowIndex] = [];\r\n                importingRow.forEach(function (cellData, colIndex) {\r\n                    var cName = schema[colIndex + offsetX].name;\r\n                    if (importingRow[colIndex] === undefined || importingRow[colIndex] === null) {\r\n                        r[cName] = existingRow[cName];\r\n                        return;\r\n                    }\r\n                    sel[rowIndex].push(colIndex + offsetX);\r\n                    r[cName] = importingRow[colIndex];\r\n                });\r\n                return r;\r\n            }\r\n            if (/^text\\/html/.test(mimeType)) {\r\n                if (!/^(<meta[^>]+>)?<table>/.test(clipData.substring(0, 29))) {\r\n                    console.warn('Unrecognized HTML format.  HTML must be a simple table, e.g.: <table><tr><td>data</td></tr></table>.  Data with the mime type text/html not in this format will not be imported as row data.');\r\n                    return;\r\n                }\r\n                // strip table beginning and ending off, then split at rows\r\n                clipData = clipData.substring(clipData.indexOf('<table><tr>') + 11, clipData.length - 13).split('</tr><tr>');\r\n                // ditch any headers on the table\r\n                clipData = clipData.filter(function (row) {\r\n                    return !/^<th>|^<thead>/.test(row);\r\n                });\r\n            } else {\r\n                clipData = clipData.split('\\n');\r\n            }\r\n            l = clipData.length;\r\n            clipData.forEach(function (rowData) {\r\n                yi += 1;\r\n                var i = self.orders.rows[yi];\r\n                self.data[i] = normalizeRowData(rowData, self.data[i], x, s, mimeType, i);\r\n            });\r\n            self.selections = sel;\r\n            return l;\r\n        };\r\n        self.getNextVisibleColumnIndex = function (visibleColumnIndex) {\r\n            var x, s = self.getVisibleSchema();\r\n            for (x = 0; x < s.length; x += 1) {\r\n                if (s[x].columnIndex === visibleColumnIndex) {\r\n                    return s[x + 1].columnIndex;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n        self.getVisibleColumnIndexOf = function (columnIndex) {\r\n            var x, s = self.getVisibleSchema();\r\n            for (x = 0; x < s.length; x += 1) {\r\n                if (s[x].columnIndex === columnIndex) {\r\n                    return x;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n        self.paste = function (e) {\r\n            var d;\r\n            function getItem(dti) {\r\n                var type = dti.type;\r\n                dti.getAsString(function (s) {\r\n                    self.pasteItem(s, self.getVisibleColumnIndexOf(self.activeCell.columnIndex), self.activeCell.rowIndex, type);\r\n                    self.draw();\r\n                });\r\n            }\r\n            d = Array.prototype.filter.call(e.clipboardData.items, function (dti) {\r\n                return dti.type === 'text/html';\r\n            })[0] || Array.prototype.filter(function (dti) {\r\n                return dti.type === 'text/csv';\r\n            })[0] || Array.prototype.filter(function (dti) {\r\n                return dti.type === 'text/plain';\r\n            })[0];\r\n            if (!d) {\r\n                console.warn('Cannot find supported clipboard data type.  Supported types are text/html, text/csv, text/plain.');\r\n                return;\r\n            }\r\n            getItem(d);\r\n        };\r\n        self.cut = function (e) {\r\n            self.copy(e);\r\n            self.forEachSelectedCell(function (data, index, colName) {\r\n                data[index][colName] = '';\r\n            });\r\n        };\r\n        self.copy = function (e) {\r\n            if (self.dispatchEvent('copy', {NativeEvent: e})) { return; }\r\n            if (!self.hasFocus || !e.clipboardData) { return; }\r\n            var t,\r\n                d,\r\n                data = (self.data || []),\r\n                tableRows = [],\r\n                textRows = [],\r\n                outputHeaders = {},\r\n                outputHeaderKeys,\r\n                sData = self.getSelectedData(),\r\n                s = self.getSchema();\r\n            function htmlSafe(v) {\r\n                return v.replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n            }\r\n            function fCopyCell(v) {\r\n                v = v === null || v === undefined ? '' : v;\r\n                return '<td>' + (typeof v === 'string' ? htmlSafe(v) : v) + '</td>';\r\n            }\r\n            function addHeaders(headers, useHtml) {\r\n                if (!s.length || headers.length < 2) { return ''; }\r\n                var h = [];\r\n                if (useHtml) {\r\n                    h.push('<tr>');\r\n                }\r\n                s.forEach(function (column, columnIndex) {\r\n                    // intentional redefinition of column\r\n                    column = s[self.orders.columns[columnIndex]];\r\n                    if (!column.hidden && headers.indexOf(column.name) !== -1) {\r\n                        var ev = {NativeEvent: e, column: column};\r\n                        if(self.dispatchEvent('copyonschema', ev)) {\r\n                            column = ev.column;\r\n                        }\r\n\r\n                        var hVal = (column.name || column.title) || '';\r\n                        if (useHtml) {\r\n                            h.push('<th>' + htmlSafe(hVal) + '</th>');\r\n                        } else {\r\n                            h.push('\"' + hVal.replace(/\"/g, '\"\"') + '\"');\r\n                        }\r\n                    }\r\n                });\r\n                h.push(useHtml ? '</tr>' : '\\n');\r\n                return h.join(useHtml ? '' : ',');\r\n            }\r\n            function addCellValue(val, trRow, textRow, column) {\r\n                // escape strings\r\n                if (val !== null\r\n                        && val !== false\r\n                        && val !== undefined\r\n                        && val.replace) {\r\n                    trRow.push(fCopyCell(val));\r\n                    textRow.push('\"' + val.replace(/\"/g, '\"\"') + '\"');\r\n                    return;\r\n                }\r\n                if (val !== undefined) {\r\n                    textRow.push(val);\r\n                    trRow.push(fCopyCell(val));\r\n                    return;\r\n                }\r\n                // issue #66\r\n                textRow.push('');\r\n                trRow.push('<td>&nbsp;</td>');\r\n            }\r\n            if (sData.length > 0) {\r\n                sData.forEach(function (row) {\r\n                    var rowKeys = Object.keys(row);\r\n                    if (row) {\r\n                        var trRow = [],\r\n                            textRow = [],\r\n                            sSorted = [];\r\n                        // HACK: https://github.com/TonyGermaneri/canvas-datagrid/issues/181\r\n                        // I can't use sort here or O(1), so hacks\r\n                        s.forEach(function (column, columnIndex) {\r\n                            sSorted.push(s[self.orders.columns[columnIndex]]);\r\n                        });\r\n                        sSorted.forEach(function (column, columnIndex) {\r\n                            if (rowKeys.indexOf(column.name) !== -1) {\r\n                                outputHeaders[column.name] = true;\r\n                                // escape strings\r\n                                addCellValue(row[column.name], trRow, textRow, column);\r\n                            }\r\n                        });\r\n                        tableRows.push(trRow.join(''));\r\n                        textRows.push(textRow.join(','));\r\n                    }\r\n                });\r\n                outputHeaderKeys = Object.keys(outputHeaders);\r\n                t = addHeaders(outputHeaderKeys) + textRows.join('\\n');\r\n                d = '<table>' + addHeaders(outputHeaderKeys, true) + '<tr>' + tableRows.join('</tr><tr>') + '</tr></table>';\r\n                if (outputHeaderKeys.length === 1) {\r\n                    // if there was only one cell selected, remove the quotes from the string\r\n                    t = t.substring(1, t.length -1);\r\n                }\r\n                e.clipboardData.setData('text/html', d);\r\n                e.clipboardData.setData('text/plain', t);\r\n                e.clipboardData.setData('text/csv', t);\r\n                e.clipboardData.setData('application/json', JSON.stringify(sData));\r\n                e.preventDefault();\r\n            }\r\n        };\r\n        return;\r\n    };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true, plusplus: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n    'use strict';\r\n    return function (self) {\r\n        var touchTimerMs = 50,\r\n            debounceTouchMove,\r\n            touchMoving,\r\n            touchScrollTimeout;\r\n        self.scrollAnimation = {};\r\n        self.touchDelta = {};\r\n        self.touchAnimateTo = {};\r\n        self.animationFrames = 0;\r\n        self.getTouchPos = function (e, touchIndex) {\r\n            var t = touchIndex ? e.touches[touchIndex] : e.touches[0],\r\n                rect = self.canvas.getBoundingClientRect(),\r\n                pos;\r\n            if (!t) { return; }\r\n            pos = {\r\n                x: t.clientX - rect.left,\r\n                y: t.clientY - rect.top\r\n            };\r\n            if (self.isChildGrid) {\r\n                pos.x -= self.canvasOffsetLeft;\r\n                pos.y -= self.canvasOffsetTop;\r\n            }\r\n            return {\r\n                x: pos.x,\r\n                y: pos.y,\r\n                rect: rect\r\n            };\r\n        };\r\n        // shamelessly stolen from from https://gist.github.com/gre/1650294\r\n        self.easingFunctions = {\r\n            linear: function (t) { return t; },\r\n            easeInQuad: function (t) { return t * t; },\r\n            easeOutQuad: function (t) { return t * (2 - t); },\r\n            easeInOutQuad: function (t) { return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; },\r\n            easeInCubic: function (t) { return t * t * t; },\r\n            easeOutCubic: function (t) { return (--t) * t * t + 1; },\r\n            easeInOutCubic: function (t) { return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; },\r\n            easeInQuart: function (t) { return t * t * t * t; },\r\n            easeOutQuart: function (t) { return 1 - (--t) * t * t * t; },\r\n            easeInOutQuart: function (t) { return t < 0.5 ? 8 * t  * t  * t * t : 1 - 8 * (--t) * t * t * t; },\r\n            easeInQuint: function (t) { return t * t * t * t * t; },\r\n            easeOutQuint: function (t) { return 1 + (--t) * t *  t * t * t; },\r\n            easeInOutQuint: function (t) { return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t; }\r\n        };\r\n        self.easing = function (t, b, c, d) {\r\n            return c * self.easingFunctions[self.attributes.touchEasingMethod](t / d) + b;\r\n        };\r\n        self.calculatePPSTimed = function () {\r\n            self.xPPST = -((self.touchDelta.x - self.touchSigmaTimed.x) / (self.touchDelta.t - self.touchSigmaTimed.t));\r\n            self.yPPST = -((self.touchDelta.y - self.touchSigmaTimed.y) / (self.touchDelta.t - self.touchSigmaTimed.t));\r\n            self.touchSigmaTimed = {\r\n                x: self.touchDelta.x,\r\n                y: self.touchDelta.y,\r\n                t: performance.now()\r\n            };\r\n        };\r\n        self.calculatePPS = function () {\r\n            self.xPPS = -((self.touchDelta.x - self.touchSigma.x) / (self.touchDelta.t - self.touchSigma.t));\r\n            self.yPPS = -((self.touchDelta.y - self.touchSigma.y) / (self.touchDelta.t - self.touchSigma.t));\r\n            self.touchSigma = {\r\n                x: self.touchDelta.x,\r\n                y: self.touchDelta.y,\r\n                t: performance.now()\r\n            };\r\n        };\r\n        self.touchEndAnimation = function () {\r\n            if (!self.canvas || !self.scrollBox.scrollTo) { return requestAnimationFrame(self.touchEndAnimation); }\r\n            var n = performance.now(),\r\n                d = self.attributes.touchReleaseAnimationDurationMs,\r\n                t;\r\n            t = n - self.touchDelta.t;\r\n            self.animationFrames += 1;\r\n            self.scrollAnimation.x = self.easing(t, self.touchDelta.scrollLeft, self.touchAnimateTo.x, d);\r\n            self.scrollAnimation.y = self.easing(t, self.touchDelta.scrollTop, self.touchAnimateTo.y, d);\r\n            if (t > d || (self.scrollAnimation.y === self.scrollBox.scrollTop\r\n                    && self.scrollAnimation.x === self.scrollBox.scrollLeft) || self.stopAnimation) {\r\n                return;\r\n            }\r\n            self.scrollBox.scrollTo(self.scrollAnimation.x, self.scrollAnimation.y);\r\n            requestAnimationFrame(self.touchEndAnimation);\r\n        };\r\n        self.touchEditCell = function (cell) {\r\n            self.beginEditAt(cell.columnIndex, cell.rowIndex);\r\n        };\r\n        self.touchCell = function (e) {\r\n            return function () {\r\n                clearInterval(self.calculatePPSTimer);\r\n                var i, pos = self.getTouchPos(e);\r\n                if (Math.abs(self.touchDelta.x) + Math.abs(self.touchDelta.y) < self.attributes.touchDeadZone) {\r\n                    i = self.getCellAt(pos.x, pos.y);\r\n                    if (!i) { return; }\r\n                    if (self.touchingCell && self.touchingCell.rowIndex === i.rowIndex\r\n                            && self.touchingCell.columnIndex === i.columnIndex) {\r\n                        self.touchEditCell(i);\r\n                        return;\r\n                    }\r\n                    if (self.input && self.input.editCell) {\r\n                        self.endEdit();\r\n                    }\r\n                    self.touchingCell = i;\r\n                    self.selectArea({\r\n                        top: i.rowIndex,\r\n                        bottom: i.rowIndex,\r\n                        left: i.columnIndex,\r\n                        right: i.columnIndex\r\n                    });\r\n                    self.draw(true);\r\n                }\r\n            };\r\n        };\r\n        self.touchstart = function (e) {\r\n            if (e.changedTouches[0]) {\r\n                self.touchStart = self.getTouchPos(e);\r\n                self.startingCell = self.getCellAt(self.touchStart.x, self.touchStart.y, true);\r\n            }\r\n            if (self.dispatchEvent('touchstart', {NativeEvent: e, cell: self.startingCell})) { return; }\r\n            self.disposeContextMenu();\r\n            clearInterval(self.calculatePPSTimer);\r\n            clearTimeout(self.touchContextTimeout);\r\n            self.touchStartEvent = e;\r\n            self.stopAnimation = true;\r\n            self.animationFrames = 0;\r\n            self.stopPropagation(e);\r\n            e.preventDefault();\r\n            if (e.touches.length === 1 && e.changedTouches[0] && !self.zoomAltered) {\r\n                self.touchLength = 1;\r\n                self.touchStart = self.touchStart || self.touchStart1;\r\n                self.touchScrollStart = {\r\n                    x: self.scrollBox.scrollLeft,\r\n                    y: self.scrollBox.scrollTop,\r\n                    t: performance.now()\r\n                };\r\n                self.touchDelta = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    scrollLeft: self.scrollBox.scrollLeft,\r\n                    scrollTop: self.scrollBox.scrollTop,\r\n                    t: self.touchScrollStart.t\r\n                };\r\n                self.touchSigma = {\r\n                    x: self.touchDelta.x,\r\n                    y: self.touchDelta.y,\r\n                    t: self.touchDelta.t\r\n                };\r\n                self.touchSigmaTimed = {\r\n                    x: self.touchDelta.x,\r\n                    y: self.touchDelta.y,\r\n                    t: self.touchDelta.t\r\n                };\r\n                self.touchContextTimeout = setTimeout(function () {\r\n                    self.contextmenuEvent(e, self.touchStart);\r\n                }, self.attributes.touchContextMenuTimeMs);\r\n                self.calculatePPSTimer = setInterval(self.calculatePPSTimed, touchTimerMs);\r\n                if (self.startingCell && (self.startingCell.isGrid || ['tree', 'inherit'].indexOf(self.startingCell.context) !== -1)) {\r\n                    self.hasFocus = false;\r\n                    return;\r\n                }\r\n                self.hasFocus = true;\r\n                if (self.startingCell.isHeader) {\r\n                    if (self.startingCell.isRowHeader) {\r\n                        self.selectArea({\r\n                            top: self.startingCell.rowIndex,\r\n                            bottom: self.startingCell.rowIndex,\r\n                            left: 0,\r\n                            right: self.getVisibleSchema().length - 1,\r\n                        });\r\n                        self.draw(true);\r\n                    } else if (self.startingCell.isColumnHeader) {\r\n                        if (self.attributes.columnHeaderClickBehavior === 'sort') {\r\n                            if (self.orderBy === self.startingCell.header.name) {\r\n                                self.orderDirection = self.orderDirection === 'asc' ? 'desc' : 'asc';\r\n                            } else {\r\n                                self.orderDirection = 'asc';\r\n                            }\r\n                            self.order(self.startingCell.header.name, self.orderDirection);\r\n                        }\r\n                        if (self.attributes.columnHeaderClickBehavior === 'select') {\r\n                            self.selectArea({\r\n                                top: 0,\r\n                                bottom: self.data.length - 1,\r\n                                left: self.startingCell.columnIndex,\r\n                                right: self.startingCell.columnIndex,\r\n                            });\r\n                            self.draw(true);\r\n                        }\r\n                    }\r\n                    self.touchEndEvents(e);\r\n                    return;\r\n                }\r\n            }\r\n            if (self.zoomAltered) { return; }\r\n            document.body.addEventListener('touchmove', self.touchmove, {passive: false});\r\n            document.body.addEventListener('touchend', self.touchend, false);\r\n            document.body.addEventListener('touchcancel', self.touchcancel, false);\r\n            self.draw(true);\r\n        };\r\n        self.touchSelect = function (cell, handleType) {\r\n            if (cell.rowIndex === undefined || cell.columnIndex === undefined) { return; }\r\n            self.touchSelecting = true;\r\n            var bounds = self.getSelectionBounds();\r\n            if (handleType === 'selection-handle-bl'\r\n                    && cell.rowIndex >= bounds.top\r\n                    && cell.columnIndex <= bounds.right) {\r\n                bounds.bottom = cell.rowIndex;\r\n                bounds.left = cell.columnIndex;\r\n            } else if (handleType === 'selection-handle-tl'\r\n                    && cell.rowIndex <= bounds.bottom\r\n                    && cell.columnIndex <= bounds.right) {\r\n                bounds.top = cell.rowIndex;\r\n                bounds.left = cell.columnIndex;\r\n            } else if (handleType === 'selection-handle-tr'\r\n                    && cell.rowIndex <= bounds.bottom\r\n                    && cell.columnIndex >= bounds.left) {\r\n                bounds.top = cell.rowIndex;\r\n                bounds.right = cell.columnIndex;\r\n            } else if (handleType === 'selection-handle-br'\r\n                    && cell.rowIndex >= bounds.top\r\n                    && cell.columnIndex >= bounds.left) {\r\n                bounds.bottom = cell.rowIndex;\r\n                bounds.right = cell.columnIndex;\r\n            }\r\n            if (self.attributes.selectionMode === 'row' || cell.rowIndex === -1) {\r\n                bounds.left = 0;\r\n                bounds.right = self.getSchema().length - 1;\r\n            } else {\r\n                bounds.left = Math.max(0, bounds.left);\r\n            }\r\n            self.selectArea(bounds);\r\n            self.draw(true);\r\n        };\r\n        function touchMove(e) {\r\n            var ch, rw, rScrollZone, lScrollZone, bScrollZone, tScrollZone, sbw, t1, t2;\r\n            if (self.dispatchEvent('beforetouchmove', {NativeEvent: e})) { return; }\r\n            clearTimeout(touchScrollTimeout);\r\n            if (e.changedTouches[0]) {\r\n                self.touchPosition = self.getTouchPos(e);\r\n            }\r\n            if (e.changedTouches[1]) {\r\n                self.touchPosition1 = self.getTouchPos(e, 1);\r\n            }\r\n            if (Math.abs(self.touchDelta.x) + Math.abs(self.touchDelta.y) > self.attributes.touchDeadZone) {\r\n                clearTimeout(self.touchContextTimeout);\r\n            }\r\n            if (e.touches.length === 2 && self.touchPosition && self.touchPosition1) {\r\n                t1 = self.touchPosition.y;\r\n                t2 = self.touchPosition1.y;\r\n                if (!self.zoomDeltaStart) {\r\n                    self.zoomDeltaStart = Math.abs(t1 - t2);\r\n                    self.startScale = self.scale;\r\n                }\r\n                self.touchLength = 2;\r\n                self.scaleDelta = self.zoomDeltaStart - Math.abs(t1 - t2);\r\n                self.scale = self.startScale - (self.scaleDelta * self.attributes.touchZoomSensitivity);\r\n                self.scale = Math.min(Math.max(self.scale, self.attributes.touchZoomMin), self.attributes.touchZoomMax);\r\n                self.zoomAltered = true;\r\n                self.resize(true);\r\n                self.resizeChildGrids();\r\n                return;\r\n            }\r\n            if (self.zoomAltered) { return; }\r\n            self.touchLength = 1;\r\n            self.touchPosition = self.touchPosition || self.touchPosition1;\r\n            ch = self.getColumnHeaderCellHeight();\r\n            rw = self.getRowHeaderCellWidth();\r\n            rScrollZone = self.width - self.style.scrollBarWidth - self.touchPosition.x < self.attributes.selectionScrollZone;\r\n            lScrollZone = self.touchPosition.x - rw < self.attributes.selectionScrollZone;\r\n            bScrollZone = self.height - self.style.scrollBarWidth - self.touchPosition.y < self.attributes.selectionScrollZone;\r\n            tScrollZone = self.touchPosition.y - ch < self.attributes.selectionScrollZone;\r\n            sbw = self.style.scrollBarWidth;\r\n            function touchScroll() {\r\n                var x = self.scrollBox.scrollLeft,\r\n                    y = self.scrollBox.scrollTop;\r\n                x += (rScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                y += (bScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                y -= (tScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                x -= (lScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                self.scrollBox.scrollTo(x, y);\r\n                touchScrollTimeout = setTimeout(touchScroll, self.attributes.scrollRepeatRate);\r\n            }\r\n            e.stopPropagation();\r\n            self.touchDelta = {\r\n                x: self.touchPosition.x - self.touchStart.x,\r\n                y: self.touchPosition.y - self.touchStart.y,\r\n                scrollLeft: self.scrollBox.scrollLeft,\r\n                scrollTop: self.scrollBox.scrollTop,\r\n                t: performance.now()\r\n            };\r\n            self.currentCell = self.getCellAt(self.touchPosition.x, self.touchPosition.y);\r\n            self.dispatchEvent('touchmove', {NativeEvent: e, cell: self.currentCell});\r\n            self.calculatePPS();\r\n            self.touchDuration = performance.now() - self.touchScrollStart.t;\r\n            self.stopAnimation = true;\r\n            self.animationFrames = 0;\r\n            if (self.touchSelecting && (rScrollZone || lScrollZone || tScrollZone || bScrollZone)) {\r\n                touchScroll();\r\n            }\r\n            if (/vertical-scroll-/.test(self.startingCell.style)) {\r\n                self.scrollBox.scrollTop = self.scrollBox.scrollHeight\r\n                    * ((self.touchPosition.y - ch - sbw) / (self.scrollBox.height - sbw - ch));\r\n                return;\r\n            }\r\n            if (/horizontal-scroll-/.test(self.startingCell.style)) {\r\n                self.scrollBox.scrollLeft = self.scrollBox.scrollWidth\r\n                    * ((self.touchPosition.x - rw - sbw) / (self.scrollBox.width - sbw - rw));\r\n                return;\r\n            }\r\n            if (/selection-handle-/.test(self.startingCell.style)) {\r\n                self.touchSelect(self.currentCell, self.startingCell.style);\r\n                return;\r\n            }\r\n            self.scrollBox.scrollTo(self.touchScrollStart.x - self.touchDelta.x,\r\n                self.touchScrollStart.y - self.touchDelta.y);\r\n        };\r\n        self.touchmove = function (e) {\r\n            if (touchMoving) {\r\n                return;\r\n            }\r\n            requestAnimationFrame(function () {\r\n                touchMoving = true;\r\n                touchMove(e);\r\n                touchMoving = false;\r\n            });\r\n        };\r\n        self.touchEndEvents = function (e) {\r\n            self.zoomDeltaStart = undefined;\r\n            self.touchSelecting = false;\r\n            clearInterval(self.touchScrollTimeout);\r\n            clearInterval(self.touchContextTimeout);\r\n            clearInterval(self.calculatePPSTimer);\r\n            e.stopPropagation();\r\n            document.body.removeEventListener('touchmove', self.touchmove, {passive: false});\r\n            document.body.removeEventListener('touchend', self.touchend, false);\r\n            document.body.removeEventListener('touchcancel', self.touchcancel, false);\r\n        };\r\n        self.touchend = function (e) {\r\n            if (self.dispatchEvent('touchend', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            self.zoomDeltaStart = undefined;\r\n            if (e.changedTouches[0]) {\r\n                self.touchPosition = undefined;\r\n            }\r\n            if (e.changedTouches[1]) {\r\n                self.touchPosition1 = undefined;\r\n            }\r\n            if (self.zoomAltered) {\r\n                if (e.touches.length === 0) {\r\n                    self.zoomAltered = false;\r\n                }\r\n                return;\r\n            }\r\n            var dz = Math.abs(self.touchDelta.x) + Math.abs(self.touchDelta.y) < self.attributes.touchDeadZone;\r\n            if (isNaN(self.xPPS)) {\r\n                self.xPPS = 0;\r\n            }\r\n            if (isNaN(self.yPPS)) {\r\n                self.yPPS = 0;\r\n            }\r\n            if (isNaN(self.xPPST)) {\r\n                self.xPPST = 0;\r\n            }\r\n            if (isNaN(self.yPPST)) {\r\n                self.yPPST = 0;\r\n            }\r\n            self.touchAnimateTo.x = self.xPPS * self.attributes.touchReleaseAcceleration;\r\n            self.touchAnimateTo.y = self.yPPS * self.attributes.touchReleaseAcceleration;\r\n            self.calculatePPSTimed();\r\n            if (dz && !self.contextMenu) {\r\n                self.touchCell(self.touchStartEvent)();\r\n            } else if (self.animationFrames === 0\r\n                    && (Math.abs(self.xPPST) > self.attributes.scrollAnimationPPSThreshold\r\n                        || Math.abs(self.yPPST) > self.attributes.scrollAnimationPPSThreshold)\r\n                    && !/-scroll-/.test(self.startingCell.style)\r\n                    && !dz) {\r\n                self.stopAnimation = false;\r\n                self.touchEndAnimation();\r\n            }\r\n            self.touchEndEvents(e);\r\n        };\r\n        self.touchcancel = function (e) {\r\n            if (self.dispatchEvent('touchcancel', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            self.touchEndEvents(e);\r\n        };\r\n    };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals HTMLElement: false, Reflect: false, define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n    'use strict';\r\n    return function (self, ctor) {\r\n        self.scale = 1;\r\n        self.orders = {\r\n            rows: [],\r\n            columns: []\r\n        };\r\n        self.appliedInlineStyles = {};\r\n        self.cellGridAttributes = {};\r\n        self.treeGridAttributes = {};\r\n        self.visibleRowHeights = [];\r\n        self.hasFocus = false;\r\n        self.activeCell = {\r\n            columnIndex: 0,\r\n            rowIndex: 0\r\n        };\r\n        self.innerHTML = '';\r\n        self.storageName = 'canvasDataGrid';\r\n        self.invalidSearchExpClass = 'canvas-datagrid-invalid-search-regExp';\r\n        self.localStyleLibraryStorageKey = 'canvas-datagrid-user-style-library';\r\n        self.dataType = 'application/x-canvas-datagrid';\r\n        self.orderBy = null;\r\n        self.orderDirection = 'asc';\r\n        self.orderings = {\r\n            columns: [],\r\n            add: function (orderBy, orderDirection, sortFunction) {\r\n                self.orderings.columns = self.orderings.columns.filter(function (col) {\r\n                    return col.orderBy !== orderBy;\r\n                });\r\n                self.orderings.columns.push({\r\n                    orderBy: orderBy,\r\n                    orderDirection: orderDirection,\r\n                    sortFunction: sortFunction\r\n                });\r\n            },\r\n            sort: function () {\r\n                self.orderings.columns.forEach(function (col) {\r\n                    self.data.sort(col.sortFunction(col.orderBy, col.orderDirection));\r\n                });\r\n            }\r\n        };\r\n        self.columnFilters = {};\r\n        self.filters = {};\r\n        self.frozenRow = 0;\r\n        self.frozenColumn = 0;\r\n        self.ellipsisCache = {};\r\n        self.scrollCache = { x: [], y: [] };\r\n        self.scrollBox = {};\r\n        self.visibleRows = [];\r\n        self.visibleCells = [];\r\n        self.sizes = {\r\n            rows: {},\r\n            columns: {},\r\n            trees: {}\r\n        };\r\n        self.currentFilter = function () {\r\n            return true;\r\n        };\r\n        self.selections = [];\r\n        self.hovers = {};\r\n        self.attributes = {};\r\n        self.style = {};\r\n        self.formatters = {};\r\n        self.sorters = {};\r\n        self.parsers = {};\r\n        self.schemaHashes = {};\r\n        self.events = {};\r\n        self.changes = [];\r\n        self.scrollIndexTop = 0;\r\n        self.scrollPixelTop = 0;\r\n        self.scrollIndexLeft = 0;\r\n        self.scrollPixelLeft = 0;\r\n        self.childGrids = {};\r\n        self.openChildren = {};\r\n        self.scrollModes = [\r\n            'vertical-scroll-box',\r\n            'vertical-scroll-top',\r\n            'vertical-scroll-bottom',\r\n            'horizontal-scroll-box',\r\n            'horizontal-scroll-right',\r\n            'horizontal-scroll-left'\r\n        ];\r\n        self.componentL1Events = {};\r\n        self.eventNames = ['afterdraw', 'afterrendercell', 'attributechanged', 'beforebeginedit',\r\n            'beforecreatecellgrid', 'beforedraw', 'beforeendedit', 'beforerendercell', 'beforerendercellgrid',\r\n            'beginedit', 'cellmouseout', 'cellmouseover', 'click', 'collapsetree', 'contextmenu', 'copy',\r\n            'datachanged', 'dblclick', 'endedit', 'expandtree', 'formatcellvalue', 'keydown', 'keypress',\r\n            'keyup', 'mousedown', 'mousemove', 'mouseup', 'newrow', 'ordercolumn', 'rendercell', 'rendercellgrid',\r\n            'renderorderbyarrow', 'rendertext', 'rendertreearrow', 'reorder', 'reordering', 'resize',\r\n            'resizecolumn', 'resizerow', 'schemachanged', 'scroll', 'selectionchanged', 'stylechanged',\r\n            'touchcancel', 'touchend', 'touchmove', 'touchstart', 'wheel'];\r\n        self.mouse = { x: 0, y: 0};\r\n        self.getSelectedData = function (expandToRow) {\r\n            var d = [], s = self.getSchema(), l = self.data.length;\r\n            if (l === 0) { return []; }\r\n            self.selections.forEach(function (row, index) {\r\n                if (!row) { return; }\r\n                if (index === l) { return; }\r\n                if (row.length === 0) {\r\n                    d[index] = null;\r\n                    return;\r\n                }\r\n                d[index] = {};\r\n                row.forEach(function (col) {\r\n                    var orderedIndex;\r\n                    if (col === -1 || !s[col]) { return; }\r\n                    orderedIndex = self.orders.columns[col];\r\n                    if (!expandToRow && s[orderedIndex].hidden) { return; }\r\n                    if (self.data[index]) {\r\n                        d[index][s[orderedIndex].name] = self.data[index][s[orderedIndex].name];\r\n                    }\r\n                });\r\n            });\r\n            return d;\r\n        };\r\n        self.getColumnHeaderCellHeight = function () {\r\n            if (!self.attributes.showColumnHeaders) { return 0; }\r\n            return ((self.sizes.rows[-1] || self.style.columnHeaderCellHeight) * self.scale);\r\n        };\r\n        self.getRowHeaderCellWidth = function () {\r\n            if (!self.attributes.showRowHeaders) { return 0; }\r\n            return (self.sizes.columns[-1] || self.style.rowHeaderCellWidth) * self.scale;\r\n        };\r\n        self.setStorageData = function () {\r\n            if (!self.attributes.saveAppearance || !self.attributes.name) { return; }\r\n            var visibility = {};\r\n            self.getSchema().forEach(function (column) {\r\n                visibility[column.name] = !column.hidden;\r\n            });\r\n            localStorage.setItem(self.storageName + '-' + self.attributes.name, JSON.stringify({\r\n                sizes: {\r\n                    rows: self.sizes.rows,\r\n                    columns: self.sizes.columns\r\n                },\r\n                orders: {\r\n                    rows: self.orders.rows,\r\n                    columns: self.orders.columns\r\n                },\r\n                orderBy: self.orderBy,\r\n                orderDirection: self.orderDirection,\r\n                visibility: visibility\r\n            }));\r\n        };\r\n        self.getSchema = function () {\r\n            return self.schema || self.tempSchema || [];\r\n        };\r\n        function fillArray(low, high) {\r\n            var i = [], x;\r\n            for (x = low; x <= high; x += 1) {\r\n                i[x] = x;\r\n            }\r\n            return i;\r\n        }\r\n        self.createColumnOrders = function () {\r\n            var s = self.getSchema();\r\n            self.orders.columns = fillArray(0, s.length - 1);\r\n        };\r\n        self.createRowOrders = function () {\r\n            self.orders.rows = fillArray(0, self.data.length - 1);\r\n        };\r\n        self.getVisibleSchema = function () {\r\n            return self.getSchema().filter(function (col) {\r\n                return !col.hidden;\r\n            });\r\n        };\r\n        self.applyDefaultValue = function (row, header) {\r\n            var d = header.defaultValue || '';\r\n            if (typeof d === 'function') {\r\n                d = d.apply(self.intf, [header]);\r\n            }\r\n            row[header.name] = d;\r\n        };\r\n        self.createNewRowData = function () {\r\n            self.newRow = {};\r\n            self.getSchema().forEach(function forEachHeader(header) {\r\n                self.applyDefaultValue(self.newRow, header);\r\n            });\r\n        };\r\n        self.getSchemaNameHash = function (key) {\r\n            var n = 0;\r\n            while (self.schemaHashes[key]) {\r\n                n += 1;\r\n                key = key + n;\r\n            }\r\n            return key;\r\n        };\r\n        self.filter = function (type) {\r\n            var f = self.filters[type];\r\n            if (!f && type !== undefined) {\r\n                console.warn('Cannot find filter for type %s, falling back to substring match.', type);\r\n                f = self.filters.string;\r\n            }\r\n            return f;\r\n        };\r\n        self.applyFilter = function () {\r\n            self.refreshFromOrigialData();\r\n            Object.keys(self.columnFilters).forEach(function (filter) {\r\n                var header = self.getHeaderByName(filter);\r\n                if (!header) {\r\n                    return;\r\n                }\r\n                self.currentFilter = header.filter || self.filter(header.type || 'string');\r\n                self.data = self.data.filter(function (row) {\r\n                    return self.currentFilter(row[filter], self.columnFilters[filter]);\r\n                });\r\n            });\r\n            self.resize();\r\n            self.draw(true);\r\n        };\r\n        self.applyDataTransforms = function () {\r\n            self.applyFilter();\r\n            self.orderings.sort();\r\n        }\r\n        self.getBestGuessDataType = function (columnName, data) {\r\n            var t, x, l = data.length;\r\n            for (x = 0; x < l; x += 1) {\r\n                if (data[x] !== undefined && data[x] !== null && [null, undefined].indexOf(data[x][columnName]) !== -1) {\r\n                    t = typeof data[x];\r\n                    return t === 'object' ? 'string' : t;\r\n                }\r\n            }\r\n            return 'string';\r\n        };\r\n        self.drawChildGrids = function () {\r\n            Object.keys(self.childGrids).forEach(function (gridKey) {\r\n                self.childGrids[gridKey].draw();\r\n            });\r\n        };\r\n        self.resizeChildGrids = function () {\r\n            Object.keys(self.childGrids).forEach(function (gridKey) {\r\n                self.childGrids[gridKey].resize();\r\n            });\r\n        };\r\n        self.autoScrollZone = function (e, x, y, ctrl) {\r\n            var setTimer,\r\n                rowHeaderCellWidth = self.getRowHeaderCellWidth(),\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight();\r\n            if (y !== -1) {\r\n                if (x > self.width - self.attributes.selectionScrollZone && x < self.width) {\r\n                    self.scrollBox.scrollLeft += self.attributes.selectionScrollIncrement;\r\n                    setTimer = true;\r\n                }\r\n                if (x - self.attributes.selectionScrollZone - rowHeaderCellWidth < 0) {\r\n                    self.scrollBox.scrollLeft -= self.attributes.selectionScrollIncrement;\r\n                    setTimer = true;\r\n                }\r\n            }\r\n            if (y !== -1) {\r\n                if (y > self.height - self.attributes.selectionScrollZone && y < self.height) {\r\n                    self.scrollBox.scrollTop += self.attributes.selectionScrollIncrement;\r\n                    setTimer = true;\r\n                }\r\n                if (y - self.attributes.selectionScrollZone - columnHeaderCellHeight < 0) {\r\n                    self.scrollBox.scrollTop -= self.attributes.selectionScrollIncrement;\r\n                    setTimer = true;\r\n                }\r\n            }\r\n            if (setTimer && !ctrl && self.currentCell && self.currentCell.columnIndex !== -1) {\r\n                self.scrollTimer = setTimeout(self.mousemove, self.attributes.scrollRepeatRate, e);\r\n            }\r\n        };\r\n        self.refreshFromOrigialData = function () {\r\n            self.data = self.originalData.filter(function (row) {\r\n                return true;\r\n            });\r\n        };\r\n        self.validateColumn = function (c, s) {\r\n            if (!c.name) {\r\n                throw new Error('A column must contain at least a name.');\r\n            }\r\n            if (s.filter(function (i) { return i.name === c.name; }).length > 0) {\r\n                throw new Error('A column with the name '\r\n                    + c.name + ' already exists and cannot be added again.');\r\n            }\r\n            return true;\r\n        };\r\n        self.setDefaults = function (obj1, obj2, key, def) {\r\n            obj1[key] = obj2[key] === undefined ? def : obj2[key];\r\n        };\r\n        self.setAttributes = function () {\r\n            self.defaults.attributes.forEach(function eachAttribute(i) {\r\n                self.setDefaults(self.attributes, self.args, i[0], i[1]);\r\n            });\r\n        };\r\n        self.setStyle = function () {\r\n            self.defaults.styles.forEach(function eachStyle(i) {\r\n                self.setDefaults(self.style, self.args.style || {}, i[0], i[1]);\r\n            });\r\n        };\r\n        self.autosize = function (colName) {\r\n            self.getVisibleSchema().forEach(function (col, colIndex) {\r\n                if (col.name === colName || colName === undefined) {\r\n                    self.sizes.columns[colIndex]\r\n                        = Math.max(self.findColumnMaxTextLength(col.name), self.style.minColumnWidth);\r\n                }\r\n            });\r\n            self.sizes.columns[-1] = self.findColumnMaxTextLength('cornerCell');\r\n        };\r\n        self.dispose = function () {\r\n            if (!self.isChildGrid && self.canvas && self.canvas.parentNode) {\r\n                self.canvas.parentNode.removeChild(self.canvas);\r\n            }\r\n            if(!self.isChildGrid) {\r\n                document.body.removeChild(self.controlInput)\r\n            }\r\n            self.eventParent.removeEventListener('mouseup', self.mouseup, false);\r\n            self.eventParent.removeEventListener('mousedown', self.mousedown, false);\r\n            self.eventParent.removeEventListener('dblclick', self.dblclick, false);\r\n            self.eventParent.removeEventListener('click', self.click, false);\r\n            self.eventParent.removeEventListener('mousemove', self.mousemove);\r\n            self.eventParent.removeEventListener('wheel', self.scrollWheel, false);\r\n            self.canvas.removeEventListener('contextmenu', self.contextmenu, false);\r\n            self.canvas.removeEventListener('copy', self.copy);\r\n            self.controlInput.removeEventListener('copy', self.copy);\r\n            self.controlInput.removeEventListener('cut', self.cut);\r\n            self.controlInput.removeEventListener('paste', self.paste);\r\n            self.controlInput.removeEventListener('keypress', self.keypress, false);\r\n            self.controlInput.removeEventListener('keyup', self.keyup, false);\r\n            self.controlInput.removeEventListener('keydown', self.keydown, false);\r\n            window.removeEventListener('resize', self.resize);\r\n            if (self.observer && self.observer.disconnect) {\r\n                self.observer.disconnect();\r\n            }\r\n        };\r\n        self.tryLoadStoredSettings = function () {\r\n            var s;\r\n            self.reloadStoredValues();\r\n            if (self.storedSettings\r\n                    && typeof self.storedSettings.orders === 'object'\r\n                    && self.storedSettings.orders !== null) {\r\n                if (self.storedSettings.orders.rows.length >= (self.data || []).length) {\r\n                    self.orders.rows = self.storedSettings.orders.rows;\r\n                }\r\n                s = self.getSchema();\r\n                if (self.storedSettings.orders.columns.length === s.length) {\r\n                    self.orders.columns = self.storedSettings.orders.columns;\r\n                }\r\n                self.orderBy = self.storedSettings.orderBy === undefined\r\n                    ? s[0].name : self.storedSettings.orderBy;\r\n                self.orderDirection = self.storedSettings.orderDirection === undefined\r\n                    ? 'asc' : self.storedSettings.orderDirection;\r\n                if (self.storedSettings.orderBy !== undefined && self.getHeaderByName(self.orderBy) && self.orderDirection) {\r\n                    self.order(self.orderBy, self.orderDirection);\r\n                }\r\n            }\r\n        };\r\n        self.getDomRoot = function () {\r\n            return self.shadowRoot ? self.shadowRoot.host : self.parentNode;\r\n        };\r\n        self.getFontName = function (fontStyle) {\r\n            return fontStyle.replace(/\\d+\\.?\\d*px/, '');\r\n        };\r\n        self.getFontHeight = function (fontStyle) {\r\n            return parseFloat(fontStyle, 10);\r\n        };\r\n        self.parseStyleValue = function (key) {\r\n            if (/Font/.test(key)) {\r\n                self.style[key + 'Height'] = self.getFontHeight(self.style[key]);\r\n                self.style[key + 'Name'] = self.getFontName(self.style[key]);\r\n                return;\r\n            }\r\n            // when inheriting styles from already instantiated grids, don't parse already parsed values.\r\n            if (key === 'moveOverlayBorderSegments' && typeof self.style[key] === 'string') {\r\n                self.style[key] = self.style[key].split(',')\r\n                    .map(function (i) { return parseInt(i, 10); });\r\n            }\r\n        };\r\n        self.initProp = function (propName) {\r\n            if (!self.args[propName]) { return; }\r\n            Object.keys(self.args[propName]).forEach(function (key) {\r\n                self[propName][key] = self.args[propName][key];\r\n            });\r\n        };\r\n        self.getStyleProperty = function (key) {\r\n            if (self.styleKeys.indexOf(key) === -1) {\r\n                return self.parentNodeStyle[key];\r\n            }\r\n            return self.style[key];\r\n        };\r\n        self.setStyleProperty = function (key, value, supressDrawAndEvent) {\r\n            var isDim = ['height', 'width', 'minHeight', 'minWidth', 'maxHeight', 'maxWidth'].indexOf(key) !== -1;\r\n            if (self.styleKeys.indexOf(key) === -1) {\r\n                self.parentNodeStyle[key] = value;\r\n            } else {\r\n                if (/-/.test(key)) {\r\n                    key = self.dehyphenateProperty(key);\r\n                }\r\n                self.style[key] = value;\r\n                self.parseStyleValue(key);\r\n            }\r\n            if (isDim) {\r\n                self.resize();\r\n            }\r\n            if (!supressDrawAndEvent) {\r\n                self.draw(true);\r\n                self.dispatchEvent('stylechanged', {name: 'style', value: value});\r\n            }\r\n        };\r\n        self.reloadStoredValues = function () {\r\n            if (self.attributes.name && self.attributes.saveAppearance) {\r\n                try {\r\n                    self.storedSettings = localStorage.getItem(self.storageName + '-' + self.attributes.name);\r\n                } catch (e) {\r\n                    console.warn(\"Error loading stored values. \" + e.message);\r\n                    self.storedSettings = undefined;\r\n                }\r\n                if (self.storedSettings) {\r\n                    try {\r\n                        self.storedSettings = JSON.parse(self.storedSettings);\r\n                    } catch (e) {\r\n                        console.warn('could not read settings from localStore', e);\r\n                        self.storedSettings = undefined;\r\n                    }\r\n                }\r\n                if (self.storedSettings) {\r\n                    if (typeof self.storedSettings.sizes === 'object'\r\n                            && self.storedSettings.sizes !== null) {\r\n                        self.sizes.rows = self.storedSettings.sizes.rows;\r\n                        self.sizes.columns = self.storedSettings.sizes.columns;\r\n                        ['trees', 'columns', 'rows'].forEach(function (i) {\r\n                            if (!self.sizes[i]) {\r\n                                self.sizes[i] = {};\r\n                            }\r\n                        });\r\n                    }\r\n                    if (typeof self.storedSettings.visibility === 'object') {\r\n                        self.getSchema().forEach(function (column) {\r\n                            if (self.storedSettings.visibility && self.storedSettings.visibility[column.name] !== undefined) {\r\n                                column.hidden = !self.storedSettings.visibility[column.name];\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        self.init = function () {\r\n            if (self.initialized) { return; }\r\n            function addStyleKeyIfNoneExists(key) {\r\n                if (self.styleKeys.indexOf(key) === -1) {\r\n                    self.styleKeys.push(key);\r\n                }\r\n            }\r\n            var publicStyleKeyIntf = {};\r\n            self.setAttributes();\r\n            self.setStyle();\r\n            self.initScrollBox();\r\n            self.setDom();\r\n            self.nodeType = 'canvas-datagrid';\r\n            self.ie = /Trident/.test(window.navigator.userAgent);\r\n            self.edge = /Edge/.test(window.navigator.userAgent);\r\n            self.webKit = /WebKit/.test(window.navigator.userAgent);\r\n            self.moz = /Gecko/.test(window.navigator.userAgent);\r\n            self.mobile = /Mobile/i.test(window.navigator.userAgent);\r\n            self.cursorGrab = 'grab';\r\n            self.cursorGrabing = 'grabbing';\r\n            self.cursorGrab = self.webKit ? '-webkit-grab' : self.cursorGrab;\r\n            self.cursorGrabing = self.moz ? '-webkit-grabbing' : self.cursorGrabbing;\r\n            self.pointerLockPosition = {x: 0, y: 0};\r\n            Object.keys(self.style).forEach(self.parseStyleValue);\r\n            self.intf.moveSelection = self.moveSelection;\r\n            self.intf.moveTo = self.moveTo;\r\n            self.intf.addEventListener = self.addEventListener;\r\n            self.intf.removeEventListener = self.removeEventListener;\r\n            self.intf.dispatchEvent = self.dispatchEvent;\r\n            /**\r\n             * Releases grid resources and removes grid elements.\r\n             * @memberof canvasDatagrid\r\n             * @name dispose\r\n             * @method\r\n             */\r\n            self.intf.dispose = self.dispose;\r\n            /**\r\n             * Appends the grid to another element later.  Not implemented.\r\n             * @memberof canvasDatagrid\r\n             * @name appendTo\r\n             * @method\r\n             * @param {number} el The element to append the grid to.\r\n             */\r\n            self.intf.appendTo = self.appendTo;\r\n            self.intf.getVisibleCellByIndex = self.getVisibleCellByIndex;\r\n            self.intf.filters = self.filters;\r\n            self.intf.sorters = self.sorters;\r\n            self.intf.autosize = self.autosize;\r\n            self.intf.beginEditAt = self.beginEditAt;\r\n            self.intf.endEdit = self.endEdit;\r\n            self.intf.setActiveCell = self.setActiveCell;\r\n            self.intf.forEachSelectedCell = self.forEachSelectedCell;\r\n            self.intf.scrollIntoView = self.scrollIntoView;\r\n            self.intf.clearChangeLog = self.clearChangeLog;\r\n            self.intf.gotoCell = self.gotoCell;\r\n            self.intf.gotoRow = self.gotoRow;\r\n            self.intf.getHeaderByName = self.getHeaderByName;\r\n            self.intf.findColumnScrollLeft = self.findColumnScrollLeft;\r\n            self.intf.findRowScrollTop = self.findRowScrollTop;\r\n            self.intf.fitColumnToValues = self.fitColumnToValues;\r\n            self.intf.findColumnMaxTextLength = self.findColumnMaxTextLength;\r\n            self.intf.disposeContextMenu = self.disposeContextMenu;\r\n            self.intf.getCellAt = self.getCellAt;\r\n            self.intf.isCellVisible = self.isCellVisible;\r\n            self.intf.isRowVisible = self.isRowVisible;\r\n            self.intf.isColumnVisible = self.isColumnVisible;\r\n            self.intf.order = self.order;\r\n            self.intf.draw = self.draw;\r\n            self.intf.isComponent = self.isComponent;\r\n            self.intf.selectArea = self.selectArea;\r\n            self.intf.clipElement = self.clipElement;\r\n            self.intf.getSchemaFromData = self.getSchemaFromData;\r\n            self.intf.setFilter = self.setFilter;\r\n            self.intf.selectRow = self.selectRow;\r\n            self.intf.parentGrid = self.parentGrid;\r\n            self.intf.toggleTree = self.toggleTree;\r\n            self.intf.expandTree = self.expandTree;\r\n            self.intf.collapseTree = self.collapseTree;\r\n            self.intf.canvas = self.canvas;\r\n            self.intf.context = self.ctx;\r\n            self.intf.insertRow = self.insertRow;\r\n            self.intf.deleteRow = self.deleteRow;\r\n            self.intf.addRow = self.addRow;\r\n            self.intf.insertColumn = self.insertColumn;\r\n            self.intf.deleteColumn = self.deleteColumn;\r\n            self.intf.addColumn = self.addColumn;\r\n            self.intf.getClippingRect = self.getClippingRect;\r\n            self.intf.setRowHeight = self.setRowHeight;\r\n            self.intf.setColumnWidth = self.setColumnWidth;\r\n            self.intf.resetColumnWidths = self.resetColumnWidths;\r\n            self.intf.resetRowHeights = self.resetRowHeights;\r\n            self.intf.resize = self.resize;\r\n            self.intf.selectColumn = self.selectColumn;\r\n            self.intf.selectRow = self.selectRow;\r\n            self.intf.selectAll = self.selectAll;\r\n            self.intf.selectNone = self.selectNone;\r\n            self.intf.drawChildGrids = self.drawChildGrids;\r\n            self.intf.assertPxColor = self.assertPxColor;\r\n            self.intf.clearPxColorAssertions = self.clearPxColorAssertions;\r\n            self.intf.integerToAlpha = self.integerToAlpha;\r\n            self.intf.copy = self.copy;\r\n            self.intf.setStyleProperty = self.setStyleProperty;\r\n            Object.defineProperty(self.intf, 'defaults', {\r\n                get: function () {\r\n                    return {\r\n                        styles: self.defaults.styles.reduce(function (a, i) { a[i[0]] = i[1]; return a; }, {}),\r\n                        attributes: self.defaults.attributes.reduce(function (a, i) { a[i[0]] = i[1]; return a; }, {})\r\n                    };\r\n                }\r\n            });\r\n            self.styleKeys = Object.keys(self.intf.defaults.styles);\r\n            self.styleKeys.map(function (i) { return self.hyphenateProperty(i, false); }).forEach(addStyleKeyIfNoneExists);\r\n            self.styleKeys.map(function (i) { return self.hyphenateProperty(i, true); }).forEach(addStyleKeyIfNoneExists);\r\n            self.DOMStyles = window.getComputedStyle(document.body, null);\r\n            self.styleKeys.concat(Object.keys(self.DOMStyles)).forEach(function (key) {\r\n                // unless this line is here, Object.keys() will not work on <instance>.style\r\n                publicStyleKeyIntf[key] = undefined;\r\n                Object.defineProperty(publicStyleKeyIntf, key, {\r\n                    get: function () {\r\n                        return self.getStyleProperty(key);\r\n                    },\r\n                    set: function (value) {\r\n                        if (self.initialized) {\r\n                            self.appliedInlineStyles[key] = value;\r\n                        }\r\n                        self.setStyleProperty(key, value);\r\n                    }\r\n                });\r\n            });\r\n            Object.defineProperty(self.intf, 'shadowRoot', {\r\n                get: function () {\r\n                    return self.shadowRoot;\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'activeCell', {\r\n                get: function () {\r\n                    return self.activeCell;\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'hasFocus', {\r\n                get: function () {\r\n                    return self.hasFocus;\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'style', {\r\n                get: function () {\r\n                    return publicStyleKeyIntf;\r\n                },\r\n                set: function (valueObject) {\r\n                    Object.keys(valueObject).forEach(function (key) {\r\n                        self.setStyleProperty(key, valueObject[key], true);\r\n                    });\r\n                    self.draw(true);\r\n                    self.dispatchEvent('stylechanged', {name: 'style', value: valueObject});\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'attributes', { value: {}});\r\n            Object.keys(self.attributes).forEach(function (key) {\r\n                Object.defineProperty(self.intf.attributes, key, {\r\n                    get: function () {\r\n                        return self.attributes[key];\r\n                    },\r\n                    set: function (value) {\r\n                        self.attributes[key] = value;\r\n                        if (key === 'name') {\r\n                            self.tryLoadStoredSettings();\r\n                        }\r\n                        self.draw(true);\r\n                        self.dispatchEvent('attributechanged', {name: key, value: value[key]});\r\n                    }\r\n                });\r\n            });\r\n            self.filters.string = function (value, filterFor) {\r\n                value = String(value);\r\n                var filterRegExp,\r\n                    regEnd = /\\/(i|g|m)*$/,\r\n                    pattern = regEnd.exec(filterFor),\r\n                    flags = pattern ? pattern[0].substring(1) : '',\r\n                    flagLength = flags.length;\r\n                self.invalidFilterRegEx = undefined;\r\n                if (filterFor.substring(0, 1) === '/' && pattern) {\r\n                    try {\r\n                        filterRegExp = new RegExp(filterFor.substring(1, filterFor.length - (flagLength + 1)), flags);\r\n                    } catch (e) {\r\n                        self.invalidFilterRegEx = e;\r\n                        return;\r\n                    }\r\n                    return filterRegExp.test(value);\r\n                }\r\n                return value.toString ? value.toString().toLocaleUpperCase()\r\n                    .indexOf(filterFor.toLocaleUpperCase()) !== -1 : false;\r\n            };\r\n            self.filters.number = function (value, filterFor) {\r\n                if (!filterFor) { return true; }\r\n                return value === filterFor;\r\n            };\r\n            ['formatters', 'filters', 'sorters'].forEach(self.initProp);\r\n            self.applyComponentStyle(false, self.intf);\r\n            self.reloadStoredValues();\r\n            if (self.args.data) {\r\n                self.intf.data = self.args.data;\r\n            }\r\n            if (self.intf.innerText || self.intf.textContent) {\r\n                if (self.intf.dataType === 'application/x-canvas-datagrid') {\r\n                    self.intf.dataType = 'application/json+x-canvas-datagrid';\r\n                }\r\n                self.intf.data = self.intf.innerText || self.intf.textContent;\r\n            }\r\n            if (self.args.schema) {\r\n                self.intf.schema = self.args.schema;\r\n            }\r\n            if (self.isChildGrid || !self.isComponent) {\r\n                requestAnimationFrame(function () { self.resize(true); });\r\n            } else {\r\n                self.resize(true);\r\n            }\r\n            self.initialized = true;\r\n            return self;\r\n        };\r\n        /**\r\n         * Removes focus from the grid.\r\n         * @memberof canvasDatagrid\r\n         * @name blur\r\n         * @method\r\n         */\r\n        self.intf.blur = function (e) {\r\n            self.hasFocus = false;\r\n        };\r\n        /**\r\n         * Focuses on the grid.\r\n         * @memberof canvasDatagrid\r\n         * @name focus\r\n         * @method\r\n         */\r\n        self.intf.focus = function () {\r\n            self.hasFocus = true;\r\n            self.controlInput.focus();\r\n        };\r\n        if (self.shadowRoot || self.isChildGrid) {\r\n            Object.defineProperty(self.intf, 'height', {\r\n                get: function () {\r\n                    if (self.shadowRoot) {\r\n                        return self.shadowRoot.height;\r\n                    }\r\n                    return self.parentNode.height;\r\n                },\r\n                set: function (value) {\r\n                    if (self.shadowRoot) {\r\n                        self.shadowRoot.height = value;\r\n                    } else {\r\n                        self.parentNode.height = value;\r\n                    }\r\n                    self.resize(true);\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'width', {\r\n                get: function () {\r\n                    if (self.shadowRoot) {\r\n                        return self.shadowRoot.width;\r\n                    }\r\n                    return self.parentNode.width;\r\n                },\r\n                set: function (value) {\r\n                    if (self.shadowRoot) {\r\n                        self.shadowRoot.width = value;\r\n                    } else {\r\n                        self.parentNode.width = value;\r\n                    }\r\n                    self.resize(true);\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'parentNode', {\r\n                get: function () {\r\n                    return self.parentNode;\r\n                },\r\n                set: function (value) {\r\n                    if (!self.isChildGrid) {\r\n                        throw new TypeError('Cannot set property parentNode which has only a getter');\r\n                    }\r\n                    self.parentNode = value;\r\n                }\r\n            });\r\n        }\r\n        Object.defineProperty(self.intf, 'visibleRowHeights', {\r\n            get: function () {\r\n                return self.visibleRowHeights;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'openChildren', {\r\n            get: function () {\r\n                return self.openChildren;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'childGrids', {\r\n            get: function () {\r\n                return Object.keys(self.childGrids).map(function (gridId) {\r\n                    return self.childGrids[gridId];\r\n                });\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'isChildGrid', {\r\n            get: function () {\r\n                return self.isChildGrid;\r\n            }\r\n        });\r\n        Object.defineProperty(self, 'cursor', {\r\n            get: function () {\r\n                return self.parentNodeStyle.cursor;\r\n            },\r\n            set: function (value) {\r\n                if (value === 'cell') { value = 'default'; }\r\n                if (self.currentCursor !== value) {\r\n                    self.parentNodeStyle.cursor = value;\r\n                    self.currentCursor = value;\r\n                }\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'orderDirection', {\r\n            get: function () {\r\n                return self.orderDirection;\r\n            },\r\n            set: function (value) {\r\n                if (value !== 'desc') {\r\n                    value = 'asc';\r\n                }\r\n                self.orderDirection = value;\r\n                self.order(self.orderBy, self.orderDirection);\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'orderBy', {\r\n            get: function () {\r\n                return self.orderBy;\r\n            },\r\n            set: function (value) {\r\n                if (self.getSchema().find(function (col) {\r\n                        return col.name === value;\r\n                    }) === undefined) {\r\n                    throw new Error('Cannot sort by unknown column name.');\r\n                }\r\n                self.orderBy = value;\r\n                self.order(self.orderBy, self.orderDirection);\r\n            }\r\n        });\r\n        if (self.isComponent) {\r\n            Object.defineProperty(self.intf, 'offsetHeight', {\r\n                get: function () {\r\n                    return self.canvas.offsetHeight;\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'offsetWidth', {\r\n                get: function () {\r\n                    return self.canvas.offsetWidth;\r\n                }\r\n            });\r\n        }\r\n        Object.defineProperty(self.intf, 'scrollHeight', {\r\n            get: function () {\r\n                return self.scrollBox.scrollHeight;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'scrollWidth', {\r\n            get: function () {\r\n                return self.scrollBox.scrollWidth;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'scrollTop', {\r\n            get: function () {\r\n                return self.scrollBox.scrollTop;\r\n            },\r\n            set: function (value) {\r\n                self.scrollBox.scrollTop = value;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'scrollLeft', {\r\n            get: function () {\r\n                return self.scrollBox.scrollLeft;\r\n            },\r\n            set: function (value) {\r\n                self.scrollBox.scrollLeft = value;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'sizes', {\r\n            get: function () {\r\n                return self.sizes;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'parentDOMNode', {\r\n            get: function () {\r\n                return self.parentDOMNode;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'input', {\r\n            get: function () {\r\n                return self.input;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'controlInput', {\r\n            get: function () {\r\n                return self.controlInput;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'currentCell', {\r\n            get: function () {\r\n                return self.currentCell;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'visibleCells', {\r\n            get: function () {\r\n                return self.visibleCells;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'visibleRows', {\r\n            get: function () {\r\n                return self.visibleRows;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'selections', {\r\n            get: function () {\r\n                return self.selections;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'dragMode', {\r\n            get: function () {\r\n                return self.dragMode;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'changes', {\r\n            get: function () {\r\n                return self.changes;\r\n            }\r\n        });\r\n        self.intf.formatters = self.formatters;\r\n        Object.defineProperty(self.intf, 'dataType', {\r\n            get: function () {\r\n                return self.dataType;\r\n            },\r\n            set: function (value) {\r\n                if (!self.parsers[value]) {\r\n                    throw new Error('No parser for MIME type ' + value);\r\n                }\r\n                self.dataType = value;\r\n            }\r\n        });\r\n        self.eventNames.forEach(function (eventName) {\r\n            Object.defineProperty(self.intf, 'on' + eventName, {\r\n                get: function () {\r\n                    return self.componentL1Events[eventName];\r\n                },\r\n                set: function (value) {\r\n                    self.events[eventName] = [];\r\n                    self.componentL1Events[eventName] = value;\r\n                    if (!value) { return; }\r\n                    self.addEventListener(eventName, value);\r\n                }\r\n            });\r\n        });\r\n        Object.defineProperty(self.intf, 'frozenRow', {\r\n            get: function () {\r\n                return self.frozenRow;\r\n            },\r\n            set: function (val) {\r\n                if (isNaN(val)) {\r\n                    throw new TypeError('Expected value for frozenRow to be a number.');\r\n                }\r\n                if (self.visibleRows.length < val) {\r\n                    throw new RangeError('Cannot set a value larger than the number of visible rows.');\r\n                }\r\n                self.frozenRow = val;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'frozenColumn', {\r\n            get: function () {\r\n                return self.frozenColumn;\r\n            },\r\n            set: function (val) {\r\n                if (isNaN(val)) {\r\n                    throw new TypeError('Expected value for frozenRow to be a number.');\r\n                }\r\n                if (self.getVisibleSchema().length < val) {\r\n                    throw new RangeError('Cannot set a value larger than the number of visible columns.');\r\n                }\r\n                self.frozenColumn = val;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'scrollIndexRect', {\r\n            get: function () {\r\n                return {\r\n                    top: self.scrollIndexTop,\r\n                    right: self.scrollIndexRight,\r\n                    bottom: self.scrollIndexBottom,\r\n                    left: self.scrollIndexLeft\r\n                };\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'scrollPixelRect', {\r\n            get: function () {\r\n                return {\r\n                    top: self.scrollPixelTop,\r\n                    right: self.scrollPixelRight,\r\n                    bottom: self.scrollPixelBottom,\r\n                    left: self.scrollPixelLeft\r\n                };\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'rowOrder', {\r\n            get: function () {\r\n                return self.orders.rows;\r\n            },\r\n            set: function (val) {\r\n                if (!Array.isArray(val)) {\r\n                    throw new TypeError('Value must be an array.');\r\n                }\r\n                if (!self.data || val.length < self.data.length) {\r\n                    throw new RangeError('Array length must be equal to or greater than number of rows.');\r\n                }\r\n                self.orders.rows = val;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'columnOrder', {\r\n            get: function () {\r\n                return self.orders.columns;\r\n            },\r\n            set: function (val) {\r\n                if (!Array.isArray(val)) {\r\n                    throw new TypeError('Value must be an array.');\r\n                }\r\n                if (val.length < self.getSchema().length) {\r\n                    throw new RangeError('Array length must be equal to or greater than number of columns.');\r\n                }\r\n                self.orders.columns = val;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'selectionBounds', {\r\n            get: function () {\r\n                return self.getSelectionBounds();\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'selectedRows', {\r\n            get: function () {\r\n                return self.getSelectedData(true);\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'selectedCells', {\r\n            get: function () {\r\n                return self.getSelectedData();\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'visibleSchema', {\r\n            get: function () {\r\n                return self.getVisibleSchema().map(function eachDataRow(col) {\r\n                    return col;\r\n                });\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'treeGridAttributes', {\r\n            get: function () {\r\n                return self.treeGridAttributes;\r\n            },\r\n            set: function setTreeGridAttributes(value) {\r\n                self.treeGridAttributes = value;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'cellGridAttributes', {\r\n            get: function () {\r\n                return self.cellGridAttributes;\r\n            },\r\n            set: function setCellGridAttributes(value) {\r\n                self.cellGridAttributes = value;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'ctx', {\r\n            get: function () {\r\n                return self.ctx;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'schema', {\r\n            get: function schemaGetter() {\r\n                return self.getSchema();\r\n            },\r\n            set: function schemaSetter(value) {\r\n                if (value === undefined) {\r\n                    // Issue #89 - allow schema to be set to initialized state\r\n                    self.schema = undefined;\r\n                    self.tempSchema = undefined;\r\n                    self.dispatchEvent('schemachanged', {schema: undefined});\r\n                    return;\r\n                }\r\n                if (!Array.isArray(value) || typeof value[0] !== 'object') {\r\n                    throw new Error('Schema must be an array of objects.');\r\n                }\r\n                if (value[0].name === undefined) {\r\n                    throw new Error('Expected schema to contain an object with at least a name property.');\r\n                }\r\n                self.schema = value.map(function eachSchemaColumn(column, index) {\r\n                    column.width = column.width || self.style.cellWidth;\r\n                    column.filter = column.filter || self.filter(column.type);\r\n                    column.type = column.type || 'string';\r\n                    column.index = index;\r\n                    column.columnIndex = index;\r\n                    column.rowIndex = -1;\r\n                    return column;\r\n                });\r\n                self.tempSchema = undefined;\r\n                self.createNewRowData();\r\n                self.createColumnOrders();\r\n                self.tryLoadStoredSettings();\r\n                if (self.storedSettings && typeof self.storedSettings.visibility === 'object') {\r\n                    self.schema.forEach(function hideEachSchemaColumn(column, index) {\r\n                        if (self.storedSettings && self.storedSettings.visibility[column.name] !== undefined) {\r\n                            column.hidden = !self.storedSettings.visibility[column.name];\r\n                        }\r\n                    });\r\n                }\r\n                self.resize(true);\r\n                self.dispatchEvent('schemachanged', {schema: self.schema});\r\n            }\r\n        });\r\n        /**\r\n         * Gets an array of currently registered MIME types.\r\n         * @memberof canvasDatagrid\r\n         * @name getDataTypes\r\n         * @method\r\n         */\r\n        self.intf.getTypes = function () {\r\n            return Object.keys(self.parsers);\r\n        };\r\n        self.parseInnerHtml = function (data) {\r\n            if (!data || /^ +$/.test(data)) {\r\n                return [];\r\n            }\r\n            try {\r\n                data = JSON.parse(data);\r\n            } catch (e) {\r\n                console.warn(Error('Cannot parse application/json+x-canvas-datagrid formated data. '\r\n                    + e.message + '  \\nNote: canvas-datagrid.innerHTML is for string data only.  '\r\n                    + 'Use the canvas-datagrid.data property to set object data.'));\r\n            }\r\n            return data;\r\n        };\r\n        self.parsers['application/json+x-canvas-datagrid'] = function (data, callback) {\r\n            self.parsers['application/x-canvas-datagrid'](self.parseInnerHtml(data), function (data, schema) {\r\n                return callback(data, schema);\r\n            });\r\n        };\r\n        self.parsers['application/x-canvas-datagrid'] = function (data, callback) {\r\n            return callback(data);\r\n        };\r\n        self.intf.parsers = self.parsers;\r\n        // send to dataType ETL function to extract from input data\r\n        // and transform into native [{}, {}] format\r\n        self.etl = function (data, callback) {\r\n            if (!self.intf.parsers[self.dataType]) {\r\n                throw new Error('Unsupported data type.');\r\n            }\r\n            self.intf.parsers[self.dataType](data, function (data, schema) {\r\n                if (Array.isArray(schema)) {\r\n                    self.schema = schema;\r\n                }\r\n                // Issue #89 - allow schema to be auto-created every time data is set\r\n                if (self.attributes.autoGenerateSchema) {\r\n                    self.schema = self.getSchemaFromData(data);\r\n                }\r\n                if (!self.schema) {\r\n                    self.tempSchema = self.getSchemaFromData(data);\r\n                }\r\n                if (self.getSchema()) {\r\n                    self.createColumnOrders();\r\n                }\r\n                // set the unfiltered/sorted data array\r\n                self.originalData = data;\r\n                // apply filter, sort, etc to incoming dataset\r\n                self.applyDataTransforms();\r\n                // empty data was set\r\n                if (!self.schema && (self.data || []).length === 0) {\r\n                    self.tempSchema = [{name: ''}];\r\n                }\r\n                self.fitColumnToValues('cornerCell', true);\r\n                if ((self.tempSchema && !self.schema) || self.attributes.autoGenerateSchema) {\r\n                    self.createColumnOrders();\r\n                    self.dispatchEvent('schemachanged', {schema: self.tempSchema});\r\n                }\r\n                callback();\r\n            });\r\n        };\r\n        Object.defineProperty(self.intf, 'data', {\r\n            get: function dataGetter() {\r\n                return self.data;\r\n            },\r\n            set: function dataSetter(value) {\r\n                self.etl(value, function () {\r\n                    self.changes = [];\r\n                    self.createNewRowData();\r\n                    if (self.attributes.autoResizeColumns && self.data.length > 0\r\n                            && self.storedSettings === undefined) {\r\n                        self.autosize();\r\n                    }\r\n                    // set the header column to fit the numbers in it\r\n                    self.fitColumnToValues('cornerCell', true);\r\n                    self.createRowOrders();\r\n                    self.tryLoadStoredSettings();\r\n                    self.dispatchEvent('datachanged', {data: self.data});\r\n                    self.resize(true);\r\n                });\r\n            }\r\n        });\r\n        self.initScrollBox = function () {\r\n            var sHeight = 0,\r\n                sWidth = 0,\r\n                scrollTop = 0,\r\n                scrollLeft = 0,\r\n                scrollHeight = 0,\r\n                scrollWidth = 0,\r\n                scrollBoxHeight = 20,\r\n                scrollBoxWidth = 20;\r\n            function setScrollTop(value, preventScrollEvent) {\r\n                if (isNaN(value)) {\r\n                    throw new Error('ScrollTop value must be a number');\r\n                }\r\n                if (value < 0) {\r\n                    value = 0;\r\n                }\r\n                if (value > scrollHeight) {\r\n                    value = scrollHeight;\r\n                }\r\n                if (scrollHeight < 0) {\r\n                    value = 0;\r\n                }\r\n                scrollTop = value;\r\n                if (!preventScrollEvent) {\r\n                    self.scroll();\r\n                }\r\n            }\r\n            function setScrollLeft(value, preventScrollEvent) {\r\n                if (isNaN(value)) {\r\n                    throw new Error('ScrollLeft value must be a number');\r\n                }\r\n                if (value < 0) {\r\n                    value = 0;\r\n                }\r\n                if (value > scrollWidth) {\r\n                    value = scrollWidth;\r\n                }\r\n                if (scrollWidth < 0) {\r\n                    value = 0;\r\n                }\r\n                scrollLeft = value;\r\n                if (!preventScrollEvent) {\r\n                    self.scroll();\r\n                }\r\n            }\r\n            self.scrollBox.toString = function () {\r\n                return '{\"width\": ' + scrollWidth.toFixed(2)\r\n                    + ', \"height\": ' + scrollHeight.toFixed(2)\r\n                    + ', \"left\": ' + scrollLeft.toFixed(2)\r\n                    + ', \"top\": ' + scrollTop.toFixed(2)\r\n                    + ', \"widthRatio\": ' + self.scrollBox.widthBoxRatio.toFixed(5)\r\n                    + ', \"heightRatio\": ' + self.scrollBox.heightBoxRatio.toFixed(5) + '}';\r\n            };\r\n            self.scrollBox.scrollTo = function (x, y, supressDrawEvent) {\r\n                setScrollLeft(x, true);\r\n                setScrollTop(y, supressDrawEvent);\r\n            };\r\n            Object.defineProperty(self.scrollBox, 'scrollBoxHeight', {\r\n                get: function () {\r\n                    return scrollBoxHeight;\r\n                },\r\n                set: function (value) {\r\n                    scrollBoxHeight = value;\r\n                }\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'scrollBoxWidth', {\r\n                get: function () {\r\n                    return scrollBoxWidth;\r\n                },\r\n                set: function (value) {\r\n                    scrollBoxWidth = value;\r\n                }\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'height', {\r\n                get: function () {\r\n                    return sHeight;\r\n                },\r\n                set: function (value) {\r\n                    sHeight = value;\r\n                }\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'width', {\r\n                get: function () {\r\n                    return sWidth;\r\n                },\r\n                set: function (value) {\r\n                    sWidth = value;\r\n                }\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'scrollTop', {\r\n                get: function () {\r\n                    return scrollTop;\r\n                },\r\n                set: setScrollTop\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'scrollLeft', {\r\n                get: function () {\r\n                    return scrollLeft;\r\n                },\r\n                set: setScrollLeft\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'scrollHeight', {\r\n                get: function () {\r\n                    return scrollHeight;\r\n                },\r\n                set: function (value) {\r\n                    if (scrollTop > value) {\r\n                        scrollTop = Math.max(value, 0);\r\n                    }\r\n                    scrollHeight = value;\r\n                }\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'scrollWidth', {\r\n                get: function () {\r\n                    return scrollWidth;\r\n                },\r\n                set: function (value) {\r\n                    if (scrollLeft > value) {\r\n                        scrollLeft = Math.max(value, 0);\r\n                    }\r\n                    scrollWidth = value;\r\n                }\r\n            });\r\n        };\r\n        return;\r\n    };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false, Event: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n    'use strict';\r\n    return function (self) {\r\n        var zIndexTop, hoverScrollTimeout, autoCompleteContext;\r\n        function applyContextItemStyle(contextItemContainer) {\r\n            self.createInlineStyle(contextItemContainer, 'canvas-datagrid-context-menu-item' + (self.mobile ? '-mobile' : ''));\r\n            contextItemContainer.addEventListener('mouseover', function () {\r\n                self.createInlineStyle(contextItemContainer, 'canvas-datagrid-context-menu-item:hover');\r\n            });\r\n            contextItemContainer.addEventListener('mouseout', function () {\r\n                self.createInlineStyle(contextItemContainer, 'canvas-datagrid-context-menu-item');\r\n            });\r\n        }\r\n        function createContextMenu(ev, pos, items, parentContextMenu) {\r\n            var container = document.createElement('div'),\r\n                upArrow = document.createElement('div'),\r\n                downArrow = document.createElement('div'),\r\n                children = [],\r\n                selectedIndex = -1,\r\n                intf = {},\r\n                rect;\r\n            if (!Array.isArray(items)) { throw new Error('createContextMenu expects an array.'); }\r\n            function createItems() {\r\n                items.forEach(function (item) {\r\n                    var contextItemContainer = document.createElement('div'),\r\n                        childMenuArrow;\r\n                    function removeChildContext(e) {\r\n                        if (e.relatedTarget === container\r\n                                || item.contextMenu.container === e.relatedTarget\r\n                                || childMenuArrow === e.relatedTarget\r\n                                || (contextItemContainer === e.relatedTarget)\r\n                                || item.contextMenu.container.contains(e.relatedTarget)\r\n                                ) { return; }\r\n                        item.contextMenu.dispose();\r\n                        children.splice(children.indexOf(item.contextMenu), 1);\r\n                        item.contextMenu = undefined;\r\n                        contextItemContainer.removeEventListener('mouseout', removeChildContext);\r\n                        container.removeEventListener('mouseout', removeChildContext);\r\n                        contextItemContainer.setAttribute('contextOpen', '0');\r\n                        contextItemContainer.setAttribute('opening', '0');\r\n                    }\r\n                    function contextAddCallback(items) {\r\n                        // check yet again if the user hasn't moved off\r\n                        if (contextItemContainer.getAttribute('opening') !== '1' ||\r\n                                contextItemContainer.getAttribute('contextOpen') === '1') {\r\n                            return;\r\n                        }\r\n                        var cPos = contextItemContainer.getBoundingClientRect();\r\n                        cPos = {\r\n                            left: cPos.left + self.style.childContextMenuMarginLeft + container.offsetWidth,\r\n                            top: cPos.top + self.style.childContextMenuMarginTop,\r\n                            bottom: cPos.bottom,\r\n                            right: cPos.right\r\n                        };\r\n                        item.contextMenu = createContextMenu(ev, cPos, items, intf);\r\n                        contextItemContainer.setAttribute('contextOpen', '1');\r\n                        contextItemContainer.addEventListener('mouseout', removeChildContext);\r\n                        container.addEventListener('mouseout', removeChildContext);\r\n                        children.push(item.contextMenu);\r\n                    }\r\n                    function createChildContext() {\r\n                        var i;\r\n                        if (contextItemContainer.getAttribute('contextOpen') === '1') {\r\n                            return;\r\n                        }\r\n                        contextItemContainer.setAttribute('opening', '1');\r\n                        if (typeof item.items === 'function') {\r\n                            i  = item.items.apply(intf, [function (items) {\r\n                                contextAddCallback(items);\r\n                            }]);\r\n                            if (i !== undefined && Array.isArray(i)) {\r\n                                contextAddCallback(i);\r\n                            }\r\n                            return;\r\n                        }\r\n                        contextAddCallback(item.items);\r\n                    }\r\n                    function addItem(item) {\r\n                        function addContent(content) {\r\n                            if (content === null) { return; }\r\n                            if (typeof content === 'function') {\r\n                                return addContent(content(ev));\r\n                            }\r\n                            if (typeof content === 'object') {\r\n                                contextItemContainer.appendChild(content);\r\n                                return;\r\n                            }\r\n                            applyContextItemStyle(contextItemContainer);\r\n                            contextItemContainer.innerHTML = content;\r\n                            return;\r\n                        }\r\n                        addContent(item.title);\r\n                        item.contextItemContainer = contextItemContainer;\r\n                        if ((item.items && item.items.length > 0) || typeof item.items === 'function') {\r\n                            childMenuArrow = document.createElement('div');\r\n                            self.createInlineStyle(childMenuArrow, 'canvas-datagrid-context-child-arrow');\r\n                            childMenuArrow.innerHTML = self.style.childContextMenuArrowHTML;\r\n                            contextItemContainer.appendChild(childMenuArrow);\r\n                            contextItemContainer.addEventListener('mouseover', createChildContext);\r\n                            contextItemContainer.addEventListener('mouseout', function () {\r\n                                contextItemContainer.setAttribute('opening', '0');\r\n                            });\r\n                        }\r\n                        if (item.click) {\r\n                            contextItemContainer.addEventListener('click', function (ev) {\r\n                                item.click.apply(self, [ev]);\r\n                            });\r\n                        }\r\n                    }\r\n                    addItem(item);\r\n                    container.appendChild(contextItemContainer);\r\n                });\r\n            }\r\n            function clickIndex(idx) {\r\n                items[idx].contextItemContainer.dispatchEvent(new Event('click'));\r\n            }\r\n            function checkArrowVisibility() {\r\n                if (container.scrollTop > 0) {\r\n                    self.parentDOMNode.appendChild(upArrow);\r\n                } else if (upArrow.parentNode) {\r\n                    upArrow.parentNode.removeChild(upArrow);\r\n                }\r\n                if (container.scrollTop >= container.scrollHeight - container.offsetHeight && downArrow.parentNode) {\r\n                    downArrow.parentNode.removeChild(downArrow);\r\n                } else if (container.scrollHeight - container.offsetHeight > 0\r\n                        && !(container.scrollTop >= container.scrollHeight - container.offsetHeight)) {\r\n                    self.parentDOMNode.appendChild(downArrow);\r\n                }\r\n            }\r\n            function startHoverScroll(type) {\r\n                return function t() {\r\n                    var a = self.attributes.contextHoverScrollAmount;\r\n                    if (type === 'up' && container.scrollTop === 0) { return; }\r\n                    if (type === 'down' && container.scrollTop === container.scrollHeight) { return; }\r\n                    container.scrollTop += (type === 'up' ? -a : a);\r\n                    hoverScrollTimeout = setTimeout(t, self.attributes.contextHoverScrollRateMs, type);\r\n                };\r\n            }\r\n            function endHoverScroll(type) {\r\n                return function () {\r\n                    clearTimeout(hoverScrollTimeout);\r\n                };\r\n            }\r\n            function init() {\r\n                var loc = {},\r\n                    s = self.scrollOffset(self.canvas);\r\n                if (zIndexTop === undefined) {\r\n                    zIndexTop = self.style.contextMenuZIndex;\r\n                }\r\n                createItems();\r\n                self.createInlineStyle(container, 'canvas-datagrid-context-menu' + (self.mobile ? '-mobile' : ''));\r\n                loc.x = pos.left - s.left;\r\n                loc.y = pos.top - s.top;\r\n                loc.height = 0;\r\n                zIndexTop += 1;\r\n                container.style.position = 'absolute';\r\n                upArrow.style.color = self.style.contextMenuArrowColor;\r\n                downArrow.style.color = self.style.contextMenuArrowColor;\r\n                [upArrow, downArrow].forEach(function (el) {\r\n                    el.style.textAlign = 'center';\r\n                    el.style.position = 'absolute';\r\n                    el.style.zIndex = zIndexTop + 1;\r\n                });\r\n                container.style.zIndex = zIndexTop;\r\n                if (parentContextMenu && parentContextMenu.inputDropdown) {\r\n                    container.style.maxHeight = window.innerHeight - loc.y - self.style.autocompleteBottomMargin + 'px';\r\n                    container.style.minWidth = pos.width + 'px';\r\n                    loc.y += pos.height;\r\n                }\r\n                if (self.mobile) {\r\n                    container.style.width = pos.width + 'px';\r\n                }\r\n                container.style.left = loc.x + 'px';\r\n                container.style.top = loc.y + 'px';\r\n                container.addEventListener('scroll', checkArrowVisibility);\r\n                container.addEventListener('wheel', function (e) {\r\n                    if (self.hasFocus) {\r\n                        container.scrollTop += e.deltaY;\r\n                        container.scrollLeft += e.deltaX;\r\n                    }\r\n                    checkArrowVisibility();\r\n                });\r\n                upArrow.innerHTML = self.style.contextMenuArrowUpHTML;\r\n                downArrow.innerHTML = self.style.contextMenuArrowDownHTML;\r\n                container.appendChild(upArrow);\r\n                document.body.appendChild(downArrow);\r\n                document.body.appendChild(container);\r\n                rect = container.getBoundingClientRect();\r\n                // TODO: fix !(parentContextMenu && parentContextMenu.inputDropdown) state (autocomplete)\r\n                if (rect.bottom > window.innerHeight) {\r\n                    if (!(parentContextMenu && parentContextMenu.inputDropdown)) {\r\n                        loc.y -= (rect.bottom + self.style.contextMenuWindowMargin) - window.innerHeight;\r\n                    }\r\n                    if (loc.y < 0) { loc.y = self.style.contextMenuWindowMargin; }\r\n                    if (container.offsetHeight > window.innerHeight - self.style.contextMenuWindowMargin) {\r\n                        container.style.height = window.innerHeight - (self.style.contextMenuWindowMargin * 2) + 'px';\r\n                    }\r\n                }\r\n                if (rect.right > window.innerWidth) {\r\n                    loc.x -= rect.right - window.innerWidth + self.style.contextMenuWindowMargin;\r\n                }\r\n                if (loc.x < 0) { loc.x = self.style.contextMenuWindowMargin; }\r\n                if (loc.y < 0) { loc.y = self.style.contextMenuWindowMargin; }\r\n                container.style.left = loc.x + 'px';\r\n                container.style.top = loc.y + 'px';\r\n                rect = container.getBoundingClientRect();\r\n                upArrow.style.top = rect.top + 'px';\r\n                downArrow.style.top = rect.top + rect.height - downArrow.offsetHeight + 'px';\r\n                upArrow.style.left = rect.left + 'px';\r\n                downArrow.style.left = rect.left + 'px';\r\n                downArrow.style.width = container.offsetWidth + 'px';\r\n                upArrow.style.width = container.offsetWidth + 'px';\r\n                downArrow.addEventListener('mouseover', startHoverScroll('down'));\r\n                downArrow.addEventListener('mouseout', endHoverScroll('down'));\r\n                upArrow.addEventListener('mouseover', startHoverScroll('up'));\r\n                upArrow.addEventListener('mouseout', endHoverScroll('up'));\r\n                checkArrowVisibility();\r\n            }\r\n            intf.parentGrid = self.intf;\r\n            intf.parentContextMenu = parentContextMenu;\r\n            intf.container = container;\r\n            init();\r\n            intf.clickIndex = clickIndex;\r\n            intf.rect = rect;\r\n            intf.items = items;\r\n            intf.upArrow = upArrow;\r\n            intf.downArrow = downArrow;\r\n            intf.dispose = function () {\r\n                clearTimeout(hoverScrollTimeout);\r\n                children.forEach(function (c) {\r\n                    c.dispose();\r\n                });\r\n                [downArrow, upArrow, container].forEach(function (el) {\r\n                    if (el.parentNode) { el.parentNode.removeChild(el); }\r\n                });\r\n            };\r\n            Object.defineProperty(intf, 'selectedIndex', {\r\n                get: function () {\r\n                    return selectedIndex;\r\n                },\r\n                set: function (value) {\r\n                    if (typeof value !== 'number' || isNaN(value || !isFinite(value))) {\r\n                        throw new Error('Context menu selected index must be a sane number.');\r\n                    }\r\n                    selectedIndex = value;\r\n                    if (selectedIndex > items.length - 1) {\r\n                        selectedIndex = items.length - 1;\r\n                    }\r\n                    if (selectedIndex < 0) {\r\n                        selectedIndex = 0;\r\n                    }\r\n                    items.forEach(function (item, index) {\r\n                        if (index === selectedIndex) {\r\n                            return self.createInlineStyle(item.contextItemContainer, 'canvas-datagrid-context-menu-item:hover');\r\n                        }\r\n                        self.createInlineStyle(item.contextItemContainer, 'canvas-datagrid-context-menu-item');\r\n                    });\r\n                }\r\n            });\r\n            return intf;\r\n        }\r\n        function createFilterContextMenuItems(e) {\r\n            var filterContainer = document.createElement('div'),\r\n                filterLabel = document.createElement('div'),\r\n                filterAutoCompleteButton = document.createElement('button'),\r\n                filterInput = document.createElement('input'),\r\n                n = e.cell && e.cell.header ? e.cell.header.title || e.cell.header.name : '',\r\n                autoCompleteItems,\r\n                iRect;\r\n            function checkRegExpErrorState() {\r\n                filterInput.style.background = self.style.contextFilterInputBackground;\r\n                filterInput.style.color = self.style.contextFilterInputColor;\r\n                if (self.invalidFilterRegEx) {\r\n                    filterInput.style.background = self.style.contextFilterInvalidRegExpBackground;\r\n                    filterInput.style.color = self.style.contextFilterInvalidRegExpColor;\r\n                }\r\n            }\r\n            function fillAutoComplete() {\r\n                var count = 0;\r\n                autoCompleteItems = {};\r\n                self.data.forEach(function (row) {\r\n                    var value = row[e.cell.header.name];\r\n                    if (autoCompleteItems[value] || count > self.attributes.maxAutoCompleteItems) { return; }\r\n                    count += 1;\r\n                    autoCompleteItems[value] = {\r\n                        title: self.formatters[e.cell.header.type || 'string']({ cell: { value: value }}),\r\n                        click: function (e) {\r\n                            filterInput.value = value;\r\n                            e.stopPropagation();\r\n                            filterInput.dispatchEvent(new Event('keyup'));\r\n                            self.disposeAutocomplete();\r\n                            return;\r\n                        }\r\n                    };\r\n                });\r\n                autoCompleteItems = Object.keys(autoCompleteItems).map(function (key) {\r\n                    return autoCompleteItems[key];\r\n                });\r\n            }\r\n            function createAutoCompleteContext(ev) {\r\n                if (ev && [40, 38, 13, 9].indexOf(ev.keyCode) !== -1) { return; }\r\n                fillAutoComplete();\r\n                iRect = filterInput.getBoundingClientRect();\r\n                if (autoCompleteContext) {\r\n                    autoCompleteContext.dispose();\r\n                    autoCompleteContext = undefined;\r\n                }\r\n                autoCompleteContext = createContextMenu(e, {\r\n                    left: iRect.left,\r\n                    top: iRect.top,\r\n                    right: iRect.right,\r\n                    bottom: iRect.bottom,\r\n                    height: iRect.height,\r\n                    width: iRect.width\r\n                }, autoCompleteItems, {inputDropdown: true});\r\n                autoCompleteContext.selectedIndex = 0;\r\n            }\r\n            self.createInlineStyle(filterLabel, 'canvas-datagrid-context-menu-label');\r\n            self.createInlineStyle(filterAutoCompleteButton, 'canvas-datagrid-context-menu-filter-button');\r\n            self.createInlineStyle(filterInput, 'canvas-datagrid-context-menu-filter-input');\r\n            checkRegExpErrorState();\r\n            filterInput.onclick = self.disposeAutocomplete;\r\n            filterInput.addEventListener('keydown', function (e) {\r\n                //down\r\n                if (e.keyCode === 40) {\r\n                    autoCompleteContext.selectedIndex += 1;\r\n                }\r\n                //up\r\n                if (e.keyCode === 38) {\r\n                    autoCompleteContext.selectedIndex -= 1;\r\n                }\r\n                //enter\r\n                if (e.keyCode === 13) {\r\n                    autoCompleteContext.clickIndex(autoCompleteContext.selectedIndex);\r\n                    self.disposeContextMenu();\r\n                }\r\n                //tab\r\n                if (e.keyCode === 9) {\r\n                    autoCompleteContext.clickIndex(autoCompleteContext.selectedIndex);\r\n                    e.preventDefault();\r\n                }\r\n                //esc\r\n                if (e.keyCode === 27) {\r\n                    self.disposeContextMenu();\r\n                }\r\n            });\r\n            filterInput.addEventListener('keyup', function () {\r\n                self.setFilter(e.cell.header.name, filterInput.value);\r\n            });\r\n            filterInput.addEventListener('keyup', createAutoCompleteContext);\r\n            ['focus', 'blur', 'keydown', 'keyup', 'change'].forEach(function (en) {\r\n                filterInput.addEventListener(en, checkRegExpErrorState);\r\n            });\r\n            filterInput.value = e.cell.header ? self.columnFilters[e.cell.header.name] || '' : '';\r\n            filterLabel.innerHTML = self.attributes.filterOptionText.replace(/%s/g, n);\r\n            filterAutoCompleteButton.onclick = function () {\r\n                if (autoCompleteContext) {\r\n                    return self.disposeAutocomplete();\r\n                }\r\n                createAutoCompleteContext();\r\n            };\r\n            filterAutoCompleteButton.innerHTML = self.style.contextFilterButtonHTML;\r\n            filterContainer.addEventListener('click', function (e) {\r\n                return e.stopPropagation();\r\n            });\r\n            filterContainer.appendChild(filterLabel);\r\n            filterContainer.appendChild(filterInput);\r\n            filterContainer.appendChild(filterAutoCompleteButton);\r\n            e.items.push({\r\n                title: filterContainer\r\n            });\r\n            if (Object.keys(self.columnFilters).length) {\r\n                Object.keys(self.columnFilters).forEach(function (cf) {\r\n                    var h = self.getHeaderByName(cf);\r\n                    e.items.push({\r\n                        title: self.attributes.removeFilterOptionText.replace(/%s/g, h.title || h.name),\r\n                        click: function removeFilterClick(e) {\r\n                            e.preventDefault();\r\n                            self.setFilter(cf, '');\r\n                            self.controlInput.focus();\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        function addDefaultContextMenuItem(e) {\r\n            var isNormalCell = !(e.cell.isBackground || e.cell.isColumnHeaderCellCap\r\n                    || e.cell.isScrollBar || e.cell.isCorner || e.cell.isRowHeader)\r\n                    && e.cell.header;\r\n            if (self.attributes.showFilter && isNormalCell) {\r\n                createFilterContextMenuItems(e);\r\n            }\r\n            if (self.attributes.showCopy\r\n                    && self.selections.reduce(function (p, r) {\r\n                        return p + r.length;\r\n                    }, 0) > 0) {\r\n                e.items.push({\r\n                    title: self.attributes.copyText,\r\n                    click: function () {\r\n                        document.execCommand('copy');\r\n                        self.disposeContextMenu();\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n            }\r\n            if (self.attributes.showPaste && self.clipBoardData) {\r\n                e.items.push({\r\n                    title: self.attributes.pasteText,\r\n                    click: function () {\r\n                        self.paste(self.clipBoardData, e.cell.columnIndex, e.cell.rowIndex);\r\n                        self.draw();\r\n                    }\r\n                });\r\n            }\r\n            if (self.attributes.showColumnSelector) {\r\n                e.items.push({\r\n                    title: self.attributes.columnSelectorText,\r\n                    items: function () {\r\n                        var d = [];\r\n                        self.getSchema().forEach(function (column) {\r\n                            function toggleColumnVisibility(e) {\r\n                                column.hidden = !column.hidden;\r\n                                self.dispatchEvent('togglecolumn', {column: column, hidden: column.hidden});\r\n                                e.preventDefault();\r\n                                self.stopPropagation(e);\r\n                                self.disposeContextMenu();\r\n                                self.resize(true);\r\n                                self.setStorageData();\r\n                            }\r\n                            var el = document.createElement('div');\r\n                            applyContextItemStyle(el);\r\n                            el.addEventListener('touchstart', toggleColumnVisibility);\r\n                            el.addEventListener('click', toggleColumnVisibility);\r\n                            el.innerHTML = (column.hidden ? self.attributes.columnSelectorHiddenText\r\n                                    : self.attributes.columnSelectorVisibleText)\r\n                                    + (column.title || column.name);\r\n                            d.push({\r\n                                title: el\r\n                            });\r\n                        });\r\n                        return d;\r\n                    }\r\n                });\r\n                if (e.cell && e.cell.header && e.cell.columnIndex > -1) {\r\n                    e.items.push({\r\n                        title: self.attributes.hideColumnText\r\n                            .replace(/%s/ig, e.cell.header.title || e.cell.header.name),\r\n                        click: function (ev) {\r\n                            self.getSchema()[e.cell.columnIndex].hidden = true;\r\n                            ev.preventDefault();\r\n                            self.stopPropagation(ev);\r\n                            self.disposeContextMenu();\r\n                            self.setStorageData();\r\n                            setTimeout(function () { self.resize(true); }, 10);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            if (self.attributes.saveAppearance && self.attributes.showClearSettingsOption\r\n                    && (Object.keys(self.sizes.rows).length > 0\r\n                        || Object.keys(self.sizes.columns).length > 0)) {\r\n                e.items.push({\r\n                    title: self.attributes.clearSettingsOptionText,\r\n                    click: function (e) {\r\n                        e.preventDefault();\r\n                        self.sizes.rows = {};\r\n                        self.sizes.columns = {};\r\n                        self.createRowOrders();\r\n                        self.createColumnOrders();\r\n                        self.storedSettings = undefined;\r\n                        self.dispatchEvent('resizecolumn', {columnWidth: self.style.cellWidth});\r\n                        self.dispatchEvent('resizerow', {cellHeight: self.style.cellHeight});\r\n                        self.setStorageData();\r\n                        self.resize(true);\r\n                        self.disposeContextMenu();\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n            }\r\n            if (self.attributes.allowSorting && self.attributes.showOrderByOption && isNormalCell) {\r\n                e.items.push({\r\n                    title: self.attributes.showOrderByOptionTextAsc.replace('%s', e.cell.header.title || e.cell.header.name),\r\n                    click: function (ev) {\r\n                        ev.preventDefault();\r\n                        self.order(e.cell.header.name, 'asc');\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n                e.items.push({\r\n                    title: self.attributes.showOrderByOptionTextDesc.replace('%s', e.cell.header.title || e.cell.header.name),\r\n                    click: function (ev) {\r\n                        ev.preventDefault();\r\n                        self.order(e.cell.header.name, 'desc');\r\n                        self.disposeContextMenu();\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        self.disposeAutocomplete = function () {\r\n            if (autoCompleteContext) {\r\n                autoCompleteContext.dispose();\r\n                autoCompleteContext = undefined;\r\n            }\r\n        };\r\n        self.disposeContextMenu = function () {\r\n            document.removeEventListener('click', self.disposeContextMenu);\r\n            zIndexTop = self.style.contextMenuZIndex;\r\n            self.disposeAutocomplete();\r\n            if (self.contextMenu) {\r\n                self.contextMenu.dispose();\r\n            }\r\n            self.contextMenu = undefined;\r\n        };\r\n        self.contextmenuEvent = function (e, overridePos) {\r\n            if (!self.hasFocus && e.target !== self.canvas) {\r\n                return;\r\n            }\r\n            function createDiposeEvent() {\r\n                requestAnimationFrame(function () {\r\n                    document.addEventListener('click', self.disposeContextMenu);\r\n                    document.removeEventListener('mouseup', createDiposeEvent);\r\n                });\r\n            }\r\n            var contextPosition,\r\n                items = [],\r\n                pos = overridePos || self.getLayerPos(e),\r\n                ev = {\r\n                    NativeEvent: e,\r\n                    cell: self.getCellAt(pos.x, pos.y),\r\n                    items: items\r\n                };\r\n            if (!ev.cell.isGrid) {\r\n                addDefaultContextMenuItem(ev);\r\n            }\r\n            if (self.dispatchEvent('contextmenu', ev)) {\r\n                return;\r\n            }\r\n            if (!ev.cell.isGrid) {\r\n                if (self.contextMenu) {\r\n                    self.disposeContextMenu();\r\n                }\r\n                contextPosition = {\r\n                    left: pos.x + pos.rect.left\r\n                        + self.style.contextMenuMarginLeft + self.canvasOffsetLeft,\r\n                    top: pos.y + pos.rect.top\r\n                        + self.style.contextMenuMarginTop + self.canvasOffsetTop,\r\n                    right: ev.cell.width + ev.cell.x + pos.rect.left,\r\n                    bottom: ev.cell.height + ev.cell.y + pos.rect.top,\r\n                    height: ev.cell.height,\r\n                    width: ev.cell.width\r\n                };\r\n                if (self.mobile) {\r\n                    contextPosition.left = self.style.mobileContextMenuMargin + 'px';\r\n                    contextPosition.width = self.width - (self.style.mobileContextMenuMargin * 2) + 'px';\r\n                }\r\n                self.contextMenu = createContextMenu(ev, contextPosition, items);\r\n                document.addEventListener('mouseup', createDiposeEvent);\r\n                e.preventDefault();\r\n            }\r\n        };\r\n        return;\r\n    };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n    'use strict';\r\n    return function (self) {\r\n        self.getClippingRect = function (ele) {\r\n            var boundingRect = self.position(self.parentNode),\r\n                eleRect = self.position(ele),\r\n                s = self.scrollOffset(self.canvas),\r\n                clipRect = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    h: 0,\r\n                    w: 0\r\n                },\r\n                parentRect = {\r\n                    x: -Infinity,\r\n                    y: -Infinity,\r\n                    h: Infinity,\r\n                    w: Infinity\r\n                },\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n                rowHeaderCellWidth = self.getRowHeaderCellWidth();\r\n            boundingRect.top -= s.top;\r\n            boundingRect.left -= s.left;\r\n            eleRect.top -= s.top;\r\n            eleRect.left -= s.left;\r\n            clipRect.h = boundingRect.top + boundingRect.height - ele.offsetTop - self.style.scrollBarWidth;\r\n            clipRect.w = boundingRect.left + boundingRect.width - ele.offsetLeft - self.style.scrollBarWidth;\r\n            clipRect.x = boundingRect.left + (eleRect.left * -1) + rowHeaderCellWidth;\r\n            clipRect.y = boundingRect.top + (eleRect.top * -1) + columnHeaderCellHeight;\r\n            return {\r\n                x: clipRect.x > parentRect.x ? clipRect.x : parentRect.x,\r\n                y: clipRect.y > parentRect.y ? clipRect.y : parentRect.y,\r\n                h: clipRect.h < parentRect.h ? clipRect.h : parentRect.h,\r\n                w: clipRect.w < parentRect.w ? clipRect.w : parentRect.w\r\n            };\r\n        };\r\n        self.clipElement = function (ele) {\r\n            var clipRect = self.getClippingRect(ele);\r\n            if (clipRect.w < 0) { clipRect.w = 0; }\r\n            if (clipRect.h < 0) { clipRect.h = 0; }\r\n            ele.style.clip = 'rect('\r\n                + clipRect.y + 'px,'\r\n                + clipRect.w + 'px,'\r\n                + clipRect.h + 'px,'\r\n                + clipRect.x + 'px'\r\n                + ')';\r\n            // INFO https://developer.mozilla.org/en-US/docs/Web/CSS/clip\r\n            // clip has been \"deprecated\" for clipPath.  Of course nothing but chrome\r\n            // supports clip path, so we'll keep using clip until someday clipPath becomes\r\n            // more widely support.  The code below works correctly, but setting clipPath and clip\r\n            // at the same time has undesirable results.\r\n            // ele.style.clipPath = 'polygon('\r\n            //     + clipRect.x + 'px ' + clipRect.y + 'px,'\r\n            //     + clipRect.x + 'px ' + clipRect.h + 'px,'\r\n            //     + clipRect.w + 'px ' + clipRect.h + 'px,'\r\n            //     + clipRect.w + 'px ' + clipRect.y + 'px'\r\n            //     + ')';\r\n        };\r\n        self.scrollOffset = function (e) {\r\n            var x = 0, y = 0, scrollingElement = document.scrollingElement || { scrollLeft: 0, scrollTop: 0 };\r\n            while (e.parentNode && e.nodeName !== 'CANVAS-DATAGRID' && e !== self.intf) {\r\n                if (e.nodeType !== 'canvas-datagrid-tree'\r\n                        && e.nodeType !== 'canvas-datagrid-cell') {\r\n                    x -= e.scrollLeft;\r\n                    y -= e.scrollTop;\r\n                }\r\n                e = e.parentNode;\r\n            }\r\n            return {\r\n                left: x - scrollingElement.scrollLeft,\r\n                top: y - scrollingElement.scrollTop\r\n            };\r\n        };\r\n        self.resizeEditInput = function () {\r\n            if (self.input && self.input.editCell) {\r\n                var pos = self.canvas.getBoundingClientRect(),\r\n                    s = self.scrollOffset(self.intf),\r\n                    bm = self.style.gridBorderCollapse === 'collapse' ? 1 : 2,\r\n                    borderWidth = (self.style.cellBorderWidth * bm),\r\n                    cell = self.getVisibleCellByIndex(self.input.editCell.columnIndex, self.input.editCell.rowIndex)\r\n                        || {x: -100, y: -100, height: 0, width: 0};\r\n                if (self.mobile) {\r\n                    self.input.style.left = '0';\r\n                    self.input.style.top = (self.height - self.style.mobileEditInputHeight) - borderWidth - 1 + 'px';\r\n                    self.input.style.height = self.style.mobileEditInputHeight + 'px';\r\n                    self.input.style.width = self.width - borderWidth - 1 + 'px';\r\n                    return;\r\n                }\r\n                self.input.style.left = pos.left + cell.x + self.canvasOffsetLeft - s.left + 'px';\r\n                self.input.style.top = pos.top + cell.y - self.style.cellBorderWidth + self.canvasOffsetTop - s.top + 'px';\r\n                self.input.style.height = cell.height - borderWidth + 'px';\r\n                self.input.style.width = cell.width - self.style.cellPaddingLeft + 'px';\r\n                self.clipElement(self.input);\r\n            }\r\n        };\r\n        self.position = function (e, ignoreScrollOffset) {\r\n            var x = 0, y = 0, s = e, h, w;\r\n            while (e.offsetParent && e.nodeName !== 'CANVAS-DATAGRID') {\r\n                x += e.offsetLeft;\r\n                y += e.offsetTop;\r\n                h = e.offsetHeight;\r\n                w = e.offsetWidth;\r\n                e = e.offsetParent;\r\n            }\r\n            if (ignoreScrollOffset) {\r\n                return {left: x, top: y, height: h, width: w};\r\n            }\r\n            e = s;\r\n            s = self.scrollOffset(e);\r\n            return { left: x + s.left, top: y + s.top, height: h, width: w };\r\n        };\r\n        self.getLayerPos = function (e) {\r\n            var rect = self.canvas.getBoundingClientRect(),\r\n                pos = {\r\n                    x: e.clientX - rect.left,\r\n                    y: e.clientY - rect.top\r\n                };\r\n            if (self.isChildGrid) {\r\n                pos.x -= self.canvasOffsetLeft;\r\n                pos.y -= self.canvasOffsetTop;\r\n            }\r\n            return {\r\n                x: pos.x,\r\n                y: pos.y,\r\n                rect: rect\r\n            };\r\n        };\r\n        /**\r\n         * Ends editing, optionally aborting the edit.\r\n         * @memberof canvasDatagrid\r\n         * @name endEdit\r\n         * @method\r\n         * @param {boolean} abort When true, abort the edit.\r\n         */\r\n        self.endEdit = function (abort) {\r\n            var cell = self.input.editCell,\r\n                y = cell.rowIndex;\r\n            function abortEdit() {\r\n                abort = true;\r\n            }\r\n            if (self.dispatchEvent('beforeendedit', {\r\n                    cell: cell,\r\n                    newValue: self.input.value,\r\n                    oldValue: cell.value,\r\n                    abort: abortEdit,\r\n                    input: self.input\r\n                })) { return false; }\r\n            if (self.input.value !== cell.value && !abort) {\r\n                self.changes[y] = self.changes[y] || {};\r\n                self.changes[y][cell.header.name] = self.input.value;\r\n                if (!cell.data) {\r\n                    self.data[cell.rowIndex] = {};\r\n                    cell.data = self.data[cell.rowIndex];\r\n                }\r\n                cell.data[cell.header.name] = self.input.value;\r\n                if (y === self.data.length) {\r\n                    if (self.dispatchEvent('newrow', {\r\n                            value: self.input.value,\r\n                            defaultValue: cell.value,\r\n                            aborted: abort,\r\n                            cell: cell,\r\n                            input: self.input\r\n                        })) { return false; }\r\n                    self.addRow(cell.data);\r\n                    self.createNewRowData();\r\n                }\r\n                self.draw(true);\r\n            }\r\n            if (self.input.parentNode) {\r\n                self.input.parentNode.removeChild(self.input);\r\n            }\r\n            self.intf.focus();\r\n            self.dispatchEvent('endedit', {\r\n                cell: cell,\r\n                value: self.input.value,\r\n                aborted: abort,\r\n                input: self.input\r\n            });\r\n            self.input = undefined;\r\n            return true;\r\n        };\r\n        /**\r\n         * Begins editing at cell x, row y.\r\n         * @memberof canvasDatagrid\r\n         * @name beginEditAt\r\n         * @method\r\n         * @param {number} x The column index of the cell to edit.\r\n         * @param {number} y The row index of the cell to edit.\r\n         */\r\n        self.beginEditAt = function (x, y, NativeEvent) {\r\n            if (!self.attributes.editable) { return; }\r\n            if (self.input) {\r\n                self.endEdit();\r\n            }\r\n            var cell = self.getVisibleCellByIndex(x, y),\r\n                s = self.getSchema(),\r\n                adjacentCells,\r\n                enumItems,\r\n                enu,\r\n                option,\r\n                valueInEnum;\r\n            if (!(cell && cell.header)) { return; }\r\n            //HACK for IE10, does not like literal enum\r\n            enu = cell.header['enum'];\r\n            if (self.dispatchEvent('beforebeginedit', {cell: cell, NativeEvent: NativeEvent})) { return false; }\r\n            self.scrollIntoView(x, y);\r\n            self.setActiveCell(x, y);\r\n            adjacentCells = self.getAdjacentCells();\r\n            if (enu) {\r\n                self.input = document.createElement('select');\r\n            } else {\r\n                self.input = document.createElement(self.attributes.multiLine\r\n                    ? 'textarea' : 'input');\r\n            }\r\n            cell = self.getVisibleCellByIndex(x, y);\r\n            //HACK on mobile devices sometimes edit can begin without the cell being in view, I don't know how.\r\n            if (!cell) { return; }\r\n            if (enu) {\r\n                // add enums\r\n                if (typeof enu === 'function') {\r\n                    enumItems = enu.apply(self.intf, [{cell: cell}]);\r\n                } else if (Array.isArray(enu)) {\r\n                    enumItems = enu;\r\n                }\r\n                enumItems.forEach(function (e) {\r\n                    var i = document.createElement('option'),\r\n                        val,\r\n                        title;\r\n                    if (Array.isArray(e)) {\r\n                        val = e[0];\r\n                        title = e[1];\r\n                    } else {\r\n                        val = e;\r\n                        title = e;\r\n                    }\r\n                    if (val === cell.value) { valueInEnum = true; }\r\n                    i.value = val;\r\n                    i.innerHTML = title;\r\n                    self.input.appendChild(i);\r\n                });\r\n                if (!valueInEnum) {\r\n                    option = document.createElement('option');\r\n                    option.value = cell.value;\r\n                    option.innerHTML = cell.value;\r\n                    self.input.appendChild(option);\r\n                }\r\n                self.input.addEventListener('change', function () {\r\n                    self.endEdit();\r\n                    self.draw(true);\r\n                });\r\n            }\r\n            // if the user has not prevented the default action, append to the body\r\n            if (!self.dispatchEvent('appendeditinput', {cell: cell, input:self.input})) { \r\n                document.body.appendChild(self.input);\r\n            }\r\n            self.createInlineStyle(self.input, self.mobile ? 'canvas-datagrid-edit-mobile-input' : 'canvas-datagrid-edit-input');\r\n            self.input.style.position = 'absolute';\r\n            self.input.editCell = cell;\r\n            self.resizeEditInput();\r\n            self.input.style.zIndex = self.style.editCellZIndex;\r\n            self.input.style.fontSize = (parseInt(self.style.editCellFontSize, 10) * self.scale) + 'px';\r\n            self.input.value = [null, undefined].indexOf(cell.value) !== -1 ? '' : cell.value;\r\n            self.input.focus();\r\n            self.input.addEventListener('click', self.stopPropagation);\r\n            self.input.addEventListener('dblclick', self.stopPropagation);\r\n            self.input.addEventListener('mouseup', self.stopPropagation);\r\n            self.input.addEventListener('mousedown', self.stopPropagation);\r\n            self.input.addEventListener('keydown', function (e) {\r\n                var nx = cell.columnIndex,\r\n                    ny = cell.rowIndex;\r\n                // esc\r\n                if (e.keyCode === 27) {\r\n                    self.endEdit(true);\r\n                    self.draw(true);\r\n                // enter\r\n                } else if (e.keyCode === 13\r\n                        && (!self.attributes.multiLine\r\n                            || (self.attributes.multiLine && e.shiftKey))) {\r\n                    self.endEdit();\r\n                    self.draw(true);\r\n                } else if (e.keyCode === 9) {\r\n                    e.preventDefault();\r\n                    if (!self.endEdit()) {\r\n                        return;\r\n                    }\r\n                    if (e.shiftKey) {\r\n                        nx = adjacentCells.left;\r\n                    } else {\r\n                        nx = adjacentCells.right;\r\n                    }\r\n                    if (adjacentCells.left === x && e.shiftKey) {\r\n                        nx = adjacentCells.last;\r\n                        ny -= 1;\r\n                    }\r\n                    if (adjacentCells.right === x && !e.shiftKey) {\r\n                        nx = adjacentCells.first;\r\n                        ny += 1;\r\n                    }\r\n                    if (ny < 0) {\r\n                        ny = self.data.length - 1;\r\n                    }\r\n                    if (ny > self.data.length - 1) {\r\n                        ny = 0;\r\n                    }\r\n                    self.scrollIntoView(nx, ny);\r\n                    self.beginEditAt(nx, ny, e);\r\n                }\r\n            });\r\n            self.dispatchEvent('beginedit', {cell: cell, input: self.input});\r\n        };\r\n        self.createInlineStyle = function (el, className) {\r\n            var css = {\r\n                'canvas-datagrid-context-menu-filter-input': {\r\n                    height: '19px',\r\n                    verticalAlign: 'bottom',\r\n                    marginLeft: '2px',\r\n                    padding: '0',\r\n                    background: self.style.contextFilterInputBackground,\r\n                    color: self.style.contextFilterInputColor,\r\n                    border: self.style.contextFilterInputBorder,\r\n                    borderRadius: self.style.contextFilterInputBorderRadius,\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextFilterInputFontFamily,\r\n                    fontSize: self.style.contextFilterInputFontSize\r\n                },\r\n                'canvas-datagrid-context-menu-filter-button': {\r\n                    height: '19px',\r\n                    verticalAlign: 'bottom',\r\n                    marginLeft: '2px',\r\n                    padding: '0',\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextFilterButtonBorder,\r\n                    borderRadius: self.style.contextFilterButtonBorderRadius,\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFilterButtonFontFamily,\r\n                    fontSize: self.style.contextMenuFilterButtonFontSize\r\n                },\r\n                'canvas-datagrid-context-child-arrow': {\r\n                    cssFloat: 'right',\r\n                    color: self.style.childContextMenuArrowColor,\r\n                    fontSize: self.style.contextMenuChildArrowFontSize,\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    verticalAlign: 'middle'\r\n                },\r\n                'canvas-datagrid-autocomplete': {\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextMenuBorder,\r\n                    padding: self.style.contextMenuPadding,\r\n                    borderRadius: self.style.contextMenuBorderRadius,\r\n                    opacity: self.style.contextMenuOpacity,\r\n                    position: 'absolute',\r\n                    zIndex: 9999,\r\n                    overflow: 'hidden'\r\n                },\r\n                'canvas-datagrid-autocomplete-item': {\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor\r\n                },\r\n                'canvas-datagrid-autocomplete-item:hover': {\r\n                    background: self.style.contextMenuHoverBackground,\r\n                    color: self.style.contextMenuHoverColor\r\n                },\r\n                'canvas-datagrid-canvas': {\r\n                    position: 'absolute',\r\n                    zIndex: '-1'\r\n                },\r\n                'canvas-datagrid': {\r\n                    display: 'block'\r\n                },\r\n                'canvas-datagrid-control-input': {\r\n                    position: 'fixed',\r\n                    top: '-5px',\r\n                    left: '-5px',\r\n                    border: 'none',\r\n                    opacity: '0',\r\n                    cursor: 'pointer',\r\n                    width: '1px',\r\n                    height: '1px',\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize\r\n                },\r\n                'canvas-datagrid-edit-mobile-input': {\r\n                    boxSizing: 'content-box',\r\n                    outline: 'none',\r\n                    margin: '0',\r\n                    padding: '0 0 0 0',\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.mobileEditFontFamily,\r\n                    fontSize: self.style.mobileEditFontSize,\r\n                    border: self.style.editCellBorder,\r\n                    color: self.style.editCellColor,\r\n                    background: self.style.editCellBackgroundColor,\r\n                    appearance: 'none',\r\n                    webkitAppearance: 'none',\r\n                    mozAppearance: 'none',\r\n                    borderRadius: '0'\r\n                },\r\n                'canvas-datagrid-edit-input': {\r\n                    boxSizing: 'content-box',\r\n                    outline: 'none',\r\n                    margin: '0',\r\n                    padding: '0 0 0 ' + self.style.editCellPaddingLeft + 'px',\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.editCellFontFamily,\r\n                    fontSize: self.style.editCellFontSize,\r\n                    boxShadow: self.style.editCellBoxShadow,\r\n                    border: self.style.editCellBorder,\r\n                    color: self.style.editCellColor,\r\n                    background: self.style.editCellBackgroundColor,\r\n                    appearance: 'none',\r\n                    webkitAppearance: 'none',\r\n                    mozAppearance: 'none',\r\n                    borderRadius: '0'\r\n                },\r\n                'canvas-datagrid-context-menu-item-mobile': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    color: 'inherit',\r\n                    background: 'inherit',\r\n                    margin: self.style.contextMenuItemMargin,\r\n                    borderRadius: self.style.contextMenuItemBorderRadius,\r\n                    verticalAlign: 'middle'\r\n                },\r\n                'canvas-datagrid-context-menu-item': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    color: 'inherit',\r\n                    background: 'inherit',\r\n                    margin: self.style.contextMenuItemMargin,\r\n                    borderRadius: self.style.contextMenuItemBorderRadius,\r\n                    verticalAlign: 'middle'\r\n                },\r\n                'canvas-datagrid-context-menu-item:hover': {\r\n                    background: self.style.contextMenuHoverBackground,\r\n                    color: self.style.contextMenuHoverColor\r\n                },\r\n                'canvas-datagrid-context-menu-label': {\r\n                    margin: self.style.contextMenuLabelMargin,\r\n                    display: self.style.contextMenuLabelDisplay,\r\n                    minWidth: self.style.contextMenuLabelMinWidth,\r\n                    maxWidth: self.style.contextMenuLabelMaxWidth\r\n                },\r\n                'canvas-datagrid-context-menu-mobile': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextMenuBorder,\r\n                    padding: self.style.contextMenuPadding,\r\n                    borderRadius: self.style.contextMenuBorderRadius,\r\n                    opacity: self.style.contextMenuOpacity,\r\n                    overflow: 'hidden',\r\n                    whiteSpace: 'nowrap'\r\n                },\r\n                'canvas-datagrid-context-menu': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextMenuBorder,\r\n                    padding: self.style.contextMenuPadding,\r\n                    borderRadius: self.style.contextMenuBorderRadius,\r\n                    opacity: self.style.contextMenuOpacity,\r\n                    overflow: 'hidden',\r\n                    whiteSpace: 'nowrap',\r\n                    cursor: self.style.contextMenuCursor\r\n                },\r\n                'canvas-datagrid-invalid-search-regExp': {\r\n                    background: self.style.contextMenuFilterInvalidExpresion\r\n                }\r\n            };\r\n            if (css[className]) {\r\n                Object.keys(css[className]).map(function (prop) {\r\n                    el.style[prop] = css[className][prop];\r\n                });\r\n            }\r\n            return;\r\n        };\r\n        self.appendTo = function (e) {\r\n            self.parentNode = e;\r\n            self.setDom();\r\n        };\r\n        self.setDom = function () {\r\n            if (self.isChildGrid) {\r\n                self.parentGrid = self.parentNode.parentGrid;\r\n                self.ctx = self.parentGrid.context;\r\n                self.canvas = self.parentGrid.canvas;\r\n                self.controlInput = self.parentGrid.controlInput;\r\n                self.eventParent = self.canvas;\r\n            } else {\r\n                self.controlInput = self.controlInput || document.createElement('input');\r\n                self.controlInput.onblur = self.intf.blur;\r\n                self.createInlineStyle(self.controlInput, 'canvas-datagrid-control-input');\r\n                self.isChildGrid = false;\r\n                self.parentDOMNode = self.parentNode;\r\n                self.parentIsCanvas = /^canvas$/i.test(self.parentDOMNode.tagName);\r\n                if (self.parentIsCanvas) {\r\n                    self.canvas = self.parentDOMNode;\r\n                } else {\r\n                    self.canvas = document.createElement('canvas');\r\n                    if (self.intf.createShadowRoot) {\r\n                        self.parentDOMNode.appendChild(self.canvas);\r\n                    }\r\n                }\r\n                document.body.appendChild(self.controlInput);\r\n                self.createInlineStyle(self.canvas, 'canvas-datagrid');\r\n                self.ctx = self.canvas.getContext('2d');\r\n                self.ctx.textBaseline = 'alphabetic';\r\n                self.eventParent = self.canvas;\r\n            }\r\n            self.parentNodeStyle = self.canvas.style;\r\n            self.controlInput.setAttribute('readonly', true);\r\n            self.controlInput.addEventListener('blur', function (e) {\r\n                if (e.target !== self.canvas) {\r\n                    self.hasFocus = false;\r\n                }\r\n            });\r\n            self.eventParent.addEventListener('scroll', self.resize, false);\r\n            self.eventParent.addEventListener('touchstart', self.touchstart, false);\r\n            self.eventParent.addEventListener('mouseup', self.mouseup, false);\r\n            self.eventParent.addEventListener('mousedown', self.mousedown, false);\r\n            self.eventParent.addEventListener('dblclick', self.dblclick, false);\r\n            self.eventParent.addEventListener('click', self.click, false);\r\n            self.eventParent.addEventListener('mousemove', self.mousemove);\r\n            self[self.isChildGrid ? 'parentGrid' : 'eventParent'].addEventListener('wheel', self.scrollWheel, false);\r\n            self.canvas.addEventListener('contextmenu', self.contextmenuEvent, false);\r\n            self.controlInput.addEventListener('copy', self.copy);\r\n            self.controlInput.addEventListener('cut', self.cut);\r\n            self.controlInput.addEventListener('paste', self.paste);\r\n            self.controlInput.addEventListener('keypress', self.keypress, false);\r\n            self.controlInput.addEventListener('keyup', self.keyup, false);\r\n            self.controlInput.addEventListener('keydown', self.keydown, false);\r\n            window.addEventListener('resize', self.resize);\r\n        };\r\n    };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n    'use strict';\r\n    return function (self) {\r\n        /**\r\n         * Converts a integer into a letter A - ZZZZZ...\r\n         * @memberof canvasDatagrid\r\n         * @name integerToAlpha\r\n         * @method\r\n         * @param {column} n The number to convert.\r\n         */\r\n        self.integerToAlpha = function (n) {\r\n            var ordA = 'a'.charCodeAt(0),\r\n                ordZ = 'z'.charCodeAt(0),\r\n                len = ordZ - ordA + 1,\r\n                s = '';\r\n            while (n >= 0) {\r\n                s = String.fromCharCode(n % len + ordA) + s;\r\n                n = Math.floor(n / len) - 1;\r\n            }\r\n            return s;\r\n        };\r\n        /**\r\n         * Inserts a new column before the specified index into the schema.\r\n         * @tutorial schema\r\n         * @memberof canvasDatagrid\r\n         * @name insertColumn\r\n         * @method\r\n         * @param {column} c The column to insert into the schema.\r\n         * @param {number} index The index of the column to insert before.\r\n         */\r\n        self.insertColumn = function (c, index) {\r\n            var s = self.getSchema();\r\n            if (s.length < index) {\r\n                throw new Error('Index is beyond the length of the schema.');\r\n            }\r\n            self.validateColumn(c, s);\r\n            s.splice(index, 0, c);\r\n            self.data.forEach(function (row) {\r\n                self.applyDefaultValue(row, c);\r\n            });\r\n            self.intf.schema = s;\r\n        };\r\n        /**\r\n         * Deletes a column from the schema at the specified index.\r\n         * @memberof canvasDatagrid\r\n         * @name deleteColumn\r\n         * @tutorial schema\r\n         * @method\r\n         * @param {number} index The index of the column to delete.\r\n         */\r\n        self.deleteColumn = function (index) {\r\n            var s = self.getSchema();\r\n            // remove data matching this column name from data\r\n            self.data.forEach(function (row) {\r\n                delete row[s[index].name];\r\n            });\r\n            s.splice(index, 1);\r\n            self.intf.schema = s;\r\n        };\r\n        /**\r\n         * Adds a new column into the schema.\r\n         * @tutorial schema\r\n         * @memberof canvasDatagrid\r\n         * @name addColumn\r\n         * @method\r\n         * @param {column} c The column to add to the schema.\r\n         */\r\n        self.addColumn = function (c) {\r\n            var s = self.getSchema();\r\n            self.validateColumn(c, s);\r\n            s.push(c);\r\n            self.data.forEach(function (row) {\r\n                self.applyDefaultValue(row, c);\r\n            });\r\n            self.intf.schema = s;\r\n        };\r\n        /**\r\n         * Deletes a row from the dataset at the specified index.\r\n         * @memberof canvasDatagrid\r\n         * @name deleteRow\r\n         * @method\r\n         * @param {number} index The index of the row to delete.\r\n         */\r\n        self.deleteRow = function (index) {\r\n            self.originalData.splice(index, 1);\r\n            self.setFilter();\r\n            self.resize(true);\r\n        };\r\n        /**\r\n         * Inserts a new row into the dataset before the specified index.\r\n         * @memberof canvasDatagrid\r\n         * @name insertRow\r\n         * @method\r\n         * @param {object} d data.\r\n         * @param {number} index The index of the row to insert before.\r\n         */\r\n        self.insertRow = function (d, index) {\r\n            if (self.originalData.length < index) {\r\n                throw new Error('Index is beyond the length of the dataset.');\r\n            }\r\n            self.originalData.splice(index, 0, d);\r\n            self.getSchema().forEach(function (c) {\r\n                if (d[c.name] === undefined) {\r\n                    self.applyDefaultValue(self.originalData[index], c);\r\n                }\r\n            });\r\n            self.setFilter();\r\n            self.resize(true);\r\n        };\r\n        /**\r\n         * Adds a new row into the dataset.\r\n         * @memberof canvasDatagrid\r\n         * @name addRow\r\n         * @method\r\n         * @param {object} d data.\r\n         */\r\n        self.addRow = function (d) {\r\n            self.originalData.push(d);\r\n            self.getSchema().forEach(function (c) {\r\n                if (d[c.name] === undefined) {\r\n                    self.applyDefaultValue(self.originalData[self.originalData.length - 1], c);\r\n                }\r\n            });\r\n            self.setFilter();\r\n            self.resize(true);\r\n        };\r\n        /**\r\n         * Sets the height of a given row by index number.\r\n         * @memberof canvasDatagrid\r\n         * @name setRowHeight\r\n         * @method\r\n         * @param {number} rowIndex The index of the row to set.\r\n         * @param {number} height Height to set the row to.\r\n         */\r\n        self.setRowHeight = function (rowIndex, height) {\r\n            self.sizes.rows[rowIndex] = height;\r\n            self.draw(true);\r\n        };\r\n        /**\r\n         * Sets the width of a given column by index number.\r\n         * @memberof canvasDatagrid\r\n         * @name setColumnWidth\r\n         * @method\r\n         * @param {number} colIndex The index of the column to set.\r\n         * @param {number} width Width to set the column to.\r\n         */\r\n        self.setColumnWidth = function (colIndex, width) {\r\n            self.sizes.columns[colIndex] = width;\r\n            self.draw(true);\r\n        };\r\n        /**\r\n         * Removes any changes to the width of the columns due to user or api interaction, setting them back to the schema or style default.\r\n         * @memberof canvasDatagrid\r\n         * @name resetColumnWidths\r\n         * @tutorial schema\r\n         * @method\r\n         */\r\n        self.resetColumnWidths = function () {\r\n            self.sizes.columns = {};\r\n            self.draw(true);\r\n        };\r\n        /**\r\n         * Removes any changes to the height of the rows due to user or api interaction, setting them back to the schema or style default.\r\n         * @memberof canvasDatagrid\r\n         * @name resetRowHeights\r\n         * @tutorial schema\r\n         * @method\r\n         */\r\n        self.resetRowHeights = function () {\r\n            self.sizes.rows = {};\r\n            self.draw(true);\r\n        };\r\n        /**\r\n         * Sets the value of the filter.\r\n         * @memberof canvasDatagrid\r\n         * @name setFilter\r\n         * @method\r\n         * @param {string} column Name of the column to filter.\r\n         * @param {string} value The value to filter for.\r\n         */\r\n        self.setFilter = function (column, value) {\r\n            if (column === undefined && value === undefined) {\r\n                self.columnFilters = {};\r\n            } else if (column && (value === '' || value === undefined)) {\r\n                delete self.columnFilters[column];\r\n            } else {\r\n                self.columnFilters[column] = value;\r\n            }\r\n            self.applyDataTransforms();\r\n        };\r\n        /**\r\n         * Returns the number of pixels to scroll down to line up with row rowIndex.\r\n         * @memberof canvasDatagrid\r\n         * @name findRowScrollTop\r\n         * @method\r\n         * @param {number} rowIndex The row index of the row to scroll find.\r\n         */\r\n        self.findRowScrollTop = function (rowIndex) {\r\n            if (self.scrollCache.y[rowIndex] === undefined) { throw new RangeError('Row index out of range.'); }\r\n            return self.scrollCache.y[rowIndex];\r\n        };\r\n        /**\r\n         * Returns the number of pixels to scroll to the left to line up with column columnIndex.\r\n         * @memberof canvasDatagrid\r\n         * @name findColumnScrollLeft\r\n         * @method\r\n         * @param {number} columnIndex The column index of the column to find.\r\n         */\r\n        self.findColumnScrollLeft = function (columnIndex) {\r\n            var i = Math.max(columnIndex - 1, 0);\r\n            if (self.scrollCache.x[i] === undefined) { throw new Error('Column index out of range.'); }\r\n            return self.scrollCache.x[i] - self.getColummnWidth(self.orders.columns[columnIndex]);\r\n        };\r\n        /**\r\n         * Scrolls to the cell at columnIndex x, and rowIndex y.  If you define both rowIndex and columnIndex additional calculations can be made to center the cell using the target cell's height and width.  Defining only one rowIndex or only columnIndex will result in simpler calculations.\r\n         * @memberof canvasDatagrid\r\n         * @name gotoCell\r\n         * @method\r\n         * @param {number} x The column index of the cell to scroll to.\r\n         * @param {number} y The row index of the cell to scroll to.\r\n         * @param {number} [offsetX=0] Percentage offset the cell should be from the left edge (not including headers).  The default is 0, meaning the cell will appear at the left edge. Valid values are 0 through 1. 1 = Left, 0 = Right, 0.5 = Center.\r\n         * @param {number} [offsetY=0] Percentage offset the cell should be from the top edge (not including headers).  The default is 0, meaning the cell will appear at the top edge. Valid values are 0 through 1. 1 = Bottom, 0 = Top, 0.5 = Center.\r\n         */\r\n        self.gotoCell = function (x, y, offsetX, offsetY) {\r\n            var targetX = x === undefined ? undefined : self.findColumnScrollLeft(x),\r\n                targetY = y === undefined ? undefined : self.findRowScrollTop(y),\r\n                cell,\r\n                sbw = self.scrollBox.width - (self.scrollBox.verticalBarVisible ? self.style.scrollBarWidth : 0),\r\n                sbh = self.scrollBox.height - (self.scrollBox.horizontalBarVisible ? self.style.scrollBarWidth : 0);\r\n            offsetX = offsetX === undefined ? 0 : offsetX;\r\n            offsetY = offsetY === undefined ? 0 : offsetY;\r\n            targetX -= sbw * offsetX;\r\n            targetY -= sbh * offsetY;\r\n            if (x !== undefined && y !== undefined) {\r\n                self.scrollBox.scrollTo(targetX, targetY);\r\n                requestAnimationFrame(function () {\r\n                    cell = self.getVisibleCellByIndex(x, y);\r\n                    // HACK: just don't offset if the target cell cannot be seen\r\n                    // TODO: offset does not work on very small grids, not sure why\r\n                    if (!cell) { return; }\r\n                    targetX += cell.width * offsetX;\r\n                    targetY += cell.height * offsetY;\r\n                    self.scrollBox.scrollTo(targetX, targetY);\r\n                });\r\n            } else if (x !== undefined) {\r\n                self.scrollBox.scrollLeft = targetX;\r\n            } else if (y !== undefined) {\r\n                self.scrollBox.scrollTop = targetY;\r\n            }\r\n        };\r\n        /**\r\n         * Scrolls the row y.\r\n         * @memberof canvasDatagrid\r\n         * @name gotoRow\r\n         * @method\r\n         * @param {number} y The row index of the cell to scroll to.\r\n         */\r\n        self.gotoRow = function (y) {\r\n            self.gotoCell(0, y);\r\n        };\r\n        /**\r\n         * Scrolls the cell at cell x, row y into view if it is not already.\r\n         * @memberof canvasDatagrid\r\n         * @name scrollIntoView\r\n         * @method\r\n         * @param {number} x The column index of the cell to scroll into view.\r\n         * @param {number} y The row index of the cell to scroll into view.\r\n         * @param {number} [offsetX=0] Percentage offset the cell should be from the left edge (not including headers).  The default is 0, meaning the cell will appear at the left edge. Valid values are 0 through 1. 1 = Left, 0 = Right, 0.5 = Center.\r\n         * @param {number} [offsetY=0] Percentage offset the cell should be from the top edge (not including headers).  The default is 0, meaning the cell will appear at the top edge. Valid values are 0 through 1. 1 = Bottom, 0 = Top, 0.5 = Center.\r\n         */\r\n        self.scrollIntoView = function (x, y, offsetX, offsetY) {\r\n            if (self.visibleCells.filter(function (cell) {\r\n                    return (cell.rowIndex === y || y === undefined)\r\n                        && (cell.columnIndex === x || x === undefined)\r\n                        && cell.x > 0\r\n                        && cell.y > 0\r\n                        && cell.x + cell.width < self.width\r\n                        && cell.y + cell.height < self.height;\r\n                }).length === 0) {\r\n                self.gotoCell(x, y, offsetX, offsetY);\r\n            }\r\n        };\r\n        /**\r\n         * Sets the active cell. Requires redrawing.\r\n         * @memberof canvasDatagrid\r\n         * @name setActiveCell\r\n         * @method\r\n         * @param {number} x The column index of the cell to set active.\r\n         * @param {number} y The row index of the cell to set active.\r\n         */\r\n        self.setActiveCell = function (x, y) {\r\n            if (x < 0) { x = 0; }\r\n            if (y < 0) { y = 0; }\r\n            self.activeCell = {\r\n                rowIndex: y,\r\n                columnIndex: x\r\n            };\r\n        };\r\n        /**\r\n         * Removes the selection.\r\n         * @memberof canvasDatagrid\r\n         * @name selectNone\r\n         * @param {boolean} dontDraw Suppress the draw method after the selection change.\r\n         * @method\r\n         */\r\n        self.selectNone = function (dontDraw) {\r\n            self.selections = [];\r\n            self.dispatchEvent('selectionchanged', {\r\n                selectedData: self.getSelectedData(),\r\n                selections: self.selections,\r\n                selectionBounds: self.selectionBounds\r\n            });\r\n            if (dontDraw) { return; }\r\n            self.draw();\r\n        };\r\n        /**\r\n         * Selects every visible cell.\r\n         * @memberof canvasDatagrid\r\n         * @name selectAll\r\n         * @param {boolean} dontDraw Suppress the draw method after the selection change.\r\n         * @method\r\n         */\r\n        self.selectAll = function (dontDraw) {\r\n            self.selectArea({\r\n                top: 0,\r\n                left: -1,\r\n                right: self.getSchema().length - 1,\r\n                bottom: self.data.length - 1\r\n            });\r\n            if (dontDraw) { return; }\r\n            self.draw();\r\n        };\r\n        /**\r\n         * Returns true if the selected columnIndex is selected on every row.\r\n         * @memberof canvasDatagrid\r\n         * @name isColumnSelected\r\n         * @method\r\n         * @param {number} columnIndex The column index to check.\r\n         */\r\n        self.isColumnSelected = function (columnIndex) {\r\n            var colIsSelected = true;\r\n            self.data.forEach(function (row, rowIndex) {\r\n                if (!self.selections[rowIndex] || self.selections[rowIndex].indexOf(self.orders.columns[columnIndex]) === -1) {\r\n                    colIsSelected = false;\r\n                }\r\n            });\r\n            return colIsSelected;\r\n        };\r\n        /**\r\n         * Runs the defined method on each selected cell.\r\n         * @memberof canvasDatagrid\r\n         * @name forEachSelectedCell\r\n         * @method\r\n         * @param {number} fn The function to execute.  The signature of the function is: (data, rowIndex, columnName).\r\n         * @param {number} expandToRow When true the data in the array is expanded to the entire row.\r\n         */\r\n        self.forEachSelectedCell = function (fn, expandToRow) {\r\n            var d = [], s = expandToRow ? self.getSchema() : self.getVisibleSchema(), l = self.data.length;\r\n            self.selections.forEach(function (row, index) {\r\n                if (index === l) { return; }\r\n                if (row.length === 0) {\r\n                    d[index] = null;\r\n                    return;\r\n                }\r\n                d[index] = {};\r\n                row.forEach(function (col) {\r\n                    if (col === -1 || !s[col]) { return; }\r\n                    fn(self.data, index, s[col].name);\r\n                });\r\n            });\r\n        };\r\n        /**\r\n         * Selects a column.\r\n         * @memberof canvasDatagrid\r\n         * @name selectColumn\r\n         * @method\r\n         * @param {number} columnIndex The column index to select.\r\n         * @param {boolean} toggleSelectMode When true, behaves as if you were holding control/command when you clicked the column.\r\n         * @param {boolean} shift When true, behaves as if you were holding shift when you clicked the column.\r\n         * @param {boolean} supressSelectionchangedEvent When true, prevents the selectionchanged event from firing.\r\n         */\r\n        self.selectColumn = function (columnIndex, ctrl, shift, supressEvent) {\r\n            var s, e, x;\r\n            function addCol(i) {\r\n                self.data.forEach(function (row, rowIndex) {\r\n                    self.selections[rowIndex] = self.selections[rowIndex] || [];\r\n                    if (self.selections[rowIndex].indexOf(i) === -1) {\r\n                        self.selections[rowIndex].push(i);\r\n                    }\r\n                });\r\n            }\r\n            function removeCol(i) {\r\n                self.data.forEach(function (row, rowIndex) {\r\n                    self.selections[rowIndex] = self.selections[rowIndex] || [];\r\n                    if (self.selections[rowIndex].indexOf(i) !== -1) {\r\n                        self.selections[rowIndex].splice(self.selections[rowIndex].indexOf(i), 1);\r\n                    }\r\n                });\r\n            }\r\n            if (shift) {\r\n                if (!self.activeCell) { return; }\r\n                s = Math.min(self.activeCell.columnIndex, columnIndex);\r\n                e = Math.max(self.activeCell.columnIndex, columnIndex);\r\n                for (x = s; e > x; x += 1) {\r\n                    addCol(x);\r\n                }\r\n            }\r\n            if (!ctrl && !shift) {\r\n                self.selections = [];\r\n                self.activeCell.columnIndex = columnIndex;\r\n                self.activeCell.rowIndex = self.scrollIndexTop;\r\n            }\r\n            if (ctrl && self.isColumnSelected(columnIndex)) {\r\n                removeCol(columnIndex);\r\n            } else {\r\n                addCol(columnIndex);\r\n            }\r\n            if (supressEvent) { return; }\r\n            self.dispatchEvent('selectionchanged', {\r\n                selectedData: self.getSelectedData(),\r\n                selections: self.selections,\r\n                selectionBounds: self.getSelectionBounds()\r\n            });\r\n        };\r\n        /**\r\n         * Selects a row.\r\n         * @memberof canvasDatagrid\r\n         * @name selectRow\r\n         * @method\r\n         * @param {number} rowIndex The row index to select.\r\n         * @param {boolean} ctrl When true, behaves as if you were holding control/command when you clicked the row.\r\n         * @param {boolean} shift When true, behaves as if you were holding shift when you clicked the row.\r\n         * @param {boolean} supressSelectionchangedEvent When true, prevents the selectionchanged event from firing.\r\n         */\r\n        self.selectRow = function (rowIndex, ctrl, shift, supressEvent) {\r\n            var x, st, en, s = self.getVisibleSchema();\r\n            function de() {\r\n                if (supressEvent) { return; }\r\n                self.dispatchEvent('selectionchanged', {\r\n                    selectedData: self.getSelectedData(),\r\n                    selections: self.selections,\r\n                    selectionBounds: self.selectionBounds\r\n                });\r\n            }\r\n            function addRow(ri) {\r\n                self.selections[ri] = [];\r\n                self.selections[ri].push(-1);\r\n                s.forEach(function (col, index) {\r\n                    self.selections[ri].push(self.orders.columns.indexOf(col.index));\r\n                });\r\n            }\r\n            if (self.dragAddToSelection === false || self.dragObject === undefined) {\r\n                if (self.selections[rowIndex] && self.selections[rowIndex].length - 1 === s.length) {\r\n                    if (ctrl) {\r\n                        self.selections[rowIndex] = [];\r\n                        de();\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            if (self.dragAddToSelection === true || self.dragObject === undefined) {\r\n                if (shift && self.dragObject === undefined) {\r\n                    if (!self.activeCell) { return; }\r\n                    st = Math.min(self.activeCell.rowIndex, rowIndex);\r\n                    en = Math.max(self.activeCell.rowIndex, rowIndex);\r\n                    for (x = st; en >= x; x += 1) {\r\n                        addRow(x);\r\n                    }\r\n                } else {\r\n                    addRow(rowIndex);\r\n                }\r\n            }\r\n            de();\r\n        };\r\n        /**\r\n         * Collapse a tree grid by row index.\r\n         * @memberof canvasDatagrid\r\n         * @name collapseTree\r\n         * @method\r\n         * @param {number} index The index of the row to collapse.\r\n         */\r\n        self.collapseTree = function (rowIndex) {\r\n            self.dispatchEvent('collapsetree', {\r\n                childGrid: self.childGrids[rowIndex],\r\n                data: self.data[rowIndex],\r\n                rowIndex: rowIndex\r\n            });\r\n            self.openChildren[rowIndex].blur();\r\n            self.openChildren[rowIndex].dispose();\r\n            delete self.openChildren[rowIndex];\r\n            delete self.sizes.trees[rowIndex];\r\n            delete self.childGrids[rowIndex];\r\n            self.dispatchEvent('resizerow', {\r\n                cellHeight: self.style.cellHeight\r\n            });\r\n            self.resize(true);\r\n            self.draw(true);\r\n        };\r\n        /**\r\n         * Expands a tree grid by row index.\r\n         * @memberof canvasDatagrid\r\n         * @name expandTree\r\n         * @method\r\n         * @param {number} index The index of the row to expand.\r\n         */\r\n        self.expandTree = function (rowIndex) {\r\n            var trArgs = self.args.treeGridAttributes || {},\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n                rowHeaderCellWidth = self.sizes.columns.cornerCell || self.style.rowHeaderCellWidth,\r\n                h = self.sizes.trees[rowIndex] || self.style.treeGridHeight,\r\n                treeGrid;\r\n            if (!self.childGrids[rowIndex]) {\r\n                trArgs.debug = self.attributes.debug;\r\n                trArgs.name = self.attributes.saveAppearance ? self.attributes.name + 'tree' + rowIndex : undefined;\r\n                trArgs.style = trArgs.style || self.style;\r\n                trArgs.parentNode = {\r\n                    parentGrid: self.intf,\r\n                    nodeType: 'canvas-datagrid-tree',\r\n                    offsetHeight: h,\r\n                    offsetWidth: self.width - rowHeaderCellWidth,\r\n                    header: { width: self.width - rowHeaderCellWidth },\r\n                    offsetLeft: rowHeaderCellWidth,\r\n                    offsetTop: columnHeaderCellHeight,\r\n                    offsetParent: self.intf.parentNode,\r\n                    parentNode: self.intf.parentNode,\r\n                    style: 'tree',\r\n                    data: self.data[rowIndex]\r\n                };\r\n                treeGrid = self.createGrid(trArgs);\r\n                self.childGrids[rowIndex] = treeGrid;\r\n            }\r\n            treeGrid = self.childGrids[rowIndex];\r\n            treeGrid.visible = true;\r\n            self.dispatchEvent('expandtree', {\r\n                treeGrid: treeGrid,\r\n                data: self.data[rowIndex],\r\n                rowIndex: rowIndex\r\n            });\r\n            self.openChildren[rowIndex] = treeGrid;\r\n            self.sizes.trees[rowIndex] = h;\r\n            self.dispatchEvent('resizerow', {height: self.style.cellHeight});\r\n            self.resize(true);\r\n        };\r\n        /**\r\n         * Toggles tree grid open and close by row index.\r\n         * @memberof canvasDatagrid\r\n         * @name toggleTree\r\n         * @method\r\n         * @param {number} index The index of the row to toggle.\r\n         */\r\n        self.toggleTree = function (rowIndex) {\r\n            var i = self.openChildren[rowIndex];\r\n            if (i) {\r\n                return self.collapseTree(rowIndex);\r\n            }\r\n            self.expandTree(rowIndex);\r\n        };\r\n        /**\r\n         * Returns a header from the schema by name.\r\n         * @memberof canvasDatagrid\r\n         * @name getHeaderByName\r\n         * @tutorial schema\r\n         * @method\r\n         * @returns {header} header with the selected name, or undefined.\r\n         * @param {string} name The name of the column to resize.\r\n         */\r\n        self.getHeaderByName = function (name) {\r\n            var x, i = self.getSchema();\r\n            for (x = 0; x < i.length; x += 1) {\r\n                if (i[x].name === name) {\r\n                    return i[x];\r\n                }\r\n            }\r\n        };\r\n        /**\r\n         * Resizes a column to fit the longest value in the column. Call without a value to resize all columns.\r\n         * Warning, can be slow on very large record sets (1m records ~3-5 seconds on an i7).\r\n         * @memberof canvasDatagrid\r\n         * @name fitColumnToValues\r\n         * @method\r\n         * @param {string} name The name of the column to resize.\r\n         */\r\n        self.fitColumnToValues = function (name, internal) {\r\n            if (!self.canvas) { return; }\r\n            self.sizes.columns[name === 'cornerCell' ? -1 : self.getHeaderByName(name).index]\r\n                = Math.max(self.findColumnMaxTextLength(name), self.style.minColumnWidth);\r\n            if (!internal) {\r\n                self.resize();\r\n                self.draw(true);\r\n            }\r\n        };\r\n        /**\r\n         * Checks if a cell is currently visible.\r\n         * @memberof canvasDatagrid\r\n         * @name isCellVisible\r\n         * @overload\r\n         * @method\r\n         * @returns {boolean} when true, the cell is visible, when false the cell is not currently drawn.\r\n         * @param {number} columnIndex The column index of the cell to check.\r\n         * @param {number} rowIndex The row index of the cell to check.\r\n         */\r\n        /**\r\n         * Checks if a cell is currently visible.\r\n         * @memberof canvasDatagrid\r\n         * @name isCellVisible\r\n         * @method\r\n         * @returns {boolean} when true, the cell is visible, when false the cell is not currently drawn.\r\n         * @param {cell} cell The cell to check for.  Alternatively you can pass an object { x: <x-pixel-value>, y: <y-pixel-value> }.\r\n         */\r\n        self.isCellVisible = function (cell, rowIndex) {\r\n            // overload\r\n            if (rowIndex !== undefined) {\r\n                return self.visibleCells.filter(function (c) {\r\n                    return c.columnIndex === cell && c.rowIndex === rowIndex;\r\n                }).length > 0;\r\n            }\r\n            var x, l = self.visibleCells.length;\r\n            for (x = 0; x < l; x += 1) {\r\n                if (cell.x === self.visibleCells[x].x && cell.y === self.visibleCells[x].y) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        /**\r\n         * Sets the order of the data.\r\n         * @memberof canvasDatagrid\r\n         * @name order\r\n         * @method\r\n         * @param {number} columnName Name of the column to be sorted.\r\n         * @param {string} direction `asc` for ascending or `desc` for descending.\r\n         * @param {function} [sortFunction] When defined, override the default sorting method defined in the column's schema and use this one.\r\n         * @param {bool} [dontSetStorageData] Don't store this setting for future use.\r\n         */\r\n        self.order = function (columnName, direction, sortFunction, dontSetStorageData) {\r\n            var f,\r\n                c = self.getSchema().filter(function (col) {\r\n                    return col.name === columnName;\r\n                });\r\n            if (self.dispatchEvent('beforesortcolumn', {name: columnName, direction: direction})) { return; }\r\n            self.orderBy = columnName;\r\n            self.orderDirection = direction;\r\n            if (!self.data || self.data.length === 0) { return; }\r\n            if (c.length === 0) {\r\n                throw new Error('Cannot sort.  No such column name');\r\n            }\r\n            f = sortFunction || c[0].sorter || self.sorters[c[0].type];\r\n            if (!f && c[0].type !== undefined) {\r\n                console.warn('Cannot sort type \"%s\" falling back to string sort.', c[0].type);\r\n            }\r\n            self.orderings.add(columnName, direction, (typeof f === 'function' ? f : self.sorters.string));\r\n            self.orderings.sort();\r\n            self.dispatchEvent('sortcolumn', {name: columnName, direction: direction});\r\n            self.draw(true);\r\n            if (dontSetStorageData) { return; }\r\n            self.setStorageData();\r\n        };\r\n        self.isInGrid = function (e) {\r\n            if (e.x < 0\r\n                    || e.x > self.width\r\n                    || e.y < 0\r\n                    || e.y > self.height) {\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n        /**\r\n         * Moves the current selection relative to the its current position.  Note: this method does not move the selected data, just the selection itself.\r\n         * @memberof canvasDatagrid\r\n         * @name moveSelection\r\n         * @method\r\n         * @param {number} offsetX The number of columns to offset the selection.\r\n         * @param {number} offsetY The number of rows to offset the selection.\r\n         */\r\n        self.moveSelection = function (offsetX, offsetY) {\r\n            var sel = [];\r\n            self.selections.forEach(function (row, rowIndex) {\r\n                sel[rowIndex + offsetY] = [];\r\n                row.forEach(function (colIndex) {\r\n                    sel[rowIndex + offsetY].push(colIndex + offsetX);\r\n                });\r\n            });\r\n            self.selections = sel;\r\n        };\r\n        /**\r\n         * Moves data in the provided selection to another position in the grid.  Moving data off the edge of the schema (columns/x) will truncate data.\r\n         * @memberof canvasDatagrid\r\n         * @name moveTo\r\n         * @method\r\n         * @param {array} sel 2D array representing selected rows and columns.  `canvasDatagrid.selections` is in this format and can be used here.\r\n         * @param {number} x The column index to start inserting the selection at.\r\n         * @param {number} y The row index to start inserting the selection at.\r\n         */\r\n        self.moveTo = function (sel, x, y) {\r\n            var d = self.getSelectedData(),\r\n                s = self.getVisibleSchema(),\r\n                l = sel.length,\r\n                xi,\r\n                maxRowLength = -Infinity,\r\n                minXi = Infinity,\r\n                yi = y - 1;\r\n            sel.forEach(function (row, index) {\r\n                if (index === l) { return; }\r\n                if (row.length === 0) { return; }\r\n                minXi = Math.min(self.getVisibleColumnIndexOf(x), minXi);\r\n                maxRowLength = Math.max(maxRowLength, row.length);\r\n                row.forEach(function (colIndex) {\r\n                    // intentional redef of colIndex\r\n                    colIndex = self.getVisibleColumnIndexOf(colIndex);\r\n                    if (!s[colIndex]) { return; }\r\n                    if (!self.data[index]) { self.data[index] = {}; }\r\n                    self.data[index][s[colIndex].name] = null;\r\n                });\r\n            });\r\n            sel.forEach(function (row, index) {\r\n                var lastSourceIndex;\r\n                yi += 1;\r\n                xi = self.getVisibleColumnIndexOf(x);\r\n                row.forEach(function (colIndex, cidx) {\r\n                    colIndex = self.getVisibleColumnIndexOf(colIndex);\r\n                    if (cidx > 0) {\r\n                        // this confusing bit of nonsense figures out\r\n                        // if the selection has skipped cells\r\n                        xi += colIndex - lastSourceIndex;\r\n                    }\r\n                    lastSourceIndex = colIndex;\r\n                    if (colIndex === -1\r\n                            || !s[xi]\r\n                            || !s[colIndex]\r\n                            || self.data.length - 1 < yi\r\n                            || yi < 0) { return; }\r\n                    if (!self.data[yi]) { self.data[yi] = {}; }\r\n                    self.data[yi][s[xi].name] = d[index][s[colIndex].name];\r\n                });\r\n            });\r\n        };\r\n        /**\r\n         * Checks if a given column is visible.\r\n         * @memberof canvasDatagrid\r\n         * @name isColumnVisible\r\n         * @method\r\n         * @returns {boolean} When true, the column is visible.\r\n         * @param {number} columnIndex Column index.\r\n         */\r\n        self.isColumnVisible = function (columnIndex) {\r\n            return self.visibleCells.filter(function (c) {\r\n                return c.columnIndex === columnIndex;\r\n            }).length > 0;\r\n        };\r\n        /**\r\n         * Checks if a given row is visible.\r\n         * @memberof canvasDatagrid\r\n         * @name isRowVisible\r\n         * @method\r\n         * @returns {boolean} When true, the row is visible.\r\n         * @param {number} rowIndex Row index.\r\n         */\r\n        self.isRowVisible = function (rowIndex) {\r\n            return self.visibleCells.filter(function (c) {\r\n                return c.rowIndex === rowIndex;\r\n            }).length > 0;\r\n        };\r\n        /**\r\n         * Gets the cell at columnIndex and rowIndex.\r\n         * @memberof canvasDatagrid\r\n         * @name getVisibleCellByIndex\r\n         * @method\r\n         * @returns {cell} cell at the selected location.\r\n         * @param {number} x Column index.\r\n         * @param {number} y Row index.\r\n         */\r\n        self.getVisibleCellByIndex = function (x, y) {\r\n            return self.visibleCells.filter(function (c) {\r\n                return c.columnIndex === x && c.rowIndex === y;\r\n            })[0];\r\n        };\r\n        /**\r\n         * Gets the cell at grid pixel coordinate x and y.  Author's note.  This function ties drawing and events together.  This is a very complex function and is core to the component.\r\n         * @memberof canvasDatagrid\r\n         * @name getCellAt\r\n         * @method\r\n         * @returns {cell} cell at the selected location.\r\n         * @param {number} x Number of pixels from the left.\r\n         * @param {number} y Number of pixels from the top.\r\n         */\r\n        self.getCellAt = function (x, y, useTouchScrollZones) {\r\n            function getBorder(entitiy) {\r\n                if (entitiy.x + entitiy.width - (self.attributes.borderResizeZone * 0.4) < x && entitiy.x + entitiy.width + (self.attributes.borderResizeZone * 0.6) > x) {\r\n                    return 'r';\r\n                }\r\n                if (entitiy.x - (self.attributes.borderResizeZone * 0.4) < x && entitiy.x + (self.attributes.borderResizeZone * 0.6) > x) {\r\n                    return 'l';\r\n                }\r\n                if (entitiy.y + entitiy.height - (self.attributes.borderResizeZone * 0.4) < y && entitiy.y + entitiy.height + (self.attributes.borderResizeZone * 0.6) > y) {\r\n                    return 'b';\r\n                }\r\n                if (entitiy.y - (self.attributes.borderResizeZone * 0.4) < y && entitiy.y + (self.attributes.borderResizeZone * 0.6) > y) {\r\n                    return 't';\r\n                }\r\n            }\r\n            if (!self.visibleCells) { return; }\r\n            var border,\r\n                tsz = useTouchScrollZones ? self.attributes.touchScrollZone : 0,\r\n                moveMode = self.attributes.borderDragBehavior === 'move',\r\n                i,\r\n                l = self.visibleCells.length,\r\n                moveBorder,\r\n                xBorderBehavior = moveMode ? self.cursorGrab : 'ew-resize',\r\n                yBorderBehavior = moveMode ? self.cursorGrab : 'ns-resize',\r\n                cell,\r\n                entitiy;\r\n            if (!self.visibleCells || !self.visibleCells.length) { return; }\r\n            self.hasFocus = true;\r\n            if (!(y < self.height\r\n                && y > 0\r\n                && x < self.width\r\n                && x > 0)) {\r\n                self.hasFocus = false;\r\n                return {\r\n                    dragContext: 'inherit',\r\n                    context: 'inherit'\r\n                };\r\n            }\r\n            for (i = 0; i < l; i += 1) {\r\n                cell = self.visibleCells[i];\r\n                // interactive dimensions of the cell.  used for touch \"over size\" zones\r\n                entitiy = {\r\n                    x: cell.x,\r\n                    y: cell.y,\r\n                    height: cell.height,\r\n                    width: cell.width\r\n                };\r\n                if (useTouchScrollZones && /(vertical|horizontal)-scroll-/.test(cell.style)) {\r\n                    entitiy.x -= tsz;\r\n                    entitiy.y -= tsz;\r\n                    entitiy.height += tsz;\r\n                    entitiy.width += tsz;\r\n                }\r\n                if (entitiy.x - self.style.cellBorderWidth < x\r\n                        && entitiy.x + entitiy.width + self.style.cellBorderWidth > x\r\n                        && entitiy.y - self.style.cellBorderWidth < y\r\n                        && entitiy.y + entitiy.height + self.style.cellBorderWidth > y) {\r\n                    if (/frozen-row-marker/.test(cell.style)) {\r\n                        cell.dragContext = cell.style;\r\n                        cell.context = 'row-resize';\r\n                        return cell;\r\n                    }\r\n                    if (/frozen-column-marker/.test(cell.style)) {\r\n                        cell.dragContext = cell.style;\r\n                        cell.context = 'col-resize';\r\n                        return cell;\r\n                    }\r\n                    if (/selection-handle-/.test(cell.style)) {\r\n                        cell.dragContext = cell.style;\r\n                        cell.context = 'crosshair';\r\n                        return cell;\r\n                    }\r\n                    if (/vertical-scroll-(bar|box)/.test(cell.style)) {\r\n                        cell.dragContext = 'vertical-scroll-box';\r\n                        cell.context = 'vertical-scroll-box';\r\n                        cell.isScrollBar = true;\r\n                        cell.isVerticalScrollBar = true;\r\n                        if (y > self.scrollBox.box.v.y + self.scrollBox.scrollBoxHeight) {\r\n                            cell.dragContext = 'vertical-scroll-bottom';\r\n                            cell.context = 'vertical-scroll-bottom';\r\n                        } else if (y < self.scrollBox.box.v.y) {\r\n                            cell.dragContext = 'vertical-scroll-top';\r\n                            cell.context = 'vertical-scroll-top';\r\n                        }\r\n                        self.cursor = 'default';\r\n                        return cell;\r\n                    }\r\n                    if (/horizontal-scroll-(bar|box)/.test(cell.style)) {\r\n                        cell.dragContext = 'horizontal-scroll-box';\r\n                        cell.context = 'horizontal-scroll-box';\r\n                        cell.isScrollBar = true;\r\n                        cell.isHorizontalScrollBar = true;\r\n                        if (x > self.scrollBox.box.h.x + self.scrollBox.scrollBoxWidth) {\r\n                            cell.dragContext = 'horizontal-scroll-right';\r\n                            cell.context = 'horizontal-scroll-right';\r\n                        } else if (x < self.scrollBox.box.h.x) {\r\n                            cell.dragContext = 'horizontal-scroll-left';\r\n                            cell.context = 'horizontal-scroll-left';\r\n                        }\r\n                        self.cursor = 'default';\r\n                        return cell;\r\n                    }\r\n                    border = getBorder(entitiy);\r\n                    // check if the border of this cell is the border of the selection and if so show move cursor in move mode\r\n                    moveBorder = moveMode && cell.selectionBorder && cell.selectionBorder.indexOf(border) !== -1;\r\n                    if (['l', 'r'].indexOf(border) !== -1\r\n                            && (self.attributes.allowColumnResize || moveBorder)\r\n                            && ((self.attributes.allowColumnResizeFromCell && cell.isNormal) || !cell.isNormal || moveBorder)\r\n                            && ((self.attributes.allowRowHeaderResize && (cell.isRowHeader || cell.isCorner)) || !(cell.isRowHeader && cell.isCorner))) {\r\n                        if (((cell.isColumnHeader || cell.isCorner) || (self.attributes.allowColumnResizeFromCell && cell.isNormal)) && border === 'r') {\r\n                            cell.context = 'ew-resize';\r\n                            cell.dragContext = 'ew-resize';\r\n                            return cell;\r\n                        }\r\n                        if (!(cell.isColumnHeader || cell.isCorner) && moveBorder) {\r\n                            cell.context = xBorderBehavior;\r\n                            cell.dragContext = border + '-move';\r\n                            return cell;\r\n                        }\r\n                    }\r\n                    if (['t', 'b'].indexOf(border) !== -1\r\n                            && cell.rowIndex > -1\r\n                            && (self.attributes.allowRowResize || moveBorder)\r\n                            && ((self.attributes.allowRowResizeFromCell && cell.isNormal) || !cell.isNormal || moveBorder)\r\n                            && !cell.isColumnHeader) {\r\n                        if (((cell.isRowHeader || cell.isCorner) || (self.attributes.allowRowResizeFromCell && cell.isNormal)) && border === 'b') {\r\n                            cell.context = 'ns-resize';\r\n                            cell.dragContext = 'ns-resize';\r\n                            return cell;\r\n                        }\r\n                        if (!(cell.isRowHeader || cell.isCorner) && moveBorder) {\r\n                            cell.context = yBorderBehavior;\r\n                            cell.dragContext = border + '-move';\r\n                            return cell;\r\n                        }\r\n                    }\r\n                    if (cell.style === 'columnHeaderCell') {\r\n                        cell.context = 'cell';\r\n                        cell.dragContext = 'column-reorder';\r\n                        return cell;\r\n                    }\r\n                    if (cell.style === 'rowHeaderCell') {\r\n                        if ((self.attributes.rowGrabZoneSize + (cell.y - self.style.cellBorderWidth) < y)\r\n                                || !self.attributes.allowRowReordering) {\r\n                            cell.dragContext = 'cell';\r\n                            cell.context = 'cell';\r\n                        } else {\r\n                            cell.context = self.cursorGrab;\r\n                            cell.dragContext = 'row-reorder';\r\n                        }\r\n                        return cell;\r\n                    }\r\n                    if (cell.isGrid) {\r\n                        self.hasFocus = false;\r\n                        cell.dragContext = 'cell-grid';\r\n                        cell.context = 'cell-grid';\r\n                        return cell;\r\n                    }\r\n                    if (cell.style === 'tree-grid') {\r\n                        self.hasFocus = false;\r\n                        cell.dragContext = 'tree';\r\n                        cell.context = 'tree';\r\n                        return cell;\r\n                    }\r\n                    cell.dragContext = 'cell';\r\n                    cell.context = 'cell';\r\n                    return cell;\r\n                }\r\n            }\r\n            self.hasFocus = true;\r\n            self.cursor = 'default';\r\n            return {\r\n                dragContext: 'background',\r\n                context: 'background',\r\n                style: 'background',\r\n                isBackground: true\r\n            };\r\n        };\r\n        /**\r\n         * Gets the bounds of current selection. \r\n         * @returns {rect} selection.\r\n         * @memberof canvasDatagrid\r\n         * @name getSelectionBounds\r\n         * @method\r\n         */\r\n        self.getSelectionBounds = function () {\r\n            var low = {x: Infinity, y: Infinity},\r\n                high = {x: -Infinity, y: -Infinity};\r\n            self.selections.forEach(function (row, rowIndex) {\r\n                var maxCol, minCol;\r\n                low.y = rowIndex < low.y ? rowIndex : low.y;\r\n                high.y = rowIndex > high.y ? rowIndex : high.y;\r\n                maxCol = Math.max.apply(null, row);\r\n                minCol = Math.min.apply(null, row);\r\n                low.x = minCol < low.x ? minCol : low.x;\r\n                high.x = maxCol > high.x ? maxCol : high.x;\r\n            });\r\n            return {\r\n                top: low.y,\r\n                left: low.x,\r\n                bottom: high.y,\r\n                right: high.x\r\n            };\r\n        };\r\n        /**\r\n         * Returns an auto generated schema based on data structure.\r\n         * @memberof canvasDatagrid\r\n         * @name getSchemaFromData\r\n         * @method\r\n         * @tutorial schema\r\n         * @returns {schema} schema A schema based on the first item in the data array.\r\n         */\r\n        self.getSchemaFromData = function (d) {\r\n            d = d || self.data;\r\n            return Object.keys(d[0] || {' ': ''}).map(function mapEachSchemaColumn(key, index) {\r\n                var type = self.getBestGuessDataType(key, d),\r\n                    i = {\r\n                        name: key,\r\n                        title: isNaN(parseInt(key, 10)) ? key : self.integerToAlpha(key).toUpperCase(),\r\n                        index: index,\r\n                        type: type,\r\n                        filter: self.filter(type)\r\n                    };\r\n                if (self.storedSettings\r\n                        && self.storedSettings.visibility\r\n                        && self.storedSettings.visibility[i.name] !== undefined) {\r\n                    i.hidden = !self.storedSettings.visibility[i.name];\r\n                }\r\n                return i;\r\n            });\r\n        };\r\n        /**\r\n         * Clears the change log grid.changes that keeps track of changes to the data set.\r\n         * This does not undo changes or alter data it is simply a convince array to keep\r\n         * track of changes made to the data since last this method was called.\r\n         * @memberof canvasDatagrid\r\n         * @name clearChangeLog\r\n         * @method\r\n         */\r\n        self.clearChangeLog = function () {\r\n            self.changes = [];\r\n        };\r\n        /**\r\n         * Selects an area of the grid.\r\n         * @memberof canvasDatagrid\r\n         * @name selectArea\r\n         * @method\r\n         * @param {rect} bounds A rect object representing the selected values.\r\n         */\r\n        self.selectArea = function (bounds, ctrl) {\r\n            self.selectionBounds = bounds || self.selectionBounds;\r\n            var ev, x, y, s = self.getSchema();\r\n            if (!ctrl) {\r\n                self.selections = [];\r\n            }\r\n            if (self.selectionBounds.top < -1\r\n                    || self.selectionBounds.bottom > self.data.length\r\n                    || self.selectionBounds.left < -1\r\n                    || self.selectionBounds.right > s.length) {\r\n                throw new Error('Impossible selection area');\r\n            }\r\n            for (x = self.selectionBounds.top; x <= self.selectionBounds.bottom; x += 1) {\r\n                self.selections[x] = [];\r\n                for (y = self.selectionBounds.left; y <= self.selectionBounds.right; y += 1) {\r\n                    if (self.selections[x].indexOf(y) === -1) {\r\n                        self.selections[x].push(y);\r\n                    }\r\n                }\r\n            }\r\n            ev = {\r\n                selections: self.selections,\r\n                selectionBounds: self.selectionBounds\r\n            };\r\n            Object.defineProperty(ev, 'selectedData', {\r\n                get: function () {\r\n                    return self.getSelectedData();\r\n                }\r\n            });\r\n            self.dispatchEvent('selectionchanged', ev);\r\n        };\r\n        /**\r\n         * Returns the maximum text width for a given column by column name.\r\n         * @memberof canvasDatagrid\r\n         * @name findColumnMaxTextLength\r\n         * @method\r\n         * @returns {number} The number of pixels wide the maximum width value in the selected column.\r\n         * @param {string} name The name of the column to calculate the value's width of.\r\n         */\r\n        self.findColumnMaxTextLength = function (name) {\r\n            var m = -Infinity;\r\n            if (name === 'cornerCell') {\r\n                self.ctx.font = self.style.rowHeaderCellFont;\r\n                return self.ctx.measureText((self.data.length + (self.attributes.showNewRow ? 1 : 0)).toString()).width\r\n                    + self.style.autosizePadding + self.style.autosizeHeaderCellPadding\r\n                    + self.style.rowHeaderCellPaddingRight\r\n                    + self.style.rowHeaderCellPaddingLeft\r\n                    + (self.attributes.tree ? self.style.treeArrowWidth\r\n                        + self.style.treeArrowMarginLeft + self.style.treeArrowMarginRight : 0);\r\n            }\r\n            self.getSchema().forEach(function (col) {\r\n                if (col.name !== name) { return; }\r\n                self.ctx.font = self.style.columnHeaderCellFont;\r\n                var t = self.ctx.measureText(col.title || col.name).width\r\n                    + self.style.headerCellPaddingRight\r\n                    + self.style.headerCellPaddingLeft;\r\n                m = t > m ? t : m;\r\n            });\r\n            self.data.forEach(function (row) {\r\n                self.ctx.font = self.style.cellFont;\r\n                var t = self.ctx.measureText(row[name]).width\r\n                    + self.style.cellPaddingRight\r\n                    + self.style.cellPaddingLeft + self.style.cellAutoResizePadding;\r\n                m = t > m ? t : m;\r\n            });\r\n            return m;\r\n        };\r\n        /**\r\n         * Gets the total width of all header columns.\r\n         * @memberof canvasDatagrid\r\n         * @name getHeaderWidth\r\n         * @method\r\n         */\r\n        self.getHeaderWidth = function () {\r\n            return self.getVisibleSchema().reduce(function (total, header) {\r\n                return total + (header.width || self.style.cellWidth);\r\n            }, 0);\r\n        };\r\n        /**\r\n         * Gets the height of a row by index.\r\n         * @memberof canvasDatagrid\r\n         * @name getRowHeight\r\n         * @method\r\n         * @param {number} rowIndex The row index to lookup.\r\n         */\r\n        self.getRowHeight = function (rowIndex) {\r\n            return ((self.sizes.rows[rowIndex]\r\n                    || self.style.cellHeight) * self.scale);\r\n        };\r\n        /**\r\n         * Gets the width of a column by index.\r\n         * @memberof canvasDatagrid\r\n         * @name getColummnWidth\r\n         * @method\r\n         * @param {number} columnIndex The column index to lookup.\r\n         */\r\n        self.getColummnWidth = function (columnIndex) {\r\n            return ((self.sizes.columns[columnIndex]\r\n                    || self.getSchema()[columnIndex].width\r\n                    || self.style.cellWidth) * self.scale);\r\n        };\r\n        self.formatters.string = function cellFormatterString(e) {\r\n            return e.cell.value !== undefined ? e.cell.value : '';\r\n        };\r\n        self.formatters.rowHeaderCell = self.formatters.string;\r\n        self.formatters.headerCell = self.formatters.string;\r\n        self.formatters.number = self.formatters.string;\r\n        self.formatters.int = self.formatters.string;\r\n        self.formatters.html = self.formatters.string;\r\n        self.sorters.string = function (columnName, direction) {\r\n            var asc = direction === 'asc';\r\n            return function (a, b) {\r\n                if (a[columnName] === undefined || a[columnName] === null) {\r\n                    return 1;\r\n                }\r\n                if (b[columnName] === undefined || b[columnName] === null) {\r\n                    return 0;\r\n                }\r\n                if (asc) {\r\n                    if (!a[columnName].localeCompare) { return 1; }\r\n                    return a[columnName].localeCompare(b[columnName]);\r\n                }\r\n                if (!b[columnName].localeCompare) { return 1; }\r\n                return b[columnName].localeCompare(a[columnName]);\r\n            };\r\n        };\r\n        self.sorters.number = function (columnName, direction) {\r\n            var asc = direction === 'asc';\r\n            return function (a, b) {\r\n                if (asc) {\r\n                    return a[columnName] - b[columnName];\r\n                }\r\n                return b[columnName] - a[columnName];\r\n            };\r\n        };\r\n        self.sorters.date = function (columnName, direction) {\r\n            var asc = direction === 'asc';\r\n            return function (a, b) {\r\n                if (asc) {\r\n                    return new Date(a[columnName]).getTime()\r\n                        - new Date(b[columnName]).getTime();\r\n                }\r\n                return new Date(b[columnName]).getTime()\r\n                        - new Date(a[columnName]).getTime();\r\n            };\r\n        };\r\n    };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// canvas-datagrid.js","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        self.defaults = {\r\n            attributes: [\r\n                ['allowColumnReordering', true],\r\n                ['allowColumnResize', true],\r\n                ['allowColumnResizeFromCell', false],\r\n                ['allowFreezingRows', false],\r\n                ['allowFreezingColumns', false],\r\n                ['allowMovingSelection', true],\r\n                ['allowRowHeaderResize', true],\r\n                ['allowRowReordering', false],\r\n                ['allowRowResize', true],\r\n                ['allowRowResizeFromCell', false],\r\n                ['allowSorting', true],\r\n                ['autoGenerateSchema', false],\r\n                ['autoResizeColumns', false],\r\n                ['borderDragBehavior', 'none'],\r\n                ['borderResizeZone', 10],\r\n                ['clearSettingsOptionText', 'Clear saved settings'],\r\n                ['columnHeaderClickBehavior', 'sort'],\r\n                ['columnSelectorHiddenText', '&nbsp;&nbsp;&nbsp;'],\r\n                ['columnSelectorText', 'Add/Remove columns'],\r\n                ['columnSelectorVisibleText', '\\u2713'],\r\n                ['contextHoverScrollAmount', 2],\r\n                ['contextHoverScrollRateMs', 5],\r\n                ['copyHeadersOnSelectAll', true],\r\n                ['copyText', 'Copy'],\r\n                ['debug', false],\r\n                ['editable', true],\r\n                ['ellipsisText', '...'],\r\n                ['filterOptionText', 'Filter %s'],\r\n                ['filterTextPrefix', '(filtered) '],\r\n                ['globalRowResize', false],\r\n                ['hideColumnText', 'Hide %s'],\r\n                ['maxAutoCompleteItems', 200],\r\n                ['multiLine', false],\r\n                ['name', ''],\r\n                ['pageUpDownOverlap', 1],\r\n                ['pasteText', 'Paste'],\r\n                ['persistantSelectionMode', false],\r\n                ['removeFilterOptionText', 'Remove filter on %s'],\r\n                ['reorderDeadZone', 3],\r\n                ['resizeScrollZone', 20],\r\n                ['rowGrabZoneSize', 5],\r\n                ['saveAppearance', true],\r\n                ['scrollAnimationPPSThreshold', 0.75],\r\n                ['scrollPointerLock', false],\r\n                ['scrollRepeatRate', 75],\r\n                ['selectionFollowsActiveCell', false],\r\n                ['selectionHandleBehavior', 'none'],\r\n                ['selectionMode', 'cell'],\r\n                ['selectionScrollIncrement', 20],\r\n                ['selectionScrollZone', 20],\r\n                ['showClearSettingsOption', true],\r\n                ['showColumnHeaders', true],\r\n                ['showColumnSelector', true],\r\n                ['showCopy', false],\r\n                ['showFilter', true],\r\n                ['showNewRow', false],\r\n                ['showOrderByOption', true],\r\n                ['showOrderByOptionTextAsc', 'Order by %s ascending'],\r\n                ['showOrderByOptionTextDesc', 'Order by %s descending'],\r\n                ['showPaste', false],\r\n                ['showPerformance', false],\r\n                ['showRowHeaders', true],\r\n                ['showRowNumbers', true],\r\n                ['snapToRow', false],\r\n                ['touchContextMenuTimeMs', 800],\r\n                ['touchDeadZone', 3],\r\n                ['touchEasingMethod', 'easeOutQuad'],\r\n                ['touchReleaseAcceleration', 1000],\r\n                ['touchReleaseAnimationDurationMs', 2000],\r\n                ['touchScrollZone', 20],\r\n                ['touchSelectHandleZone', 20],\r\n                ['touchZoomSensitivity', 0.005],\r\n                ['touchZoomMin', 0.5],\r\n                ['touchZoomMax', 1.75],\r\n                ['maxPixelRatio', 2],\r\n                ['tree', false],\r\n                ['treeHorizontalScroll', false]\r\n            ],\r\n            styles: [\r\n                ['activeCellBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n                ['activeCellBorderColor', 'rgba(110, 168, 255, 1)'],\r\n                ['activeCellBorderWidth', 1],\r\n                ['activeCellColor', 'rgba(0, 0, 0, 1)'],\r\n                ['activeCellFont', '16px sans-serif'],\r\n                ['activeCellHoverBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n                ['activeCellHorizontalAlignment', 'left'],\r\n                ['activeCellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n                ['activeCellOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\r\n                ['activeCellOverlayBorderWidth', 1],\r\n                ['activeCellPaddingBottom', 5],\r\n                ['activeCellPaddingLeft', 5],\r\n                ['activeCellPaddingRight', 5],\r\n                ['activeCellPaddingTop', 5],\r\n                ['activeCellSelectedBackgroundColor', 'rgba(236, 243, 255, 1)'],\r\n                ['activeCellSelectedColor', 'rgba(0, 0, 0, 1)'],\r\n                ['activeCellVerticalAlignment', 'center'],\r\n                ['activeColumnHeaderCellBackgroundColor', 'rgba(225, 225, 225, 1)'],\r\n                ['activeColumnHeaderCellColor', 'rgba(0, 0, 0, 1)'],\r\n                ['activeRowHeaderCellBackgroundColor', 'rgba(225, 225, 225, 1)'],\r\n                ['activeRowHeaderCellColor', 'rgba(0, 0, 0, 1)'],\r\n                ['autocompleteBottomMargin', 60],\r\n                ['autosizeHeaderCellPadding', 8],\r\n                ['autosizePadding', 5],\r\n                ['cellAutoResizePadding', 13],\r\n                ['cellBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n                ['cellBorderColor', 'rgba(195, 199, 202, 1)'],\r\n                ['cellBorderWidth', 1],\r\n                ['cellColor', 'rgba(0, 0, 0, 1)'],\r\n                ['cellFont', '16px sans-serif'],\r\n                ['cellGridHeight', 250],\r\n                ['cellHeight', 24],\r\n                ['cellHeightWithChildGrid', 150],\r\n                ['cellHorizontalAlignment', 'left'],\r\n                ['cellHoverBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n                ['cellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n                ['cellPaddingBottom', 5],\r\n                ['cellPaddingLeft', 5],\r\n                ['cellPaddingRight', 5],\r\n                ['cellPaddingTop', 5],\r\n                ['cellSelectedBackgroundColor', 'rgba(236, 243, 255, 1)'],\r\n                ['cellSelectedColor', 'rgba(0, 0, 0, 1)'],\r\n                ['cellVerticalAlignment', 'center'],\r\n                ['cellWidth', 250],\r\n                ['cellWidthWithChildGrid', 250],\r\n                ['cellWhiteSpace', 'nowrap'],\r\n                ['cellLineHeight', 1],\r\n                ['cellLineSpacing', 3],\r\n                ['childContextMenuArrowColor', 'rgba(43, 48, 43, 1)'],\r\n                ['childContextMenuArrowHTML', '&#x25BA;'],\r\n                ['childContextMenuMarginLeft', -11],\r\n                ['childContextMenuMarginTop', -6],\r\n                ['columnHeaderCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['columnHeaderCellBorderColor', 'rgba(172, 172, 172, 1)'],\r\n                ['columnHeaderCellBorderWidth', 1],\r\n                ['columnHeaderCellCapBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['columnHeaderCellCapBorderColor', 'rgba(172, 172, 172, 1)'],\r\n                ['columnHeaderCellCapBorderWidth', 1],\r\n                ['columnHeaderCellColor', 'rgba(50, 50, 50, 1)'],\r\n                ['columnHeaderCellFont', '16px sans-serif'],\r\n                ['columnHeaderCellHeight', 25],\r\n                ['columnHeaderCellHorizontalAlignment', 'left'],\r\n                ['columnHeaderCellHoverBackgroundColor', 'rgba(235, 235, 235, 1)'],\r\n                ['columnHeaderCellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n                ['columnHeaderCellPaddingBottom', 5],\r\n                ['columnHeaderCellPaddingLeft', 5],\r\n                ['columnHeaderCellPaddingRight', 5],\r\n                ['columnHeaderCellPaddingTop', 5],\r\n                ['columnHeaderCellVerticalAlignment', 'center'],\r\n                ['columnHeaderOrderByArrowBorderColor', 'rgba(195, 199, 202, 1)'],\r\n                ['columnHeaderOrderByArrowBorderWidth', 1],\r\n                ['columnHeaderOrderByArrowColor', 'rgba(155, 155, 155, 1)'],\r\n                ['columnHeaderOrderByArrowHeight', 8],\r\n                ['columnHeaderOrderByArrowMarginLeft', 0],\r\n                ['columnHeaderOrderByArrowMarginRight', 5],\r\n                ['columnHeaderOrderByArrowMarginTop', 6],\r\n                ['columnHeaderOrderByArrowWidth', 13],\r\n                ['contextFilterButtonBorder', 'solid 1px rgba(158, 163, 169, 1)'],\r\n                ['contextFilterButtonBorderRadius', '3px'],\r\n                ['contextFilterButtonHTML', '&#x25BC;'],\r\n                ['contextFilterInputBackground', 'rgba(255,255,255,1)'],\r\n                ['contextFilterInputBorder', 'solid 1px rgba(158, 163, 169, 1)'],\r\n                ['contextFilterInputBorderRadius', '0'],\r\n                ['contextFilterInputColor', 'rgba(0,0,0,1)'],\r\n                ['contextFilterInputFontFamily', 'sans-serif'],\r\n                ['contextFilterInputFontSize', '14px'],\r\n                ['contextFilterInvalidRegExpBackground', 'rgba(180, 6, 1, 1)'],\r\n                ['contextFilterInvalidRegExpColor', 'rgba(255, 255, 255, 1)'],\r\n                ['contextMenuArrowColor', 'rgba(43, 48, 43, 1)'],\r\n                ['contextMenuArrowDownHTML', '&#x25BC;'],\r\n                ['contextMenuArrowUpHTML', '&#x25B2;'],\r\n                ['contextMenuBackground', 'rgba(240, 240, 240, 1)'],\r\n                ['contextMenuBorder', 'solid 1px rgba(158, 163, 169, 1)'],\r\n                ['contextMenuBorderRadius', '3px'],\r\n                ['contextMenuChildArrowFontSize', '12px'],\r\n                ['contextMenuColor', 'rgba(43, 48, 43, 1)'],\r\n                ['contextMenuCursor', 'default'],\r\n                ['contextMenuFilterButtonFontFamily', 'sans-serif'],\r\n                ['contextMenuFilterButtonFontSize', '10px'],\r\n                ['contextMenuFilterInvalidExpresion', 'rgba(237, 155, 156, 1)'],\r\n                ['contextMenuFontFamily', 'sans-serif'],\r\n                ['contextMenuFontSize', '16px'],\r\n                ['contextMenuHoverBackground', 'rgba(182, 205, 250, 1)'],\r\n                ['contextMenuHoverColor', 'rgba(43, 48, 153, 1)'],\r\n                ['contextMenuItemBorderRadius', '3px'],\r\n                ['contextMenuItemMargin', '2px'],\r\n                ['contextMenuLabelDisplay', 'inline-block'],\r\n                ['contextMenuLabelMargin', '0 3px 0 0'],\r\n                ['contextMenuLabelMaxWidth', '700px'],\r\n                ['contextMenuLabelMinWidth', '75px'],\r\n                ['contextMenuMarginLeft', 3],\r\n                ['contextMenuMarginTop', -3],\r\n                ['contextMenuOpacity', '0.98'],\r\n                ['contextMenuPadding', '2px'],\r\n                ['contextMenuWindowMargin', 30],\r\n                ['contextMenuZIndex', 10000],\r\n                ['cornerCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['cornerCellBorderColor', 'rgba(202, 202, 202, 1)'],\r\n                ['debugBackgroundColor', 'rgba(0, 0, 0, .0)'],\r\n                ['debugColor', 'rgba(255, 15, 24, 1)'],\r\n                ['debugEntitiesColor', 'rgba(76, 231, 239, 1.00)'],\r\n                ['debugFont', '11px sans-serif'],\r\n                ['debugPerfChartBackground', 'rgba(29, 25, 26, 1.00)'],\r\n                ['debugPerfChartTextColor', 'rgba(255, 255, 255, 0.8)'],\r\n                ['debugPerformanceColor', 'rgba(252, 255, 37, 1.00)'],\r\n                ['debugScrollHeightColor', 'rgba(248, 33, 103, 1.00)'],\r\n                ['debugScrollWidthColor', 'rgba(66, 255, 27, 1.00)'],\r\n                ['debugTouchPPSXColor', 'rgba(246, 102, 24, 1.00)'],\r\n                ['debugTouchPPSYColor', 'rgba(186, 0, 255, 1.00)'],\r\n                ['display', 'inline-block'],\r\n                ['editCellBackgroundColor', 'white'],\r\n                ['editCellBorder', 'solid 1px rgba(110, 168, 255, 1)'],\r\n                ['editCellBoxShadow', '0 2px 5px rgba(0,0,0,0.4)'],\r\n                ['editCellColor', 'black'],\r\n                ['editCellFontFamily', 'sans-serif'],\r\n                ['editCellFontSize', '16px'],\r\n                ['editCellPaddingLeft', 4],\r\n                ['editCellZIndex', 10000],\r\n                ['frozenMarkerHoverColor', 'rgba(236, 243, 255, 1)'],\r\n                ['frozenMarkerHoverBorderColor', 'rgba(110, 168, 255, 1)'],\r\n                ['frozenMarkerActiveColor', 'rgba(236, 243, 255, 1)'],\r\n                ['frozenMarkerActiveBorderColor', 'rgba(110, 168, 255, 1)'],\r\n                ['frozenMarkerColor', 'rgba(222, 222, 222, 1)'],\r\n                ['frozenMarkerBorderColor', 'rgba(168, 168, 168, 1)'],\r\n                ['frozenMarkerBorderWidth', 1],\r\n                ['frozenMarkerWidth', 2],\r\n                ['gridBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['gridBorderCollapse', 'collapse'],\r\n                ['gridBorderColor', 'rgba(202, 202, 202, 1)'],\r\n                ['gridBorderWidth', 1],\r\n                ['height', 'auto'],\r\n                ['maxHeight', 'inherit'],\r\n                ['maxWidth', 'inherit'],\r\n                ['minColumnWidth', 45],\r\n                ['minHeight', 'inherit'],\r\n                ['minRowHeight', 24],\r\n                ['minWidth', 'inherit'],\r\n                ['mobileContextMenuMargin', 10],\r\n                ['mobileEditInputHeight', 30],\r\n                ['mobileEditFontFamily', 'sans-serif'],\r\n                ['mobileEditFontSize', '16px'],\r\n                ['moveOverlayBorderWidth', 1],\r\n                ['moveOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\r\n                ['moveOverlayBorderSegments', '12, 7'],\r\n                ['name', 'default'],\r\n                ['overflowY', 'auto'],\r\n                ['overflowX', 'auto'],\r\n                ['reorderMarkerBackgroundColor', 'rgba(0, 0, 0, 0.1)'],\r\n                ['reorderMarkerBorderColor', 'rgba(0, 0, 0, 0.2)'],\r\n                ['reorderMarkerBorderWidth', 1.25],\r\n                ['reorderMarkerIndexBorderColor', 'rgba(66, 133, 244, 1)'],\r\n                ['reorderMarkerIndexBorderWidth', 2.75],\r\n                ['rowHeaderCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['rowHeaderCellBorderColor', 'rgba(200, 200, 200, 1)'],\r\n                ['rowHeaderCellBorderWidth', 1],\r\n                ['rowHeaderCellColor', 'rgba(50, 50, 50, 1)'],\r\n                ['rowHeaderCellFont', '16px sans-serif'],\r\n                ['rowHeaderCellHeight', 25],\r\n                ['rowHeaderCellHorizontalAlignment', 'left'],\r\n                ['rowHeaderCellHoverBackgroundColor', 'rgba(235, 235, 235, 1)'],\r\n                ['rowHeaderCellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n                ['rowHeaderCellPaddingBottom', 5],\r\n                ['rowHeaderCellPaddingLeft', 5],\r\n                ['rowHeaderCellPaddingRight', 5],\r\n                ['rowHeaderCellPaddingTop', 5],\r\n                ['rowHeaderCellSelectedBackgroundColor', 'rgba(217, 217, 217, 1)'],\r\n                ['rowHeaderCellSelectedColor', 'rgba(50, 50, 50, 1)'],\r\n                ['rowHeaderCellVerticalAlignment', 'center'],\r\n                ['rowHeaderCellWidth', 57],\r\n                ['scrollBarActiveColor', 'rgba(125, 125, 125, 1)'],\r\n                ['scrollBarBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['scrollBarBorderColor', 'rgba(202, 202, 202, 1)'],\r\n                ['scrollBarBorderWidth', 0.5],\r\n                ['scrollBarBoxBorderRadius', 4.125],\r\n                ['scrollBarBoxColor', 'rgba(192, 192, 192, 1)'],\r\n                ['scrollBarBoxMargin', 2],\r\n                ['scrollBarBoxMinSize', 15],\r\n                ['scrollBarBoxWidth', 8],\r\n                ['scrollBarCornerBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n                ['scrollBarCornerBorderColor', 'rgba(202, 202, 202, 1)'],\r\n                ['scrollBarWidth', 11],\r\n                ['selectionHandleBorderColor', 'rgba(255, 255, 255, 1)'],\r\n                ['selectionHandleBorderWidth', 1.5],\r\n                ['selectionHandleColor', 'rgba(66, 133, 244, 1)'],\r\n                ['selectionHandleSize', 8],\r\n                ['selectionHandleType', 'square'],\r\n                ['selectionOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\r\n                ['selectionOverlayBorderWidth', 1],\r\n                ['treeArrowBorderColor', 'rgba(195, 199, 202, 1)'],\r\n                ['treeArrowBorderWidth', 1],\r\n                ['treeArrowClickRadius', 5],\r\n                ['treeArrowColor', 'rgba(155, 155, 155, 1)'],\r\n                ['treeArrowHeight', 8],\r\n                ['treeArrowMarginLeft', 0],\r\n                ['treeArrowMarginRight', 5],\r\n                ['treeArrowMarginTop', 6],\r\n                ['treeArrowWidth', 13],\r\n                ['treeGridHeight', 250],\r\n                ['width', 'auto']\r\n            ]\r\n        };\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/defaults.js\n// module id = 0\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true, evil: true*/\r\n/*globals Reflect: false, HTMLElement: true, define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([\r\n    './component',\r\n    './defaults',\r\n    './draw',\r\n    './events',\r\n    './touch',\r\n    './intf',\r\n    './contextMenu',\r\n    './dom',\r\n    './publicMethods'\r\n], function context(component) {\r\n    'use strict';\r\n    component = component();\r\n    var modules = Array.prototype.slice.call(arguments);\r\n    function Grid(args) {\r\n        args = args || {};\r\n        var self = {};\r\n        self.isComponent = args.component === undefined;\r\n        self.isChildGrid = args.parentNode && /canvas-datagrid-(cell|tree)/.test(args.parentNode.nodeType);\r\n        if (self.isChildGrid) {\r\n            self.intf = {};\r\n        } else {\r\n            self.intf = self.isComponent ? eval('Reflect.construct(HTMLElement, [], new.target)')\r\n                : document.createElement('canvas');\r\n        }\r\n        self.args = args;\r\n        self.intf.args = args;\r\n        self.applyComponentStyle = component.applyComponentStyle;\r\n        self.hyphenateProperty = component.hyphenateProperty;\r\n        self.dehyphenateProperty = component.dehyphenateProperty;\r\n        self.createGrid = function grid(args) {\r\n            args.component = false;\r\n            return new Grid(args);\r\n        };\r\n        modules.forEach(function (module) {\r\n            module(self);\r\n        });\r\n        if (self.isChildGrid) {\r\n            self.shadowRoot = args.parentNode.shadowRoot;\r\n            self.parentNode = args.parentNode;\r\n        } else if (self.intf.createShadowRoot) {\r\n            self.shadowRoot = self.intf.attachShadow({mode: 'open'});\r\n            self.parentNode = self.shadowRoot;\r\n        } else {\r\n            self.parentNode = self.intf;\r\n        }\r\n        self.init();\r\n        return self.intf;\r\n    }\r\n    if (window.HTMLElement) {\r\n        Grid.prototype = Object.create(window.HTMLElement.prototype);\r\n    }\r\n    // export web component\r\n    if (window.customElements) {\r\n        Grid.observedAttributes = component.getObservableAttributes();\r\n        Grid.prototype.disconnectedCallback = component.disconnectedCallback;\r\n        Grid.prototype.attributeChangedCallback = component.attributeChangedCallback;\r\n        Grid.prototype.connectedCallback = component.connectedCallback;\r\n        Grid.prototype.adoptedCallback = component.adoptedCallback;\r\n        window.customElements.define('canvas-datagrid', Grid);\r\n    }\r\n    // export global\r\n    if (window && !window.canvasDatagrid && !window.require) {\r\n        window.canvasDatagrid = function (args) { return new Grid(args); };\r\n    }\r\n    // export amd loader\r\n    module.exports = function grid(args) {\r\n        args = args || {};\r\n        var i, tKeys = ['style', 'formatters', 'sorters', 'filters',\r\n                    'treeGridAttributes', 'cellGridAttributes', 'data', 'schema'];\r\n        if (window.customElements && document.body.createShadowRoot) {\r\n            i = document.createElement('canvas-datagrid');\r\n            Object.keys(args).forEach(function (argKey) {\r\n                // set data and parentNode after everything else\r\n                if (argKey === 'data') { return; }\r\n                if (argKey === 'parentNode') { return; }\r\n                // top level keys in args\r\n                if (tKeys.indexOf(argKey) !== -1) {\r\n                    tKeys.forEach(function (tKey) {\r\n                        if (args[tKey] === undefined || tKey !== argKey) { return; }\r\n                        if (['formatters', 'sorters', 'filters'].indexOf(argKey) !== -1) {\r\n                            if (typeof args[tKey] === 'object' && args[tKey] !== null) {\r\n                                Object.keys(args[tKey]).forEach(function (sKey) {\r\n                                    i[tKey][sKey] = args[tKey][sKey];\r\n                                });\r\n                            }\r\n                        } else {\r\n                            i[tKey] = args[tKey];\r\n                        }\r\n                    });\r\n                    return;\r\n                }\r\n                // all others are attribute level keys\r\n                i.attributes[argKey] = args[argKey];\r\n            });\r\n            if (args.data) {\r\n                i.data = args.data;\r\n            }\r\n            // add to the dom very last to avoid redraws\r\n            if (args.parentNode) {\r\n                args.parentNode.appendChild(i);\r\n            }\r\n            return i;\r\n        }\r\n        args.component = false;\r\n        i = new Grid(args);\r\n        if (args.parentNode && args.parentNode.appendChild) {\r\n            args.parentNode.appendChild(i);\r\n        }\r\n        return i;\r\n    };\r\n    return module.exports;\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/main.js\n// module id = 1\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine(['./defaults'], function (defaults) {\r\n    'use strict';\r\n    return function () {\r\n        var typeMap, component = {};\r\n        component.dehyphenateProperty = function hyphenateProperty(prop) {\r\n            prop = prop.replace('--cdg-', '');\r\n            var p = '', nextLetterCap;\r\n            Array.prototype.forEach.call(prop, function (char) {\r\n                if (nextLetterCap) {\r\n                    nextLetterCap = false;\r\n                    p += char.toUpperCase();\r\n                    return;\r\n                }\r\n                if (char === '-') {\r\n                    nextLetterCap = true;\r\n                    return;\r\n                }\r\n                p += char;\r\n            });\r\n            return p;\r\n        };\r\n        component.hyphenateProperty = function hyphenateProperty(prop, cust) {\r\n            var p = '';\r\n            Array.prototype.forEach.call(prop, function (char) {\r\n                if (char === char.toUpperCase()) {\r\n                    p += '-' + char.toLowerCase();\r\n                    return;\r\n                }\r\n                p += char;\r\n            });\r\n            return (cust ? '--cdg-' : '') + p;\r\n        };\r\n        function getDefaultItem(base, item) {\r\n            var i = {},\r\n                r;\r\n            defaults(i);\r\n            r = i.defaults[base].filter(function (i) {\r\n                return i[0].toLowerCase() === item.toLowerCase()\r\n                    || component.hyphenateProperty(i[0]) === item.toLowerCase()\r\n                    || component.hyphenateProperty(i[0], true) === item.toLowerCase();\r\n            })[0];\r\n            return r;\r\n        }\r\n        component.applyComponentStyle = function (supressChangeAndDrawEvents, intf) {\r\n            if (!intf.isComponent) { return; }\r\n            var cStyle = window.getComputedStyle(intf.tagName === 'CANVAS-DATAGRID' ? intf : intf.canvas, null),\r\n                defs = {};\r\n            intf.computedStyle = cStyle;\r\n            defaults(defs);\r\n            defs = defs.defaults.styles;\r\n            defs.forEach(function (def) {\r\n                var val;\r\n                val = cStyle.getPropertyValue(component.hyphenateProperty(def[0], true));\r\n                if (val === \"\") {\r\n                    val = cStyle.getPropertyValue(component.hyphenateProperty(def[0], false));\r\n                }\r\n                if (val !== \"\" && typeof val === 'string') {\r\n                    intf.setStyleProperty(def[0], typeMap[typeof def[1]](val\r\n                        .replace(/^\\s+/, '').replace(/\\s+$/, ''), def[1]), true);\r\n                }\r\n            });\r\n            if (!supressChangeAndDrawEvents && intf.dispatchEvent) {\r\n                requestAnimationFrame(function () { intf.resize(true); });\r\n                intf.dispatchEvent('stylechanged', intf.style);\r\n            }\r\n        };\r\n        typeMap = {\r\n            data: function (strData) {\r\n                try {\r\n                    return JSON.parse(strData);\r\n                } catch (e) {\r\n                    throw new Error('Cannot read JSON data in canvas-datagrid data.');\r\n                }\r\n            },\r\n            schema: function (strSchema) {\r\n                try {\r\n                    return JSON.parse(strSchema);\r\n                } catch (e) {\r\n                    throw new Error('Cannot read JSON data in canvas-datagrid schema attribute.');\r\n                }\r\n            },\r\n            number: function (strNum, def) {\r\n                var n = parseInt(strNum, 10);\r\n                return isNaN(n) ? def : n;\r\n            },\r\n            boolean: function (strBool) {\r\n                return (/true/i).test(strBool);\r\n            },\r\n            string: function (str) {\r\n                return str;\r\n            }\r\n        };\r\n        component.getObservableAttributes = function () {\r\n            var i = {}, attrs = ['data', 'schema', 'style', 'className', 'name'];\r\n            defaults(i);\r\n            i.defaults.attributes.forEach(function (attr) {\r\n                attrs.push(attr[0].toLowerCase());\r\n            });\r\n            return attrs;\r\n        };\r\n        component.disconnectedCallback = function () {\r\n            this.connected = false;\r\n        };\r\n        component.connectedCallback = function () {\r\n            var intf = this;\r\n            intf.parentDOMNode.innerHTML = \"\";\r\n            intf.parentDOMNode.appendChild(intf.canvas);\r\n            intf.connected = true;\r\n            component.observe(intf);\r\n            component.applyComponentStyle(true, intf);\r\n            intf.resize(true);\r\n        };\r\n        component.adoptedCallback = function () {\r\n            this.resize();\r\n        };\r\n        component.attributeChangedCallback = function (attrName, oldVal, newVal) {\r\n            var tfn, intf = this, def;\r\n            if (attrName === 'style') {\r\n                component.applyComponentStyle(false, intf);\r\n                return;\r\n            }\r\n            if (attrName === 'data') {\r\n                if (intf.dataType === 'application/x-canvas-datagrid') {\r\n                    intf.dataType = 'application/json+x-canvas-datagrid';\r\n                }\r\n                intf.args.data = newVal;\r\n                return;\r\n            }\r\n            if (attrName === 'schema') {\r\n                intf.args.schema = typeMap.schema(newVal);\r\n                return;\r\n            }\r\n            if (attrName === 'name') {\r\n                intf.name = newVal;\r\n                return;\r\n            }\r\n            if (attrName === 'class' || attrName === 'className') {\r\n                return;\r\n            }\r\n            def = getDefaultItem('attributes', attrName);\r\n            if (def) {\r\n                tfn = typeMap[typeof def[1]];\r\n                intf.attributes[def[0]] = tfn(newVal);\r\n                return;\r\n            }\r\n            if (/^on/.test(attrName)) {\r\n                intf.addEventListener('on' + attrName, function (e) {\r\n                    eval(newVal);\r\n                });\r\n            }\r\n            return;\r\n        };\r\n        component.observe = function (intf) {\r\n            var observer;\r\n            if (!window.MutationObserver) { return; }\r\n            intf.applyComponentStyle = function () { component.applyComponentStyle(false, intf); intf.resize(); };\r\n            /**\r\n             * Applies the computed css styles to the grid.  In some browsers, changing directives in attached style sheets does not automatically update the styles in this component.  It is necessary to call this method to update in these cases.\r\n             * @memberof canvasDatagrid\r\n             * @name applyComponentStyle\r\n             * @method\r\n             */\r\n            observer = new window.MutationObserver(function (mutations) {\r\n                var checkInnerHTML, checkStyle;\r\n                Array.prototype.forEach.call(mutations, function (mutation) {\r\n                    if (mutation.attributeName === 'class'\r\n                            || mutation.attributeName === 'style') {\r\n                        checkStyle = true;\r\n                        return;\r\n                    }\r\n                    if (mutation.target.nodeName === 'STYLE') {\r\n                        checkStyle = true;\r\n                        return;\r\n                    }\r\n                    if (mutation.target.parentNode\r\n                            && mutation.target.parentNode.nodeName === 'STYLE') {\r\n                        checkStyle = true;\r\n                        return;\r\n                    }\r\n                    if (mutation.target === intf && (mutation.addedNodes.length > 0 || mutation.type === 'characterData')) {\r\n                        checkInnerHTML = true;\r\n                    }\r\n                });\r\n                if (checkStyle) {\r\n                    intf.applyComponentStyle(false, intf);\r\n                }\r\n                if (checkInnerHTML) {\r\n                    if (intf.dataType === 'application/x-canvas-datagrid') {\r\n                        intf.dataType = 'application/json+x-canvas-datagrid';\r\n                    }\r\n                    intf.data = intf.innerHTML;\r\n                }\r\n            });\r\n            observer.observe(intf, { characterData: true, childList: true, attributes: true, subtree: true });\r\n            Array.prototype.forEach.call(document.querySelectorAll('style'), function (el) {\r\n                observer.observe(el, { characterData: true, childList: true, attributes: true, subtree: true });\r\n            });\r\n        };\r\n        return component;\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component.js\n// module id = 2\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals XMLSerializer: false, define: true, Blob: false, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        var perfCounters = [],\r\n            cachedImagesDrawn = false,\r\n            drawCount = 0,\r\n            perfWindowSize = 300,\r\n            entityCount = [],\r\n            hiddenFrozenColumnCount = 0,\r\n            scrollDebugCounters = [],\r\n            touchPPSCounters = [];\r\n        self.htmlImageCache = {};\r\n        // more heavyweight version than fillArray defined in intf.js\r\n        function fillArray(low, high, step, def) {\r\n            step = step || 1;\r\n            var i = [], x;\r\n            for (x = low; x <= high; x += step) {\r\n                i[x] = def === undefined ? x : (typeof def === 'function' ? def(x) : def);\r\n            }\r\n            return i;\r\n        }\r\n        function drawPerfLine(w, h, x, y, perfArr, arrIndex, max, color, useAbs) {\r\n            var i = w / perfArr.length,\r\n                r = h / max;\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.beginPath();\r\n            self.ctx.moveTo(x, y + h);\r\n            perfArr.forEach(function (n) {\r\n                var val = (arrIndex === undefined ? n : n[arrIndex]),\r\n                    cx,\r\n                    cy;\r\n                if (useAbs) {\r\n                    val = Math.abs(val);\r\n                }\r\n                cx = x + i;\r\n                cy = y + h - (val * r);\r\n                self.ctx.lineTo(cx, cy);\r\n                x += i;\r\n            });\r\n            self.ctx.moveTo(x + w, y + h);\r\n            self.ctx.strokeStyle = color;\r\n            self.ctx.stroke();\r\n        }\r\n        function drawOnAllImagesLoaded() {\r\n            var loaded = true;\r\n            Object.keys(self.htmlImageCache).forEach(function (html) {\r\n                if (!self.htmlImageCache[html].complete) {\r\n                    loaded = false;\r\n                }\r\n            });\r\n            if (loaded && !cachedImagesDrawn) {\r\n                cachedImagesDrawn = true;\r\n                self.draw();\r\n            }\r\n        }\r\n        function drawHtml(cell) {\r\n            var img,\r\n                v = cell.innerHTML || cell.formattedValue,\r\n                cacheKey = v.toString() + cell.rowIndex.toString() + cell.columnIndex.toString(), \r\n                x = cell.x + self.canvasOffsetLeft,\r\n                y = cell.y + self.canvasOffsetTop;\r\n            if (self.htmlImageCache[cacheKey]) {\r\n                img = self.htmlImageCache[cacheKey];\r\n                if (img.height !== cell.height || img.width !== cell.width) {\r\n                    // height and width of the cell has changed, invalidate cache\r\n                    self.htmlImageCache[cacheKey] = undefined;\r\n                } else {\r\n                    if (!img.complete) {\r\n                        return;\r\n                    }\r\n                    return self.ctx.drawImage(img, x, y);\r\n                }\r\n            } else {\r\n                cachedImagesDrawn = false;\r\n            }\r\n            img = new Image(cell.width, cell.height);\r\n            self.htmlImageCache[cacheKey] = img;\r\n            img.onload = function () {\r\n                self.ctx.drawImage(img, x, y);\r\n                drawOnAllImagesLoaded();\r\n            };\r\n            img.src = 'data:image/svg+xml;base64,' + btoa(\r\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' + cell.width + '\" height=\"' + cell.height + '\">\\n' +\r\n                    '<foreignObject class=\"node\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">\\n' +\r\n                    '<body xmlns=\"http://www.w3.org/1999/xhtml\" style=\"margin:0;padding:0;\">\\n' +\r\n                    v + '\\n' +\r\n                    '</body>' +\r\n                    '</foreignObject>\\n' +\r\n                    '</svg>\\n'\r\n            );\r\n        }\r\n        function drawOrderByArrow(x, y) {\r\n            var mt = self.style.columnHeaderOrderByArrowMarginTop * self.scale,\r\n                ml = self.style.columnHeaderOrderByArrowMarginLeft * self.scale,\r\n                mr = self.style.columnHeaderOrderByArrowMarginRight * self.scale,\r\n                aw = self.style.columnHeaderOrderByArrowWidth * self.scale,\r\n                ah = self.style.columnHeaderOrderByArrowHeight * self.scale;\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.fillStyle = self.style.columnHeaderOrderByArrowColor;\r\n            self.ctx.strokeStyle = self.style.columnHeaderOrderByArrowBorderColor;\r\n            self.ctx.beginPath();\r\n            x = x + ml;\r\n            y = y + mt;\r\n            if (self.orderDirection === 'asc') {\r\n                self.ctx.moveTo(x, y);\r\n                self.ctx.lineTo(x + aw, y);\r\n                self.ctx.lineTo(x + (aw * 0.5), y + ah);\r\n                self.ctx.moveTo(x, y);\r\n            } else {\r\n                self.ctx.lineTo(x, y + ah);\r\n                self.ctx.lineTo(x + aw, y + ah);\r\n                self.ctx.lineTo(x + (aw * 0.5), y);\r\n                self.ctx.lineTo(x, y + ah);\r\n            }\r\n            self.ctx.stroke();\r\n            self.ctx.fill();\r\n            return ml + aw + mr;\r\n        }\r\n        function drawTreeArrow(cell, x, y) {\r\n            var mt = self.style.treeArrowMarginTop * self.scale,\r\n                mr = self.style.treeArrowMarginRight * self.scale,\r\n                ml = self.style.treeArrowMarginLeft * self.scale,\r\n                aw = self.style.treeArrowWidth * self.scale,\r\n                ah = self.style.treeArrowHeight * self.scale;\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.fillStyle = self.style.treeArrowColor;\r\n            self.ctx.strokeStyle = self.style.treeArrowBorderColor;\r\n            self.ctx.beginPath();\r\n            x = x + ml;\r\n            y = y + mt;\r\n            if (self.openChildren[cell.rowIndex]) {\r\n                self.ctx.moveTo(x, y);\r\n                self.ctx.lineTo(x + aw, y);\r\n                self.ctx.lineTo(x + (aw * 0.5), y + ah);\r\n                self.ctx.moveTo(x, y);\r\n            } else {\r\n                self.ctx.lineTo(x, y);\r\n                self.ctx.lineTo(x + ah, y + (aw * 0.5));\r\n                self.ctx.lineTo(x, y + aw);\r\n                self.ctx.lineTo(x, y);\r\n            }\r\n            self.ctx.stroke();\r\n            self.ctx.fill();\r\n            return ml + aw + mr;\r\n        }\r\n        function radiusRect(x, y, w, h, radius) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            var r = x + w, b = y + h;\r\n            self.ctx.beginPath();\r\n            self.ctx.moveTo(x + radius, y);\r\n            self.ctx.lineTo(r - radius, y);\r\n            self.ctx.quadraticCurveTo(r, y, r, y + radius);\r\n            self.ctx.lineTo(r, y + h - radius);\r\n            self.ctx.quadraticCurveTo(r, b, r - radius, b);\r\n            self.ctx.lineTo(x + radius, b);\r\n            self.ctx.quadraticCurveTo(x, b, x, b - radius);\r\n            self.ctx.lineTo(x, y + radius);\r\n            self.ctx.quadraticCurveTo(x, y, x + radius, y);\r\n        }\r\n        function fillRect(x, y, w, h) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.fillRect(x, y, w, h);\r\n        }\r\n        function strokeRect(x, y, w, h) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.strokeRect(x, y, w, h);\r\n        }\r\n        function fillText(text, x, y) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.fillText(text, x, y);\r\n        }\r\n        function fillCircle(x, y, r) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.beginPath();\r\n            self.ctx.arc(x, y, r, 0, 2 * Math.PI);\r\n            self.ctx.fill();\r\n        }\r\n        function strokeCircle(x, y, r) {\r\n            x += self.canvasOffsetLeft;\r\n            y += self.canvasOffsetTop;\r\n            self.ctx.beginPath();\r\n            self.ctx.arc(x, y, r, 0, 2 * Math.PI);\r\n            self.ctx.stroke();\r\n        }\r\n        function clipFrozenArea(mode) {\r\n            // 0 both, 1 rows, 2 cols\r\n            // self.lastFrozenColumnPixel;\r\n            // self.lastFrozenRowPixel;\r\n            self.ctx.beginPath();\r\n            if (mode === 0) {\r\n                self.ctx.moveTo(self.lastFrozenColumnPixel, self.lastFrozenRowPixel);\r\n                self.ctx.lineTo(self.lastFrozenColumnPixel, self.height);\r\n                self.ctx.lineTo(self.width, self.height);\r\n                self.ctx.lineTo(self.width, self.lastFrozenRowPixel);\r\n            }\r\n            if (mode === 1) {\r\n                self.ctx.moveTo(0, self.lastFrozenRowPixel);\r\n                self.ctx.lineTo(0, self.height);\r\n                self.ctx.lineTo(self.width, self.height);\r\n                self.ctx.lineTo(self.width, self.lastFrozenRowPixel);\r\n            }\r\n            if (mode === 2) {\r\n                self.ctx.moveTo(self.lastFrozenColumnPixel, 0);\r\n                self.ctx.lineTo(self.width, 0);\r\n                self.ctx.lineTo(self.width, self.height);\r\n                self.ctx.lineTo(self.lastFrozenColumnPixel, self.height);\r\n            }\r\n            self.ctx.clip();\r\n        }\r\n        function fillHandle(x, y, r) {\r\n            if (self.style.selectionHandleType === 'circle') {\r\n                return fillCircle(x, y, r * 0.5);\r\n            }\r\n            fillRect(x - r * 0.5, y - r * 0.5, r, r);\r\n        }\r\n        function strokeHandle(x, y, r) {\r\n            if (self.style.selectionHandleType === 'circle') {\r\n                return strokeCircle(x, y, r * 0.5);\r\n            }\r\n            strokeRect(x - r * 0.5, y - r * 0.5, r, r);\r\n        }\r\n        function addselectionHandle(c, pos) {\r\n            var hw = self.style.selectionHandleSize,\r\n                p = {\r\n                    tr: function () {\r\n                        fillHandle(c.x + c.width, c.y, hw);\r\n                        strokeHandle(c.x + c.width, c.y, hw);\r\n                    },\r\n                    br: function () {\r\n                        fillHandle(c.x + c.width, c.y + c.height, hw);\r\n                        strokeHandle(c.x + c.width, c.y + c.height, hw);\r\n                    },\r\n                    tl: function () {\r\n                        fillHandle(c.x, c.y, hw);\r\n                        strokeHandle(c.x, c.y, hw);\r\n                    },\r\n                    bl: function () {\r\n                        fillHandle(c.x, c.y + c.height, hw);\r\n                        strokeHandle(c.x, c.y + c.height, hw);\r\n                    }\r\n                };\r\n            p[pos]();\r\n        }\r\n        function addBorderLine(c, pos) {\r\n            self.ctx.beginPath();\r\n            var p = {\r\n                t: function () {\r\n                    self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop);\r\n                    self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop);\r\n                },\r\n                r: function () {\r\n                    self.ctx.moveTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop);\r\n                    self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop + c.height);\r\n                },\r\n                b: function () {\r\n                    self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop + c.height);\r\n                    self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop + c.height);\r\n                },\r\n                l: function () {\r\n                    self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop);\r\n                    self.ctx.lineTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop + c.height);\r\n                }\r\n            };\r\n            p[pos]();\r\n            self.ctx.stroke();\r\n        }\r\n        function addEllipsis(text, width) {\r\n            var c, w = 0;\r\n            if (self.ellipsisCache[text] && self.ellipsisCache[text][width]) {\r\n                return self.ellipsisCache[text][width];\r\n            }\r\n            //TODO Add ellipsis back when there is a fast way to do it\r\n            w = self.ctx.measureText(text).width;\r\n            self.ellipsisCache[text] = self.ellipsisCache[text] || {};\r\n            c = {value: text, width: w};\r\n            self.ellipsisCache[text][width] = c;\r\n            return c;\r\n        }\r\n        function wrapText(cell, splitChar) {\r\n            if (!cell.formattedValue) {\r\n                return { lines: [{width: 0, value: ''}], width: 0, height: cell.calculatedLineHeight };\r\n            }\r\n            var max = 0,\r\n                n = '\\n',\r\n                x,\r\n                word,\r\n                words = cell.formattedValue.split(splitChar),\r\n                textHeight = cell.calculatedLineHeight,\r\n                lines = [],\r\n                out = [],\r\n                wrap = self.style.cellWhiteSpace !== 'nowrap',\r\n                elWidth,\r\n                et = self.attributes.ellipsisText,\r\n                elClipLength,\r\n                plWidth,\r\n                clippedVal,\r\n                ogWordWidth,\r\n                previousLine,\r\n                line = {\r\n                    width: 0,\r\n                    value: ''\r\n                },\r\n                cHeight = wrap ? cell.paddedHeight : cell.calculatedLineHeight;\r\n            lines.push(line);\r\n            elWidth = self.ctx.measureText(' ' + et).width;\r\n            for (x = 0; x < words.length; x += 1) {\r\n                word = words[x];\r\n                var measure = self.ctx.measureText(word + splitChar);\r\n                if (line.width + measure.width + elWidth < cell.paddedWidth) {\r\n                    line.value += word + splitChar;\r\n                    line.width += measure.width;\r\n                    continue;\r\n                }\r\n                // if there is a hyphenated word that is too long\r\n                // split it and add the split set to the array\r\n                // then back up and re-read new split set\r\n                // this behavior seems right, it might not be\r\n                if (/\\w-\\w/.test(word) && cell.paddedWidth < measure.width) {\r\n                    words.splice(x, 1, word.split('-')[0] + '-', word.split('-')[1]);\r\n                    x -= 1;\r\n                    continue;\r\n                }\r\n                line = {\r\n                    width: measure.width,\r\n                    value: word + splitChar\r\n                };\r\n                if (x === 0) {\r\n                    lines = [];\r\n                    lines.push(line);\r\n                }\r\n                textHeight += cell.calculatedLineHeight;\r\n                if (textHeight > cHeight) {\r\n                    if (lines.length === 0) { break; }\r\n                    elClipLength = 1;\r\n                    previousLine = lines[lines.length - 1];\r\n                    if (previousLine.width < cell.paddedWidth && words.length === 1) { break; }\r\n                    clippedVal = previousLine.value + word;\r\n                    plWidth = self.ctx.measureText(clippedVal + et).width;\r\n                    var originText = clippedVal;\r\n                    if (plWidth > cell.paddedWidth) {\r\n                        var stepLength = parseInt(clippedVal.length / 2);\r\n                        var direction = -1;\r\n                        while (stepLength > 0) {\r\n                            clippedVal = originText.substr(0, stepLength * direction + clippedVal.length);\r\n                            plWidth = self.ctx.measureText(clippedVal + et).width;\r\n                            direction = plWidth > cell.paddedWidth ? -1 : 1;\r\n                            stepLength = parseInt(stepLength / 2);\r\n                        }\r\n                    }\r\n                    clippedVal = clippedVal + (originText.length != clippedVal.length ? et : '');\r\n                    previousLine.value = clippedVal;\r\n                    previousLine.width = plWidth;\r\n                    break;\r\n                }\r\n                if (x > 0) {\r\n                    lines.push(line);\r\n                }\r\n            }\r\n            return {\r\n                lines: lines,\r\n                width: max,\r\n                height: cell.calculatedLineHeight * lines.length\r\n            }\r\n        }\r\n        function drawText(cell) {\r\n            var ll = cell.text.lines.length,\r\n                h = (cell.fontHeight * cell.lineHeight),\r\n                x,\r\n                line,\r\n                wrap = self.style.cellWhiteSpace !== 'nowrap',\r\n                textHeight = 0;\r\n            for (x = 0; x < cell.text.lines.length; x += 1) {\r\n                line = cell.text.lines[x];\r\n                var vPos = Math.max((cell.height - (wrap ? cell.text.height : cell.calculatedLineHeight)) * 0.5, 0) + h,\r\n                    hPos = cell.paddingLeft + cell.treeArrowWidth + cell.orderByArrowWidth;\r\n                if (cell.horizontalAlignment === 'right') {\r\n                    hPos = cell.paddingLeft + cell.paddedWidth - line.width;\r\n                } else if (cell.horizontalAlignment === 'center') {\r\n                    hPos = cell.paddingLeft + ((cell.paddedWidth + cell.paddingRight) / 2) - (line.width / 2);\r\n                }\r\n                if (cell.verticalAlignment === 'top') {\r\n                    vPos = cell.calculatedLineHeight;\r\n                } else if (cell.verticalAlignment === 'bottom') {\r\n                    vPos = cell.height - cell.paddingBottom - cell.text.height;\r\n                }\r\n                line.height = h + cell.lineSpacing;\r\n                line.offsetLeft = hPos;\r\n                line.offsetTop = vPos;\r\n                line.x = cell.x + hPos;\r\n                line.y = cell.y + textHeight + vPos;\r\n                textHeight += line.height;\r\n                fillText(line.value, line.x, line.y);\r\n            }\r\n            if (self.attributes.debug && cell.active) {\r\n                requestAnimationFrame(function () {\r\n                    self.ctx.font = self.style.debugFont;\r\n                    self.ctx.fillStyle = self.style.debugColor;\r\n                    fillText(JSON.stringify({\r\n                        x: cell.x,\r\n                        y: cell.y,\r\n                        h: cell.height,\r\n                        w: cell.width,\r\n                        pw: cell.paddedWidth,\r\n                        idx: cell.columnIndex,\r\n                        idx_ord: cell.sortColumnIndex\r\n                    }, null, '\\t'),\r\n                        cell.x + 14, cell.y + 14);\r\n                    fillText(JSON.stringify(cell.text.lines.map(function (l) { return {w: l.width, v: l.value.length }; }), null, '\\t'),\r\n                        cell.x + 14, cell.y + 30);\r\n                });\r\n            }\r\n        }\r\n        function getFrozenColumnsWidth() {\r\n            var w = 0,\r\n                s = self.getSchema(),\r\n                x = 0,\r\n                n = Math.min(self.frozenColumn, s.length),\r\n                column;\r\n            hiddenFrozenColumnCount = 0;\r\n            while (x < n) {\r\n                column = s[x];\r\n                if (column.hidden) {\r\n                    hiddenFrozenColumnCount += 1;\r\n                } else {\r\n                    w += self.getColummnWidth(x);\r\n                }\r\n                x += 1;\r\n            }\r\n            return w;\r\n        }\r\n        /**\r\n         * Redraws the grid. No matter what the change, this is the only method required to refresh everything.\r\n         * @memberof canvasDatagrid\r\n         * @name draw\r\n         * @method\r\n         */\r\n         // r = literal row index\r\n         // rd = row data array\r\n         // i = user order index\r\n         // o = literal data index\r\n         // y = y drawing cursor\r\n         // x = x drawing cursor\r\n         // s = visible schema array\r\n         // cx = current x drawing cursor sub calculation var\r\n         // cy = current y drawing cursor sub calculation var\r\n         // a = static cell (like corner cell)\r\n         // p = perf counter\r\n         // l = data length\r\n         // u = current cell\r\n         // h = current height\r\n         // w = current width\r\n        self.draw = function (internal) {\r\n            if (self.dispatchEvent('beforedraw', {})) { return; }\r\n            if (!self.isChildGrid && (!self.height || !self.width)) {\r\n                return;\r\n            }\r\n            if (self.isChildGrid && internal) {\r\n                requestAnimationFrame(self.parentGrid.draw);\r\n                return;\r\n            }\r\n            if (self.intf.visible === false) {\r\n                return;\r\n            }\r\n            // initial values\r\n            var checkScrollHeight, rowHeaderCell, p, cx, cy, treeGrid, rowOpen,\r\n                rowHeight, cornerCell, y, x, c, h, w, s, r, rd, aCell,\r\n                data = (self.data || []),\r\n                bc = self.style.gridBorderCollapse === 'collapse',\r\n                selectionBorders = [],\r\n                moveBorders = [],\r\n                selectionHandles = [],\r\n                rowHeaders = [],\r\n                l = data.length,\r\n                u = self.currentCell || {},\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n                rowHeaderCellWidth = self.getRowHeaderCellWidth(),\r\n                cellHeight = self.style.cellHeight;\r\n            drawCount += 1;\r\n            p = performance.now();\r\n            self.visibleRowHeights = [];\r\n            // if data length has changed, there is no way to know\r\n            if (data.length > self.orders.rows.length) {\r\n                self.createRowOrders();\r\n            }\r\n            function createHandlesOverlayArray(cell) {\r\n                if (self.attributes.allowMovingSelection || self.mobile) {\r\n                    if (cell.selectionBorderTop && cell.selectionBorderRight && self.mobile) {\r\n                        selectionHandles.push([cell, 'tr']);\r\n                        cell.selectionHandle = 'tr';\r\n                    }\r\n                    if (cell.selectionBorderTop && cell.selectionBorderLeft && self.mobile) {\r\n                        selectionHandles.push([cell, 'tl']);\r\n                        cell.selectionHandle = 'tl';\r\n                    }\r\n                    if (cell.selectionBorderBottom && cell.selectionBorderLeft && self.mobile) {\r\n                        selectionHandles.push([cell, 'bl']);\r\n                        cell.selectionHandle = 'bl';\r\n                    }\r\n                    if (cell.selectionBorderBottom && cell.selectionBorderRight\r\n                            && (self.attributes.selectionHandleBehavior !== 'none' || self.mobile)) {\r\n                        selectionHandles.push([cell, 'br']);\r\n                        cell.selectionHandle = 'br';\r\n                    }\r\n                }\r\n            }\r\n            function createBorderOverlayArray(cell, drawArray, propPrefix, offsetPoint) {\r\n                offsetPoint = offsetPoint || {x: 0, y: 0};\r\n                cell.selectionBorder = '';\r\n                if (!cell.isRowHeader\r\n                        && self.selections[cell.rowIndex + -offsetPoint.y]\r\n                        && self.selections[cell.rowIndex + -offsetPoint.y].indexOf(cell.columnIndex + -offsetPoint.x) !== -1) {\r\n                    if ((!self.selections[cell.rowIndex - 1 + -offsetPoint.y]\r\n                            || self.selections[cell.rowIndex - 1 + -offsetPoint.y].indexOf(cell.columnIndex + -offsetPoint.x) === -1\r\n                            || cell.rowIndex === 0)\r\n                            && !cell.isHeader) {\r\n                        drawArray.push([cell, 't']);\r\n                        cell[propPrefix + 'BorderTop'] = true;\r\n                        cell[propPrefix + 'Border'] += 't';\r\n                    }\r\n                    if (!self.selections[cell.rowIndex + 1 + -offsetPoint.y]\r\n                            || self.selections[cell.rowIndex + 1 + -offsetPoint.y].indexOf(cell.columnIndex + -offsetPoint.x) === -1) {\r\n                        drawArray.push([cell, 'b']);\r\n                        cell[propPrefix + 'BorderBottom'] = true;\r\n                        cell[propPrefix + 'Border'] += 'b';\r\n                    }\r\n                    if (!self.selections[cell.rowIndex + -offsetPoint.y] || cell.columnIndex === 0\r\n                            || self.selections[cell.rowIndex + -offsetPoint.y].indexOf(cell.columnIndex - 1 + -offsetPoint.x) === -1) {\r\n                        drawArray.push([cell, 'l']);\r\n                        cell[propPrefix + 'BorderLeft'] = true;\r\n                        cell[propPrefix + 'Border'] += 'l';\r\n                    }\r\n                    if (!self.selections[cell.rowIndex + -offsetPoint.y] || cell.columnIndex === s.length\r\n                            || self.selections[cell.rowIndex + -offsetPoint.y].indexOf(cell.columnIndex + 1 + -offsetPoint.x) === -1) {\r\n                        drawArray.push([cell, 'r']);\r\n                        cell[propPrefix + 'BorderRight'] = true;\r\n                        cell[propPrefix + 'Border'] += 'r';\r\n                    }\r\n                }\r\n            }\r\n            function drawCell(d, rowOrderIndex, rowIndex) {\r\n                return function drawEach(header, headerIndex, columnOrderIndex) {\r\n                    if (header.hidden) { return 0; }\r\n                    var cellStyle = header.style || 'cell',\r\n                        cellGridAttributes,\r\n                        cell,\r\n                        isHeader = /HeaderCell/.test(cellStyle),\r\n                        isCorner = /cornerCell/.test(cellStyle),\r\n                        isRowHeader = 'rowHeaderCell' === cellStyle,\r\n                        isColumnHeader = 'columnHeaderCell' === cellStyle,\r\n                        selected = self.selections[rowOrderIndex] && self.selections[rowOrderIndex].indexOf(columnOrderIndex) !== -1,\r\n                        hovered = self.hovers.rowIndex === rowOrderIndex && self.hovers.columnIndex === columnOrderIndex,\r\n                        active = self.activeCell.rowIndex === rowOrderIndex && self.activeCell.columnIndex === columnOrderIndex,\r\n                        isColumnHeaderCellCap = cellStyle === 'columnHeaderCellCap',\r\n                        rawValue = d ? d[header.name] : undefined,\r\n                        isGrid = header.type === 'canvas-datagrid',\r\n                        activeHeader = (self.orders.rows[self.activeCell.rowIndex] === rowOrderIndex\r\n                                || self.orders.columns[self.activeCell.columnIndex] === headerIndex)\r\n                            && (columnOrderIndex === -1 || rowOrderIndex === -1)\r\n                            ? (isRowHeader ? 'activeRowHeaderCell' : 'activeColumnHeaderCell') : false,\r\n                        val,\r\n                        f = self.formatters[header.type || 'string'],\r\n                        orderByArrowSize = 0,\r\n                        treeArrowSize = 0,\r\n                        cellWidth = self.sizes.columns[headerIndex] || header.width,\r\n                        ev = {\r\n                            value: rawValue,\r\n                            row: d,\r\n                            header: header\r\n                        };\r\n                    if (isColumnHeaderCellCap) {\r\n                        cellWidth = w - x;\r\n                    }\r\n                    // if no data or schema are defined, a width is provided to the stub column\r\n                    if (cellWidth === undefined) {\r\n                        cellWidth = self.style.cellWidth;\r\n                    }\r\n                    cellWidth = cellWidth * self.scale;\r\n                    if (x + cellWidth + self.style.cellBorderWidth < 0) {\r\n                        x += cellWidth + self.style.cellBorderWidth;\r\n                    }\r\n                    if (active && cellStyle !== 'cornerCell') {\r\n                        cellStyle = 'activeCell';\r\n                    }\r\n                    if (self.visibleRows.indexOf(rowIndex) === -1 && !isHeader) {\r\n                        self.visibleRows.push(rowIndex);\r\n                    }\r\n                    val = self.dispatchEvent('formatcellvalue', ev);\r\n                    cx = x;\r\n                    cy = y;\r\n                    if (cellStyle === 'cornerCell') {\r\n                        cx = 0;\r\n                        cy = 0;\r\n                    } else if (isRowHeader) {\r\n                        cx = 0;\r\n                    } else if (isHeader) {\r\n                        cy = 0;\r\n                    }\r\n                    cell = {\r\n                        type: isGrid ? 'canvas-datagrid-cell' : header.type,\r\n                        style: cellStyle,\r\n                        nodeType: 'canvas-datagrid-cell',\r\n                        x: cx,\r\n                        y: cy,\r\n                        fontHeight: (self.style[cellStyle + 'FontHeight'] || 0) * self.scale,\r\n                        horizontalAlignment: self.style[cellStyle + 'HorizontalAlignment'],\r\n                        verticalAlignment: self.style[cellStyle + 'VerticalAlignment'],\r\n                        paddingLeft: (self.style[cellStyle + 'PaddingLeft'] || 0) * self.scale,\r\n                        paddingTop: (self.style[cellStyle + 'PaddingTop'] || 0) * self.scale,\r\n                        paddingRight: (self.style[cellStyle + 'PaddingRight'] || 0) * self.scale,\r\n                        paddingBottom: (self.style[cellStyle + 'PaddingBottom'] || 0) * self.scale,\r\n                        whiteSpace: self.style.cellWhiteSpace,\r\n                        lineHeight: self.style.cellLineHeight,\r\n                        lineSpacing: self.style.cellLineSpacing,\r\n                        offsetTop: self.canvasOffsetTop + cy,\r\n                        offsetLeft: self.canvasOffsetLeft + cx,\r\n                        scrollTop: self.scrollBox.scrollTop,\r\n                        scrollLeft: self.scrollBox.scrollLeft,\r\n                        active: active || activeHeader,\r\n                        hovered: hovered,\r\n                        selected: selected,\r\n                        width: cellWidth,\r\n                        height: cellHeight,\r\n                        offsetWidth: cellWidth,\r\n                        offsetHeight: cellHeight,\r\n                        parentNode: self.intf.parentNode,\r\n                        offsetParent: self.intf.parentNode,\r\n                        data: d,\r\n                        isCorner: isCorner,\r\n                        isHeader: isHeader,\r\n                        isColumnHeader: isColumnHeader,\r\n                        isColumnHeaderCellCap: isColumnHeaderCellCap,\r\n                        isRowHeader: isRowHeader,\r\n                        rowOpen: rowOpen,\r\n                        header: header,\r\n                        columnIndex: columnOrderIndex,\r\n                        rowIndex: rowOrderIndex,\r\n                        sortColumnIndex: headerIndex,\r\n                        sortRowIndex: rowIndex,\r\n                        isGrid: isGrid,\r\n                        isNormal: !isGrid && !isCorner && !isHeader,\r\n                        gridId: (self.attributes.name || '') + rowIndex + ':' + headerIndex,\r\n                        parentGrid: self.intf,\r\n                        innerHTML: '',\r\n                        activeHeader: activeHeader,\r\n                        value: isHeader && !isRowHeader ? (header.title || header.name) : rawValue\r\n                    };\r\n                    cell.calculatedLineHeight = (cell.fontHeight * cell.lineHeight) + cell.lineSpacing;\r\n                    cell.paddedWidth = cell.width - cell.paddingRight - cell.paddingLeft;\r\n                    cell.paddedHeight = cell.height - cell.paddingTop - cell.paddingBottom;\r\n                    ev.cell = cell;\r\n                    cell.userHeight = cell.isHeader ? self.sizes.rows[-1] : rowHeight;\r\n                    cell.userWidth = cell.isHeader ? self.sizes.columns.cornerCell : self.sizes.columns[headerIndex];\r\n                    self.visibleCells.unshift(cell);\r\n                    if (self.dispatchEvent('beforerendercell', ev)) { return; }\r\n                    self.ctx.fillStyle = self.style[cellStyle + 'BackgroundColor'];\r\n                    self.ctx.strokeStyle = self.style[cellStyle + 'BorderColor'];\r\n                    self.ctx.lineWidth = self.style[cellStyle + 'BorderWidth'];\r\n                    if (hovered) {\r\n                        self.ctx.fillStyle = self.style[cellStyle + 'HoverBackgroundColor'];\r\n                        self.ctx.strokeStyle = self.style[cellStyle + 'HoverBorderColor'];\r\n                    }\r\n                    if (selected) {\r\n                        self.ctx.fillStyle = self.style[cellStyle + 'SelectedBackgroundColor'];\r\n                        self.ctx.strokeStyle = self.style[cellStyle + 'SelectedBorderColor'];\r\n                    }\r\n                    if (activeHeader) {\r\n                        self.ctx.fillStyle = self.style[activeHeader + 'BackgroundColor'];\r\n                    }\r\n                    self.dispatchEvent('rendercell', ev);\r\n                    if (cell.isGrid) {\r\n                        if (cell.height !== rowHeight) {\r\n                            cell.height = rowHeight || self.style.cellHeightWithChildGrid;\r\n                            checkScrollHeight = true;\r\n                        }\r\n                        cell.width = self.sizes.columns[headerIndex] || self.style.cellWidthWithChildGrid;\r\n                    }\r\n                    if (rowOpen && !cell.isRowHeader) {\r\n                        cell.height = self.sizes.rows[rowIndex] || self.style.cellHeight;\r\n                    }\r\n                    if (!cell.isGrid) {\r\n                        fillRect(cx, cy, cell.width, cell.height);\r\n                        strokeRect(cx, cy, cell.width, cell.height);\r\n                    }\r\n                    self.ctx.save();\r\n                    radiusRect(cell.x, cell.y, cell.width, cell.height, 0);\r\n                    self.ctx.clip();\r\n                    self.dispatchEvent('afterrendercell', ev);\r\n                    if (cell.height !== cellHeight && !(rowOpen && !cell.isRowHeader)) {\r\n                        self.sizes.rows[isHeader ? -1 : rowIndex] = cell.height;\r\n                        checkScrollHeight = true;\r\n                    }\r\n                    if (cell.width !== cellWidth) {\r\n                        self.sizes.columns[headerIndex] = cell.width;\r\n                        checkScrollHeight = true;\r\n                    }\r\n                    if (isRowHeader && self.attributes.tree) {\r\n                        if (!self.dispatchEvent('rendertreearrow', ev)) {\r\n                            treeArrowSize = drawTreeArrow(cell, self.style[cellStyle + 'PaddingLeft'], cy, 0);\r\n                        }\r\n                    }\r\n                    if ((self.attributes.showRowNumbers && isRowHeader)\r\n                            || !isRowHeader) {\r\n                        if (cell.isGrid && !self.dispatchEvent('beforerendercellgrid', ev)) {\r\n                            if (!self.childGrids[cell.gridId]) {\r\n                                // HACK: this only allows setting of the child grids styles if data is set _after_\r\n                                // this is less than desirable.  An interface needs to be made to effect the\r\n                                // style of all cell grids.  One for individual grids already exists.\r\n                                cellGridAttributes = self.cellGridAttributes;\r\n                                cellGridAttributes.name = self.attributes.saveAppearance ? cell.gridId : undefined;\r\n                                cellGridAttributes.component = false;\r\n                                cellGridAttributes.parentNode = cell;\r\n                                cellGridAttributes.data = rawValue;\r\n                                ev.cellGridAttributes = cellGridAttributes;\r\n                                if (self.dispatchEvent('beforecreatecellgrid', ev)) { return; }\r\n                                self.childGrids[cell.gridId] = self.createGrid(cellGridAttributes);\r\n                                self.sizes.rows[rowIndex]\r\n                                    = self.sizes.rows[rowIndex] || self.style.cellGridHeight;\r\n                                checkScrollHeight = true;\r\n                            }\r\n                            cell.grid = self.childGrids[cell.gridId];\r\n                            cell.grid.parentNode = cell;\r\n                            cell.grid.visible = true;\r\n                            cell.grid.draw();\r\n                            self.dispatchEvent('rendercellgrid', ev);\r\n                        } else if (!cell.isGrid) {\r\n                            if (self.childGrids[cell.gridId]) {\r\n                                self.childGrids[cell.gridId].parentNode.offsetHeight = 0;\r\n                            }\r\n                            if (isHeader && self.orderBy === header.name) {\r\n                                if (!self.dispatchEvent('renderorderbyarrow', ev)) {\r\n                                    orderByArrowSize = drawOrderByArrow(cx + self.style[cellStyle + 'PaddingLeft'], 0);\r\n                                }\r\n                            }\r\n                            self.ctx.fillStyle = self.style[cellStyle + 'Color'];\r\n                            if (hovered) {\r\n                                self.ctx.fillStyle = self.style[cellStyle + 'HoverColor'];\r\n                            }\r\n                            if (selected) {\r\n                                self.ctx.fillStyle = self.style[cellStyle + 'SelectedColor'];\r\n                            }\r\n                            if (activeHeader) {\r\n                                self.ctx.fillStyle = self.style[activeHeader + 'Color'];\r\n                            }\r\n                            cell.treeArrowWidth = treeArrowSize;\r\n                            cell.orderByArrowWidth = orderByArrowSize;\r\n                            // create text ref to see if height needs to expand\r\n                            val = val !== undefined ? val : f\r\n                                ? f(ev) : '';\r\n                            if (val === undefined && !f) {\r\n                                val = '';\r\n                                console.warn('canvas-datagrid: Unknown format '\r\n                                    + header.type + ' add a cellFormater');\r\n                            }\r\n                            cell.formattedValue = ((val !== undefined && val !== null) ? val : '').toString();\r\n                            if (self.columnFilters && self.columnFilters[val] !== undefined && isHeader) {\r\n                                cell.formattedValue = self.attributes.filterTextPrefix + val;\r\n                            }\r\n                            self.ctx.font = (self.style[cellStyle + 'FontHeight'] * self.scale) + 'px ' + self.style[cellStyle + 'FontName'];\r\n                            if (!self.dispatchEvent('formattext', ev)) {\r\n                                cell.text = wrapText(cell, ' ');\r\n                            }\r\n                            if (!self.dispatchEvent('rendertext', ev)) {\r\n                                if (cell.innerHTML || header.type === 'html') {\r\n                                    drawHtml(cell);\r\n                                } else {\r\n                                    drawText(cell);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (active) {\r\n                        aCell = cell;\r\n                    }\r\n                    createBorderOverlayArray(cell, selectionBorders, 'selection');\r\n                    // createBorderOverlayArray calculates data for createHandlesOverlayArray so it must go 2nd\r\n                    createHandlesOverlayArray(cell);\r\n                    if (self.movingSelection) {\r\n                        createBorderOverlayArray(cell, moveBorders, 'move', self.moveOffset);\r\n                    }\r\n                    self.ctx.restore();\r\n                    x += cell.width + (bc ? 0 : self.style.cellBorderWidth);\r\n                    return cell.width;\r\n                };\r\n            }\r\n            function drawRowHeader(rowData, index, rowOrderIndex) {\r\n                var a, i;\r\n                if (self.attributes.showRowHeaders) {\r\n                    x = 0;\r\n                    i = index + 1;\r\n                    rowHeaderCell = {'rowHeaderCell': i };\r\n                    a = {\r\n                        name: 'rowHeaderCell',\r\n                        width: self.sizes.columns[-1] || self.style.rowHeaderCellWidth,\r\n                        style: 'rowHeaderCell',\r\n                        type: 'string',\r\n                        data: i,\r\n                        index: -1\r\n                    };\r\n                    rowOpen = self.openChildren[index];\r\n                    drawCell(rowHeaderCell, index, rowOrderIndex)(a, -1, -1);\r\n                }\r\n            }\r\n            function drawHeaders() {\r\n                var d, g = s.length, i, o, columnHeaderCell, header, nonFrozenHeaderWidth;\r\n                function drawHeaderColumnRange(start, end) {\r\n                    end = Math.min(end, g);\r\n                    for (o = start; o < end; o += 1) {\r\n                        i = self.orders.columns[o];\r\n                        header = s[i];\r\n                        if (!header.hidden) {\r\n                            d = {\r\n                                title: header.title,\r\n                                name: header.name,\r\n                                width: header.width || self.style.cellWidth,\r\n                                style: 'columnHeaderCell',\r\n                                type: 'string',\r\n                                index: o,\r\n                                order: i\r\n                            };\r\n                            columnHeaderCell = {'columnHeaderCell': header.title || header.name};\r\n                            x += drawCell(columnHeaderCell, -1, -1)(d, i, o);\r\n                            if (x > self.width + self.scrollBox.scrollLeft) {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                rowHeaders.forEach(function (rArgs, rhIndex) {\r\n                    y = rArgs[3];\r\n                    cellHeight = rArgs[4];\r\n                    if (rhIndex === self.frozenRow) {\r\n                        self.ctx.save();\r\n                        radiusRect(0, self.lastFrozenRowPixel, self.width, self.height - self.lastFrozenRowPixel, 0);\r\n                        self.ctx.clip();\r\n                    }\r\n                    drawRowHeader(rArgs[0], rArgs[1], rArgs[2]);\r\n                });\r\n                self.ctx.restore();\r\n                if (self.attributes.showColumnHeaders) {\r\n                    x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.columnHeaderCellBorderWidth;\r\n                    if (self.attributes.showRowHeaders) {\r\n                        x += rowHeaderCellWidth;\r\n                    }\r\n                    y = 0;\r\n                    // cell height might have changed during drawing\r\n                    cellHeight = self.getColumnHeaderCellHeight();\r\n                    drawHeaderColumnRange(self.scrollIndexLeft, g);\r\n                    nonFrozenHeaderWidth = x;\r\n                    x = self.style.columnHeaderCellBorderWidth;\r\n                    if (self.attributes.showRowHeaders) {\r\n                        x += rowHeaderCellWidth;\r\n                    }\r\n                    drawHeaderColumnRange(0, self.frozenColumn);\r\n                    // fill in the space right of the headers\r\n                    x = nonFrozenHeaderWidth;\r\n                    if (x < w) {\r\n                        c = {\r\n                            name: '',\r\n                            width: self.style.scrollBarWidth,\r\n                            style: 'columnHeaderCellCap',\r\n                            isColumnHeaderCell: true,\r\n                            isColumnHeaderCellCap: true,\r\n                            type: 'string',\r\n                            index: s.length\r\n                        };\r\n                        drawCell({endCap: ''}, -1, -1)(c, -1, -1);\r\n                    }\r\n                    // fill in the space right of the headers\r\n                    if (self.attributes.showRowHeaders) {\r\n                        cornerCell = {'cornerCell': '' };\r\n                        x = 0;\r\n                        c = {\r\n                            name: 'cornerCell',\r\n                            width: self.style.rowHeaderCellWidth,\r\n                            style: 'cornerCell',\r\n                            type: 'string',\r\n                            index: -1\r\n                        };\r\n                        drawCell(cornerCell, -1, -1)(c, -1, -1);\r\n                    }\r\n                }\r\n            }\r\n            function drawRow(r, d) {\r\n                var i, treeHeight, rowSansTreeHeight, o, g = s.length;\r\n                if (y - (cellHeight * 2) > h) {\r\n                    return false;\r\n                }\r\n                rd = data[r];\r\n                rowOpen = self.openChildren[r];\r\n                rowSansTreeHeight = (self.sizes.rows[r] || self.style.cellHeight) * self.scale;\r\n                treeHeight = (rowOpen ? self.sizes.trees[r] : 0) * self.scale;\r\n                rowHeight = (rowSansTreeHeight + treeHeight);\r\n                if (y < -rowHeight) {\r\n                    return false;\r\n                }\r\n                if (self.attributes.showRowHeaders) {\r\n                    x += rowHeaderCellWidth;\r\n                }\r\n                cellHeight = rowHeight;\r\n                //draw normal columns\r\n                for (o = (self.scrollIndexLeft); o < g; o += 1) {\r\n                    i = self.orders.columns[o];\r\n                    x += drawCell(rd, r, d)(s[i], i, o);\r\n                    if (x > self.width) {\r\n                        self.scrollIndexRight = o;\r\n                        self.scrollPixelRight = x;\r\n                        break;\r\n                    }\r\n                }\r\n                //draw frozen columns\r\n                x = 0;\r\n                if (self.attributes.showRowHeaders) {\r\n                    x += rowHeaderCellWidth;\r\n                }\r\n                for (o = 0; o < self.frozenColumn; o += 1) {\r\n                    i = self.orders.columns[o];\r\n                    x += drawCell(rd, r, d)(s[i], i, o);\r\n                    if (x > self.width) {\r\n                        break;\r\n                    }\r\n                }\r\n                self.lastFrozenColumnPixel = x;\r\n                // cell height might have changed during drawing\r\n                cellHeight = rowHeight;\r\n                x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.cellBorderWidth;\r\n                // don't draw a tree for the new row\r\n                treeGrid = self.childGrids[r];\r\n                if (r !== data.length && rowOpen) {\r\n                    treeGrid.visible = true;\r\n                    treeGrid.parentNode = {\r\n                        offsetTop: y + rowSansTreeHeight + self.canvasOffsetTop,\r\n                        offsetLeft: rowHeaderCellWidth - 1 + self.canvasOffsetLeft,\r\n                        offsetHeight: treeHeight,\r\n                        offsetWidth: self.width - rowHeaderCellWidth - self.style.scrollBarWidth - 1,\r\n                        offsetParent: self.intf.parentNode,\r\n                        parentNode: self.intf.parentNode,\r\n                        style: self.style,\r\n                        nodeType: 'canvas-datagrid-tree',\r\n                        scrollTop: self.scrollBox.scrollTop,\r\n                        scrollLeft: self.scrollBox.scrollLeft,\r\n                        rowIndex: r\r\n                    };\r\n                    self.visibleCells.unshift({\r\n                        rowIndex: r,\r\n                        columnIndex: 0,\r\n                        y: treeGrid.parentNode.offsetTop,\r\n                        x: treeGrid.parentNode.offsetLeft,\r\n                        height: treeGrid.height,\r\n                        width: treeGrid.width,\r\n                        style: 'tree-grid',\r\n                        type: treeGrid.parentNode.nodeType\r\n                    });\r\n                    treeGrid.draw();\r\n                } else if (treeGrid) {\r\n                    treeGrid.parentNode.offsetHeight = 0;\r\n                    delete self.sizes.trees[r];\r\n                }\r\n                rowHeaders.push([rd, r, d, y, rowHeight]);\r\n                self.visibleRowHeights[r] = rowHeight;\r\n                y += cellHeight + (bc ? 0 : self.style.cellBorderWidth);\r\n                return true;\r\n            }\r\n            function initDraw() {\r\n                self.visibleRows = [];\r\n                s = self.getSchema();\r\n                self.visibleCells = [];\r\n                self.canvasOffsetTop = self.isChildGrid ? self.parentNode.offsetTop : 0;\r\n                self.canvasOffsetLeft = self.isChildGrid ? self.parentNode.offsetLeft : 0;\r\n                h = self.height;\r\n                w = self.width;\r\n            }\r\n            function drawBackground() {\r\n                radiusRect(0, 0, w, h, 0);\r\n                self.ctx.clip();\r\n                self.ctx.fillStyle = self.style.gridBackgroundColor;\r\n                fillRect(0, 0, w, h);\r\n            }\r\n            function drawFrozenRows() {\r\n                var n, ln = Math.min(data.length, self.frozenRow);\r\n                x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.cellBorderWidth;\r\n                y = columnHeaderCellHeight;\r\n                for (r = 0; r < ln; r += 1) {\r\n                    n = self.orders.rows[r];\r\n                    if (!drawRow(n, r)) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (self.attributes.allowFreezingRows) {\r\n                    // HACK great, another stupid magic number.\r\n                    // Background will appear as a 0.5px artifact behind the row freeze bar without this hack\r\n                    y += self.style.frozenMarkerBorderWidth + self.style.frozenMarkerWidth - 0.4999999999;\r\n                }\r\n                self.lastFrozenRowPixel = y;\r\n            }\r\n            function drawRows() {\r\n                self.ctx.save();\r\n                if (self.frozenRow > 0) {\r\n                    radiusRect(0, self.lastFrozenRowPixel, self.width, self.height - self.lastFrozenRowPixel, 0);\r\n                    self.ctx.clip();\r\n                }\r\n                var o, n, i, g = s.length;\r\n                x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.cellBorderWidth;\r\n                if (!self.attributes.snapToRow) {\r\n                    y += -self.scrollBox.scrollTop + self.scrollPixelTop + self.style.cellBorderWidth;\r\n                }\r\n                for (r = self.frozenRow + self.scrollIndexTop; r < l; r += 1) {\r\n                    n = self.orders.rows[r];\r\n                    self.scrollIndexBottom = r;\r\n                    self.scrollPixelBottom = y;\r\n                    if (!drawRow(n, r)) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (self.attributes.showNewRow) {\r\n                    if (self.attributes.showRowHeaders) {\r\n                        x += rowHeaderCellWidth;\r\n                    }\r\n                    rowHeight = cellHeight = self.style.cellHeight;\r\n                    rowOpen = false;\r\n                    for (o = self.scrollIndexLeft; o < g; o += 1) {\r\n                        i = self.orders.columns[o];\r\n                        x += drawCell(self.newRow, data.length, data.length)(s[i], i, o);\r\n                        if (x > self.width + self.scrollBox.scrollLeft) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    rowHeaders.push([self.newRow, data.length, data.length, y, rowHeight]);\r\n                }\r\n                self.ctx.restore();\r\n            }\r\n            function drawMoveMarkers() {\r\n                if (!self.movingSelection) { return; }\r\n                self.ctx.lineWidth = self.style.moveOverlayBorderWidth;\r\n                self.ctx.strokeStyle = self.style.moveOverlayBorderColor;\r\n                self.ctx.setLineDash(self.style.moveOverlayBorderSegments);\r\n                moveBorders.forEach(function (c) {\r\n                    addBorderLine(c[0], c[1]);\r\n                });\r\n                self.ctx.setLineDash([]);\r\n            }\r\n            function drawReorderMarkers() {\r\n                if (!self.reorderObject) { return; }\r\n                var b = {\r\n                        height: self.reorderObject.height,\r\n                        width: self.reorderObject.width,\r\n                        x: self.reorderObject.x + self.reorderObject.dragOffset.x,\r\n                        y: self.reorderObject.y + self.reorderObject.dragOffset.y\r\n                    },\r\n                    m = {\r\n                        width: w,\r\n                        height: h,\r\n                        x: 0,\r\n                        y: 0\r\n                    };\r\n                self.ctx.fillStyle = self.style.reorderMarkerBackgroundColor;\r\n                self.ctx.lineWidth = self.style.reorderMarkerBorderWidth;\r\n                self.ctx.strokeStyle = self.style.reorderMarkerBorderColor;\r\n                if (self.dragMode === 'row-reorder') {\r\n                    b.width = w;\r\n                    b.x = 0;\r\n                    m.width = w;\r\n                    m.height = self.currentCell.height;\r\n                    m.y = self.currentCell.y;\r\n                    fillRect(b.x, b.y, b.width, b.height);\r\n                    strokeRect(b.x, b.y, b.width, b.height);\r\n                    self.ctx.lineWidth = self.style.reorderMarkerIndexBorderWidth;\r\n                    self.ctx.strokeStyle = self.style.reorderMarkerIndexBorderColor;\r\n                    if (self.currentCell.rowIndex !== self.reorderObject.rowIndex\r\n                            && self.currentCell.rowIndex > -1\r\n                            && self.currentCell.rowIndex < l) {\r\n                        addBorderLine(m, self.reorderTarget.sortRowIndex > self.reorderObject.sortRowIndex ? 'b' : 't');\r\n                    }\r\n                } else if (self.dragMode === 'column-reorder' && self.reorderObject) {\r\n                    b.height = h;\r\n                    b.y = 0;\r\n                    m.height = h;\r\n                    m.width = self.currentCell.width;\r\n                    m.y = 0;\r\n                    m.x = self.currentCell.x;\r\n                    fillRect(b.x, b.y, b.width, b.height);\r\n                    strokeRect(b.x, b.y, b.width, b.height);\r\n                    self.ctx.lineWidth = self.style.reorderMarkerIndexBorderWidth;\r\n                    self.ctx.strokeStyle = self.style.reorderMarkerIndexBorderColor;\r\n                    if (self.currentCell.sortColumnIndex !== self.reorderObject.sortColumnIndex\r\n                            && self.currentCell.sortColumnIndex > -1\r\n                            && self.currentCell.sortColumnIndex < s.length) {\r\n                        addBorderLine(m, self.reorderTarget.columnIndex > self.reorderObject.columnIndex ? 'r' : 'l');\r\n                    }\r\n                }\r\n            }\r\n            function drawBorder() {\r\n                self.ctx.lineWidth = self.style.gridBorderWidth;\r\n                self.ctx.strokeStyle = self.style.gridBorderColor;\r\n                strokeRect(0, 0, self.width, self.height);\r\n            }\r\n            function drawSelectionBorders() {\r\n                self.ctx.lineWidth = self.style.selectionOverlayBorderWidth;\r\n                self.ctx.strokeStyle = self.style.selectionOverlayBorderColor;\r\n                function dsb(c) {\r\n                    addBorderLine(c[0], c[1]);\r\n                }\r\n                selectionBorders.filter(function (c) {\r\n                    return c[0].rowIndex < self.frozenRow && c[0].columnIndex < self.frozenColumn;\r\n                }).forEach(dsb);\r\n                self.ctx.save();\r\n                clipFrozenArea(0);\r\n                selectionBorders.filter(function (c) {\r\n                    return c[0].rowIndex >= self.frozenRow && c[0].columnIndex >= self.frozenColumn;\r\n                }).forEach(dsb);\r\n                self.ctx.restore();\r\n                self.ctx.save();\r\n                clipFrozenArea(1);\r\n                selectionBorders.filter(function (c) {\r\n                    return c[0].rowIndex >= self.frozenRow && c[0].columnIndex < self.frozenColumn;\r\n                }).forEach(dsb);\r\n                self.ctx.restore();\r\n                self.ctx.save();\r\n                clipFrozenArea(2);\r\n                selectionBorders.filter(function (c) {\r\n                    return c[0].rowIndex < self.frozenRow && c[0].columnIndex >= self.frozenColumn;\r\n                }).forEach(dsb);\r\n                self.ctx.restore();\r\n            }\r\n            function drawSelectionHandles() {\r\n                if (self.mobile || self.attributes.allowMovingSelection) {\r\n                    self.ctx.lineWidth = self.style.selectionHandleBorderWidth;\r\n                    self.ctx.strokeStyle = self.style.selectionHandleBorderColor;\r\n                    self.ctx.fillStyle = self.style.selectionHandleColor;\r\n                    selectionHandles.forEach(function (c) {\r\n                        addselectionHandle(c[0], c[1]);\r\n                        var az = self.attributes.touchSelectHandleZone / 2,\r\n                            ax = c[0].x + (c[1] === 'tl' || c[1] === 'bl' ? 0 : c[0].width) - az,\r\n                            ay = c[0].y + (c[1] === 'bl' || c[1] === 'br' ? c[0].height : 0) - az;\r\n                        self.visibleCells.unshift({\r\n                            x: ax,\r\n                            y: ay,\r\n                            height: self.style.selectionHandleSize + az,\r\n                            width: self.style.selectionHandleSize + az,\r\n                            style: 'selection-handle-' + c[1]\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n            function drawActiveCell() {\r\n                if (!aCell) { return; }\r\n                self.ctx.save();\r\n                var cl = self.activeCell.columnIndex + 1 > self.frozenColumn || self.activeCell.rowIndex + 1 > self.frozenRow,\r\n                    acx = cl ? self.lastFrozenColumnPixel : 0,\r\n                    acy = cl ? self.lastFrozenRowPixel : 0,\r\n                    acw = cl ? self.width - self.lastFrozenColumnPixel : self.width,\r\n                    ach = cl ? self.height - self.lastFrozenRowPixel : self.height;\r\n                radiusRect(acx, acy, acw, ach, 0);\r\n                self.ctx.clip();\r\n                if (self.attributes.selectionMode === 'row') {\r\n                    if (self.activeCell && self.activeCell.rowIndex === aCell.rowIndex) {\r\n                        self.ctx.lineWidth = self.style.activeCellOverlayBorderWidth;\r\n                        self.ctx.strokeStyle = self.style.activeCellOverlayBorderColor;\r\n                        strokeRect(0, aCell.y, self.getHeaderWidth() + rowHeaderCellWidth, self.visibleRowHeights[aCell.rowIndex]);\r\n                    }\r\n                } else {\r\n                    self.ctx.lineWidth = self.style.activeCellOverlayBorderWidth;\r\n                    self.ctx.strokeStyle = self.style.activeCellOverlayBorderColor;\r\n                    strokeRect(aCell.x, aCell.y, aCell.width, aCell.height);\r\n                }\r\n                self.ctx.restore();\r\n            }\r\n            function drawFrozenMarkers() {\r\n                var my = self.lastFrozenRowPixel - self.style.frozenMarkerWidth,\r\n                    mx = self.lastFrozenColumnPixel - self.style.frozenMarkerBorderWidth,\r\n                    xHover = self.currentCell && self.currentCell.style === 'frozen-row-marker',\r\n                    yHover = self.currentCell && self.currentCell.style === 'frozen-column-marker';\r\n                self.ctx.lineWidth = self.style.frozenMarkerBorderWidth;\r\n                if (self.attributes.allowFreezingColumns) {\r\n                    self.ctx.fillStyle = yHover ? self.style.frozenMarkerHoverColor : self.style.frozenMarkerColor;\r\n                    self.ctx.strokeStyle = yHover ? self.style.frozenMarkerHoverBorderColor : self.style.frozenMarkerBorderColor;\r\n                    fillRect(mx, 0, self.style.frozenMarkerWidth, self.height);\r\n                    strokeRect(mx, 0, self.style.frozenMarkerWidth, self.height);\r\n                    self.visibleCells.unshift({\r\n                        x: mx,\r\n                        y: 0,\r\n                        height: self.height,\r\n                        width: self.style.frozenMarkerWidth + self.style.frozenMarkerBorderWidth,\r\n                        style: 'frozen-column-marker'\r\n                    });\r\n                }\r\n                if (self.attributes.allowFreezingRows) {\r\n                    self.ctx.fillStyle = xHover ? self.style.frozenMarkerHoverColor : self.style.frozenMarkerColor;\r\n                    self.ctx.strokeStyle = xHover ? self.style.frozenMarkerHoverBorderColor : self.style.frozenMarkerBorderColor;\r\n                    fillRect(0, my, self.width, self.style.frozenMarkerWidth);\r\n                    strokeRect(0, my, self.width, self.style.frozenMarkerWidth);\r\n                    self.visibleCells.unshift({\r\n                        x: 0,\r\n                        y: my,\r\n                        height: self.style.frozenMarkerWidth + self.style.frozenMarkerBorderWidth,\r\n                        width: self.width,\r\n                        style: 'frozen-row-marker'\r\n                    });\r\n                }\r\n                if (self.freezeMarkerPosition) {\r\n                    self.ctx.fillStyle = self.style.frozenMarkerActiveColor;\r\n                    self.ctx.strokeStyle = self.style.frozenMarkerActiveBorderColor;\r\n                    if (self.dragMode === 'frozen-column-marker') {\r\n                        fillRect(self.freezeMarkerPosition.x, 0, self.style.frozenMarkerWidth, self.height);\r\n                        strokeRect(self.freezeMarkerPosition.x, 0, self.style.frozenMarkerWidth, self.height);\r\n                    } else {\r\n                        fillRect(0, self.freezeMarkerPosition.y, self.width, self.style.frozenMarkerWidth);\r\n                        strokeRect(0, self.freezeMarkerPosition.y, self.width, self.style.frozenMarkerWidth);\r\n                    }\r\n                }\r\n            }\r\n            function drawPerfLines() {\r\n                if (!self.attributes.showPerformance) { return; }\r\n                var pw = 250,\r\n                    px = self.width - pw - self.style.scrollBarWidth - (self.style.scrollBarBorderWidth * 2),\r\n                    py = columnHeaderCellHeight,\r\n                    ph = 100;\r\n                if (scrollDebugCounters.length === 0) { scrollDebugCounters = fillArray(0, perfWindowSize, 1, function () { return [0, 0]; }); }\r\n                if (touchPPSCounters.length === 0) { touchPPSCounters = fillArray(0, perfWindowSize, 1, function () { return [0, 0]; }); }\r\n                if (entityCount.length === 0) { entityCount = fillArray(0, perfWindowSize, 1, 0); }\r\n                self.ctx.lineWidth = 0.5;\r\n                function dpl(name, perfArr, arrIndex, max, color, useAbs, rowIndex) {\r\n                    var v;\r\n                    drawPerfLine(pw, ph, px, py, perfArr, arrIndex, max, color, useAbs);\r\n                    self.ctx.fillStyle = color;\r\n                    fillRect(3 + px, py + 9 + (rowIndex * 11), 8, 8);\r\n                    self.ctx.fillStyle = self.style.debugPerfChartTextColor;\r\n                    v = arrIndex !== undefined ? perfArr[0][arrIndex] : perfArr[0];\r\n                    fillText(name + ' ' + (isNaN(v) ? 0 : v).toFixed(3), 14 + px, py + 16 + (rowIndex * 11));\r\n                }\r\n                self.ctx.textAlign = 'left';\r\n                self.ctx.font = self.style.debugFont;\r\n                self.ctx.fillStyle = self.style.debugPerfChartBackground;\r\n                fillRect(px, py, pw, ph);\r\n                [['Scroll Height', scrollDebugCounters, 0, self.scrollBox.scrollHeight, self.style.debugScrollHeightColor, false],\r\n                    ['Scroll Width', scrollDebugCounters, 1, self.scrollBox.scrollWidth, self.style.debugScrollWidthColor, false],\r\n                    ['Performance', perfCounters, undefined, 200, self.style.debugPerformanceColor, false],\r\n                    ['Entities', entityCount, undefined, 1500, self.style.debugEntitiesColor, false],\r\n                    ['TouchPPSX', touchPPSCounters, 0, 1000, self.style.debugTouchPPSXColor, true],\r\n                    ['TouchPPSY', touchPPSCounters, 1, 1000, self.style.debugTouchPPSYColor, true]\r\n                    ].forEach(function (i, index) {\r\n                    i.push(index);\r\n                    dpl.apply(null, i);\r\n                });\r\n                self.ctx.fillStyle = self.style.debugPerfChartBackground;\r\n                entityCount.pop();\r\n                entityCount.unshift(self.visibleCells.length);\r\n                scrollDebugCounters.pop();\r\n                scrollDebugCounters.unshift([self.scrollBox.scrollTop, self.scrollBox.scrollLeft]);\r\n                touchPPSCounters.pop();\r\n                touchPPSCounters.unshift([self.yPPS, self.xPPS]);\r\n            }\r\n            function drawDebug() {\r\n                self.ctx.save();\r\n                var d;\r\n                if (self.attributes.showPerformance || self.attributes.debug) {\r\n                    if (perfCounters.length === 0) { perfCounters = fillArray(0, perfWindowSize, 1, 0); }\r\n                    perfCounters.pop();\r\n                    perfCounters.unshift(performance.now() - p);\r\n                }\r\n                if (!self.attributes.debug) {\r\n                    self.ctx.restore();\r\n                    return;\r\n                }\r\n                self.ctx.font = self.style.debugFont;\r\n                d = {};\r\n                d.perf = (perfCounters.reduce(function (a, b) {\r\n                    return a + b;\r\n                }, 0) / Math.min(drawCount, perfCounters.length)).toFixed(1);\r\n                d.perfDelta = perfCounters[0].toFixed(1);\r\n                d.frozenColumnsWidth = getFrozenColumnsWidth();\r\n                d.htmlImages = Object.keys(self.htmlImageCache).length;\r\n                d.reorderObject = 'x: ' + (self.reorderObject || {columnIndex: 0}).columnIndex + ', y: ' + (self.reorderObject || {rowIndex: 0}).rowIndex;\r\n                d.reorderTarget = 'x: ' + (self.reorderTarget || {columnIndex: 0}).columnIndex + ', y: ' + (self.reorderTarget || {rowIndex: 0}).rowIndex;\r\n                d.scale = self.scale;\r\n                d.startScale = self.startScale;\r\n                d.scaleDelta = self.scaleDelta;\r\n                d.zoomDeltaStart = self.zoomDeltaStart;\r\n                d.touchLength = self.touchLength;\r\n                d.touches = 'y0: ' + (self.touchPosition || {y: 0}).y + ' y1: ' + (self.touchPosition1 || {y: 0}).y;\r\n                d.scrollBox = self.scrollBox.toString();\r\n                d.scrollIndex = 'x: ' + self.scrollIndexLeft + ', y: ' + self.scrollIndexTop;\r\n                d.scrollPixel = 'x: ' + self.scrollPixelLeft + ', y: ' + self.scrollPixelTop;\r\n                d.canvasOffset = 'x: ' + self.canvasOffsetLeft + ', y: ' + self.canvasOffsetTop;\r\n                d.touchDelta = 'x: ' + self.touchDelta.x + ', y: ' + self.touchDelta.y;\r\n                d.touchAnimateTo = 'x: ' + self.touchAnimateTo.x + ', y: ' + self.touchAnimateTo.y;\r\n                d.scrollAnimation = 'x: ' + self.scrollAnimation.x + ', y: ' + self.scrollAnimation.y;\r\n                d.touchPPS = 'x: ' + self.xPPS + ', y: ' + self.yPPS;\r\n                d.touchPPST = 'x: ' + self.xPPST + ', y: ' + self.yPPST;\r\n                d.touchDuration = self.touchDuration;\r\n                d.pointerLockPosition =  self.pointerLockPosition ?\r\n                        self.pointerLockPosition.x + ', ' + self.pointerLockPosition.y : '';\r\n                d.size = 'w: ' + self.width + ', h: ' + self.height;\r\n                d.mouse = 'x: ' + self.mouse.x + ', y: ' + self.mouse.y;\r\n                d.touch = !self.touchStart\r\n                    ? '' : 'x: ' + self.touchStart.x + ', y: ' + self.touchStart.y;\r\n                d.entities = self.visibleCells.length;\r\n                d.hasFocus = self.hasFocus;\r\n                d.dragMode = self.dragMode;\r\n                if (self.currentCell) {\r\n                    d.columnIndex = self.currentCell.columnIndex;\r\n                    d.rowIndex = self.currentCell.rowIndex;\r\n                    d.sortColumnIndex = self.currentCell.sortColumnIndex;\r\n                    d.sortRowIndex = self.currentCell.sortRowIndex;\r\n                    d.context = self.currentCell.context;\r\n                    d.dragContext = self.currentCell.dragContext;\r\n                    d.style = self.currentCell.style;\r\n                    d.type = self.currentCell.type;\r\n                }\r\n                self.ctx.textAlign = 'right';\r\n                self.ctx.fillStyle = self.style.debugBackgroundColor;\r\n                fillRect(0, 0, self.width, self.height);\r\n                Object.keys(d).forEach(function (key, index) {\r\n                    var m = key + ': ' + d[key],\r\n                        lh = 14;\r\n                    self.ctx.fillStyle = self.style.debugColor;\r\n                    fillText(m, w - 20, (self.attributes.showPerformance ? 140 : 24) + (index * lh));\r\n                });\r\n                self.ctx.restore();\r\n            }\r\n            self.ctx.save();\r\n            initDraw();\r\n            drawBackground();\r\n            drawFrozenRows();\r\n            drawRows();\r\n            drawActiveCell();\r\n            drawHeaders();\r\n            drawFrozenMarkers();\r\n            drawSelectionHandles();\r\n            drawReorderMarkers();\r\n            drawMoveMarkers();\r\n            drawBorder();\r\n            drawSelectionBorders();\r\n            if (checkScrollHeight) {\r\n                self.resize(true);\r\n            }\r\n            drawDebug();\r\n            drawPerfLines();\r\n            if (self.dispatchEvent('afterdraw', {})) { return; }\r\n            self.ctx.restore();\r\n        };\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/draw.js\n// module id = 3\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true, plusplus: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        var wheeling;\r\n        self.stopPropagation = function (e) { e.stopPropagation(); };\r\n        /**\r\n         * Adds an event listener to the given event.\r\n         * @memberof canvasDatagrid\r\n         * @name addEventListener\r\n         * @method\r\n         * @param {string} ev The name of the event to subscribe to.\r\n         * @param {function} fn The event procedure to execute when the event is raised.\r\n         */\r\n        self.addEventListener = function (ev, fn) {\r\n            self.events[ev] = self.events[ev] || [];\r\n            self.events[ev].unshift(fn);\r\n        };\r\n        /**\r\n         * Removes the given listener function from the given event.  Must be an actual reference to the function that was bound.\r\n         * @memberof canvasDatagrid\r\n         * @name removeEventListener\r\n         * @method\r\n         * @param {string} ev The name of the event to unsubscribe from.\r\n         * @param {function} fn The event procedure to execute when the event is raised.\r\n         */\r\n        self.removeEventListener = function (ev, fn) {\r\n            (self.events[ev] || []).forEach(function removeEachListener(sfn, idx) {\r\n                if (fn === sfn) {\r\n                    self.events[ev].splice(idx, 1);\r\n                }\r\n            });\r\n        };\r\n        /**\r\n         * Fires the given event, padding an event object to the event subscribers.\r\n         * @memberof canvasDatagrid\r\n         * @name dispatchEvent\r\n         * @method\r\n         * @param {number} ev The name of the event to dispatch.\r\n         * @param {number} e The event object.\r\n         */\r\n        self.dispatchEvent = function (ev, e) {\r\n            e = ev.type ? ev : (e || {});\r\n            ev = ev.type || ev;\r\n            var defaultPrevented;\r\n            function preventDefault() {\r\n                defaultPrevented = true;\r\n            }\r\n            if (!self.events[ev]) { return; }\r\n            self.events[ev].forEach(function dispatchEachEvent(fn) {\r\n                e.ctx = self.ctx;\r\n                e.preventDefault = preventDefault;\r\n                fn.apply(self.intf, [e]);\r\n            });\r\n            return defaultPrevented;\r\n        };\r\n        self.getRatio = function () {\r\n            return Math.min(self.attributes.maxPixelRatio, (window.devicePixelRatio || 1) /\r\n                (self.ctx.webkitBackingStorePixelRatio ||\r\n                    self.ctx.mozBackingStorePixelRatio ||\r\n                    self.ctx.msBackingStorePixelRatio ||\r\n                    self.ctx.oBackingStorePixelRatio ||\r\n                    self.ctx.backingStorePixelRatio || 1));\r\n        };\r\n        self.resize = function (drawAfterResize) {\r\n            if (!self.canvas) { return; }\r\n            var x,\r\n                v = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    height: 0,\r\n                    width: 0,\r\n                    style: 'vertical-scroll-bar'\r\n                },\r\n                n = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    height: 0,\r\n                    width: 0,\r\n                    style: 'horizontal-scroll-bar'\r\n                },\r\n                vb = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    height: 0,\r\n                    width: 0,\r\n                    style: 'vertical-scroll-box'\r\n                },\r\n                nb = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    height: 0,\r\n                    width: 0,\r\n                    style: 'horizontal-scroll-box'\r\n                },\r\n                co = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    height: 0,\r\n                    width: 0,\r\n                    isCorner: true,\r\n                    isScrollBoxCorner: true,\r\n                    style: 'scroll-box-corner'\r\n                },\r\n                m = (self.style.scrollBarBoxMargin * 2),\r\n                b = (self.style.scrollBarBorderWidth * 2),\r\n                d = self.style.scrollBarBoxMargin * 0.5,\r\n                sbw = self.style.scrollBarWidth + (self.style.scrollBarBorderWidth * 2),\r\n                ratio = self.getRatio(),\r\n                bm = self.style.gridBorderCollapse === 'collapse' ? 1 : 2,\r\n                cellBorder = self.style.cellBorderWidth * bm,\r\n                columnHeaderCellBorder = self.style.columnHeaderCellBorderWidth * bm,\r\n                dataHeight = 0,\r\n                dataWidth = 0,\r\n                dims,\r\n                l = (self.data || []).length,\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n                rowHeaderCellWidth = self.getRowHeaderCellWidth(),\r\n                ch = self.style.cellHeight,\r\n                s = self.getSchema();\r\n            // sets actual DOM canvas element\r\n            function checkScrollBoxVisibility() {\r\n                self.scrollBox.horizontalBarVisible = (self.style.width !== 'auto' && dataWidth > self.scrollBox.width && self.style.overflowX !== 'hidden')\r\n                    || self.style.overflowX === 'scroll';\r\n                self.scrollBox.horizontalBoxVisible = dataWidth > self.scrollBox.width;\r\n                self.scrollBox.verticalBarVisible = (self.style.height !== 'auto' && dataHeight > self.scrollBox.height && self.style.overflowY !== 'hidden')\r\n                    || self.style.overflowY === 'scroll';\r\n                self.scrollBox.verticalBoxVisible = dataHeight > self.scrollBox.height;\r\n            }\r\n            function setScrollBoxSize() {\r\n                self.scrollBox.width = self.width - rowHeaderCellWidth;\r\n                self.scrollBox.height = self.height - columnHeaderCellHeight;\r\n            }\r\n            function setCanvasSize() {\r\n                if (self.isChildGrid) {\r\n                    return;\r\n                }\r\n                dims = {\r\n                    // HACK +1 ? maybe it's a magic cell border?  Required to line up properly in auto height mode.\r\n                    height: columnHeaderCellHeight + dataHeight + cellBorder + 1,\r\n                    width: dataWidth + rowHeaderCellWidth + cellBorder\r\n                };\r\n                ['width', 'height'].forEach(function (dim) {\r\n                    //TODO: support inherit\r\n                    if (['auto', undefined].indexOf(self.style[dim]) !== -1\r\n                            && ['auto', undefined].indexOf(self.appliedInlineStyles[dim]) !== -1) {\r\n                        self.parentNodeStyle[dim] = dims[dim] + 'px';\r\n                    } else {\r\n                        self.parentNodeStyle[dim] = self.style[dim];\r\n                        if (self.isComponet) {\r\n                            self.canvas.style[dim] = self.style[dim];\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            self.scrollCache.x = [];\r\n            self.scrollCache.y = [];\r\n            for (x = 0; x < l; x += 1) {\r\n                self.scrollCache.y[x] = dataHeight;\r\n                dataHeight += (((self.sizes.rows[x] || ch) + (self.sizes.trees[x] || 0)) * self.scale)\r\n                    // HACK? if an expanded tree row is frozen it is necessary to add the tree row's height a second time.\r\n                    + (self.frozenRow > x ? (self.sizes.trees[x] || 0) : 0);\r\n            }\r\n            if (l > 1) {\r\n                self.scrollCache.y[x] = dataHeight;\r\n            }\r\n            dataWidth = s.reduce(function reduceSchema(accumulator, column, columnIndex) {\r\n                // intentional redefintion of column.  This causes scrollCache to be in the correct order\r\n                column = s[self.orders.columns[columnIndex]];\r\n                if (column.hidden) {\r\n                    self.scrollCache.x[columnIndex] = accumulator;\r\n                    return accumulator;\r\n                }\r\n                var va = accumulator + self.getColummnWidth(self.orders.columns[columnIndex]);\r\n                self.scrollCache.x[columnIndex] = va;\r\n                return va;\r\n            }, 0) || 0;\r\n            if (self.attributes.showNewRow) {\r\n                dataHeight += ch;\r\n            }\r\n            if (self.attributes.snapToRow) {\r\n              dataHeight += self.style.cellHeight;\r\n            }\r\n            setCanvasSize();\r\n            if (self.isChildGrid) {\r\n                self.width = self.parentNode.offsetWidth;\r\n                self.height = self.parentNode.offsetHeight;\r\n            } else if (self.height !== self.canvas.offsetHeight || self.width !== self.canvas.offsetWidth) {\r\n                self.height = self.canvas.offsetHeight;\r\n                self.width = self.canvas.offsetWidth;\r\n                self.canvasOffsetLeft = self.args.canvasOffsetLeft || 0;\r\n                self.canvasOffsetTop = self.args.canvasOffsetTop || 0;\r\n            }\r\n            /// calculate scroll bar dimensions\r\n            // non-controversial\r\n            self.scrollBox.top = columnHeaderCellHeight + columnHeaderCellBorder;\r\n            self.scrollBox.left = rowHeaderCellWidth;\r\n            // width and height of scroll box\r\n            setScrollBoxSize();\r\n            // is the data larger than the scroll box\r\n            checkScrollBoxVisibility();\r\n            // if the scroll box is visible, make room for it by expanding the size of the element\r\n            // if the other dimension is set to auto\r\n            if (self.scrollBox.horizontalBarVisible) {\r\n                if (self.style.height === 'auto' && !self.isChildGrid) {\r\n                    self.height += sbw;\r\n                }\r\n                dataHeight += sbw;\r\n                setCanvasSize();\r\n                setScrollBoxSize();\r\n                checkScrollBoxVisibility();\r\n            }\r\n            if (self.scrollBox.verticalBarVisible) {\r\n                if (self.style.width === 'auto' && !self.isChildGrid) {\r\n                    self.width += sbw;\r\n                }\r\n                dataWidth += sbw;\r\n                setCanvasSize();\r\n                setScrollBoxSize();\r\n                checkScrollBoxVisibility();\r\n            }\r\n            // set again after bar visibility checks\r\n            setScrollBoxSize();\r\n            self.scrollBox.scrollWidth = dataWidth - self.scrollBox.width;\r\n            self.scrollBox.scrollHeight = dataHeight - self.scrollBox.height;\r\n            self.scrollBox.widthBoxRatio = self.scrollBox.width / dataWidth;\r\n            self.scrollBox.scrollBoxWidth = self.scrollBox.width\r\n                * self.scrollBox.widthBoxRatio\r\n                - self.style.scrollBarWidth - b - d;\r\n            // TODO: This heightBoxRatio number is terribly wrong.\r\n            // They should be a result of the size of the grid/canvas?\r\n            // it being off causes the scroll bar to \"slide\" under\r\n            // the dragged mouse.\r\n            // https://github.com/TonyGermaneri/canvas-datagrid/issues/97\r\n            self.scrollBox.heightBoxRatio = (self.scrollBox.height - columnHeaderCellHeight) / dataHeight;\r\n            self.scrollBox.scrollBoxHeight = self.scrollBox.height\r\n                * self.scrollBox.heightBoxRatio\r\n                - self.style.scrollBarWidth - b - d;\r\n            self.scrollBox.scrollBoxWidth = Math.max(self.scrollBox.scrollBoxWidth, self.style.scrollBarBoxMinSize);\r\n            self.scrollBox.scrollBoxHeight = Math.max(self.scrollBox.scrollBoxHeight, self.style.scrollBarBoxMinSize);\r\n            // horizontal\r\n            n.x += rowHeaderCellWidth;\r\n            n.y += self.height - self.style.scrollBarWidth - d;\r\n            n.width = self.width - self.style.scrollBarWidth - rowHeaderCellWidth - d - m;\r\n            n.height = self.style.scrollBarWidth + self.style.scrollBarBorderWidth + d;\r\n            // horizontal box\r\n            nb.y = n.y + self.style.scrollBarBoxMargin;\r\n            nb.width = self.scrollBox.scrollBoxWidth;\r\n            nb.height = self.style.scrollBarBoxWidth;\r\n            // vertical\r\n            v.x += self.width - self.style.scrollBarWidth - self.style.scrollBarBorderWidth - d;\r\n            v.y += columnHeaderCellHeight;\r\n            v.width = self.style.scrollBarWidth + self.style.scrollBarBorderWidth + d;\r\n            v.height = self.height - columnHeaderCellHeight - self.style.scrollBarWidth - d - m;\r\n            // vertical box\r\n            vb.x = v.x + self.style.scrollBarBoxMargin;\r\n            vb.width = self.style.scrollBarBoxWidth;\r\n            vb.height = self.scrollBox.scrollBoxHeight;\r\n            // corner\r\n            co.x = n.x + n.width + m;\r\n            co.y = v.y + v.height + m;\r\n            co.width = self.style.scrollBarWidth + self.style.scrollBarBorderWidth;\r\n            co.height = self.style.scrollBarWidth + self.style.scrollBarBorderWidth;\r\n            self.scrollBox.entities = {\r\n                horizontalBar: n,\r\n                horizontalBox: nb,\r\n                verticalBar: v,\r\n                verticalBox: vb,\r\n                corner: co\r\n            };\r\n            self.scrollBox.bar = {\r\n                v: v,\r\n                h: n\r\n            };\r\n            self.scrollBox.box = {\r\n                v: vb,\r\n                h: nb\r\n            };\r\n            /// calculate page and dom elements\r\n            self.page = Math.max(1, self.visibleRows.length - 3 - self.attributes.pageUpDownOverlap);\r\n            // set canvas drawing related items\r\n            if (!self.isChildGrid) {\r\n                self.canvas.width = self.width * ratio;\r\n                self.canvas.height = self.height * ratio;\r\n                self.ctx.scale(ratio, ratio);\r\n            }\r\n            // resize any open dom elements (input/textarea)\r\n            self.resizeEditInput();\r\n            self.scroll(true);\r\n            if (drawAfterResize) {\r\n                self.draw(true);\r\n            }\r\n            self.dispatchEvent('resize', {});\r\n            return true;\r\n        };\r\n        self.scroll = function (dontDraw) {\r\n            var s = self.getSchema(),\r\n                l = (self.data || []).length,\r\n                ch = self.style.cellHeight;\r\n            // go too far in leaps, then get focused\r\n            self.scrollIndexTop = Math.floor((l * (self.scrollBox.scrollTop / self.scrollBox.scrollHeight)) - 100);\r\n            self.scrollIndexTop = Math.max(self.scrollIndexTop, 0);\r\n            self.scrollPixelTop = self.scrollCache.y[self.scrollIndexTop];\r\n            // sometimes the grid is rendered but the height is zero\r\n            if (self.scrollBox.scrollHeight === 0) {\r\n                self.scrollIndexTop = 0;\r\n            }\r\n            self.scrollPixelTop = 0;\r\n            self.scrollIndexLeft = self.frozenColumn;\r\n            self.scrollPixelLeft = 0;\r\n            while (self.scrollPixelTop < self.scrollBox.scrollTop && self.scrollIndexTop < self.data.length) {\r\n                // start on index +1 since index 0 was used in \"go too far\" section above\r\n                self.scrollIndexTop += 1;\r\n                self.scrollPixelTop = self.scrollCache.y[self.scrollIndexTop];\r\n            }\r\n            while (self.scrollPixelLeft < (self.scrollBox.scrollLeft + 1) && self.scrollIndexLeft < s.length) {\r\n                self.scrollPixelLeft = self.scrollCache.x[self.scrollIndexLeft];\r\n                self.scrollIndexLeft += 1;\r\n            }\r\n            if (s.length > 0) {\r\n                self.scrollIndexLeft = Math.max(self.scrollIndexLeft - 1, 0);\r\n                self.scrollPixelLeft -= self.getColummnWidth(self.orders.columns[self.scrollIndexLeft]);\r\n            }\r\n            if ((self.data || []).length > 0) {\r\n                self.scrollIndexTop = Math.max(self.scrollIndexTop - 1, 0);\r\n                self.scrollPixelTop = Math.max((self.scrollPixelTop\r\n                    - (\r\n                        self.data[self.scrollIndexTop] ? (self.sizes.rows[self.scrollIndexTop] || ch)\r\n                                + (self.sizes.trees[self.scrollIndexTop] || 0)\r\n                        : ch\r\n                    ) * self.scale), 0);\r\n            }\r\n            self.ellipsisCache = {};\r\n            if (!dontDraw) {\r\n                self.draw(true);\r\n            }\r\n            //TODO: figure out why this has to be delayed for child grids\r\n            //BUG: wheeling event on 3rd level hierarchy fails to move input box\r\n            requestAnimationFrame(self.resizeEditInput);\r\n            self.dispatchEvent('scroll', {top: self.scrollBox.scrollTop, left: self.scrollBox.scrollLeft});\r\n        };\r\n        self.mousemove = function (e, overridePos) {\r\n            if (self.contextMenu || self.input) {\r\n                return;\r\n            }\r\n            self.mouse = overridePos || self.getLayerPos(e);\r\n            var ctrl = (e.ctrlKey || e.metaKey || self.attributes.persistantSelectionMode),\r\n                i,\r\n                s = self.getSchema(),\r\n                dragBounds,\r\n                sBounds,\r\n                x = self.mouse.x,\r\n                y = self.mouse.y,\r\n                o = self.getCellAt(x, y),\r\n                delta,\r\n                ev = {NativeEvent: e, cell: o, x: x, y: y},\r\n                previousCell = self.currentCell;\r\n            clearTimeout(self.scrollTimer);\r\n            if (!self.isInGrid({x: x, y: y})) {\r\n                self.hasFocus = false;\r\n            }\r\n            if (self.dispatchEvent('mousemove', ev)) {\r\n                return;\r\n            }\r\n            if (o && self.currentCell) {\r\n                self.rowBoundaryCrossed = self.currentCell.rowIndex !== o.rowIndex;\r\n                self.columnBoundaryCrossed = self.currentCell.columnIndex !== o.columnIndex;\r\n                self.cellBoundaryCrossed = self.rowBoundaryCrossed || self.columnBoundaryCrossed;\r\n                ['row', 'column', 'cell'].forEach(function (prefix) {\r\n                    if (self[prefix + 'BoundaryCrossed']) {\r\n                        ev.cell = previousCell;\r\n                        self.dispatchEvent(prefix + 'mouseout', ev);\r\n                        ev.cell = o;\r\n                        self.dispatchEvent(prefix + 'mouseover', ev);\r\n                    }\r\n                });\r\n            }\r\n            self.currentCell = o;\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            self.hovers = {};\r\n            if (!self.draggingItem\r\n                    && o\r\n                    && self.scrollModes.indexOf(o.context) === -1) {\r\n                self.dragItem = o;\r\n                self.dragMode = o.dragContext;\r\n                self.cursor = o.context;\r\n                if (o.context === 'cell') {\r\n                    self.cursor = 'default';\r\n                    self.hovers = { rowIndex: o.rowIndex, columnIndex: o.columnIndex };\r\n                }\r\n                if ((self.selecting || self.reorderObject)\r\n                        && o.context === 'cell') {\r\n                    delta = {\r\n                        x: Math.abs(self.dragStart.x - x),\r\n                        y: Math.abs(self.dragStart.y - y)\r\n                    };\r\n                    if (self.dragStartObject.columnIndex !== -1 && e.shiftKey) {\r\n                        self.dragStartObject = {\r\n                            rowIndex: self.activeCell.rowIndex,\r\n                            columnIndex: self.activeCell.columnIndex\r\n                        };\r\n                    }\r\n                    dragBounds = {\r\n                        top: Math.min(self.dragStartObject.rowIndex, o.rowIndex),\r\n                        left: Math.min(self.dragStartObject.columnIndex, o.columnIndex),\r\n                        bottom: Math.max(self.dragStartObject.rowIndex, o.rowIndex),\r\n                        right: Math.max(self.dragStartObject.columnIndex, o.columnIndex)\r\n                    };\r\n                    if (self.dragStartObject.columnIndex === -1) {\r\n                        sBounds = self.getSelectionBounds();\r\n                        dragBounds.left = -1;\r\n                        dragBounds.right = s.length - 1;\r\n                        dragBounds.top = Math.min(sBounds.top, o.rowIndex);\r\n                        dragBounds.bottom = Math.max(sBounds.bottom, o.rowIndex);\r\n                    }\r\n                    if (self.dragStartObject.rowIndex !== o.rowIndex\r\n                                || self.dragStartObject.columnIndex !== o.columnIndex) {\r\n                        self.ignoreNextClick = true;\r\n                    }\r\n                    if (self.cellBoundaryCrossed || (delta.x === 0 && delta.y === 0) || (self.attributes.selectionMode === 'row')) {\r\n                        if (((self.attributes.selectionMode === 'row') || self.dragStartObject.columnIndex === -1)\r\n                                && self.rowBoundaryCrossed) {\r\n                            self.selectRow(o.rowIndex, ctrl, null, true);\r\n                        } else if (self.attributes.selectionMode !== 'row') {\r\n                            if (!self.dragAddToSelection && o.rowIndex !== undefined) {\r\n                                if (self.selections[o.rowIndex] && self.selections[o.rowIndex].indexOf(o.columnIndex) !== -1) {\r\n                                    self.selections[o.rowIndex].splice(self.selections[o.rowIndex].indexOf(o.columnIndex), 1);\r\n                                }\r\n                            } else {\r\n                                self.selections[o.rowIndex] = self.selections[o.rowIndex] || [];\r\n                                if (self.selections[o.rowIndex].indexOf(o.columnIndex) === -1) {\r\n                                    self.selections[o.rowIndex].push(o.columnIndex);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if ((!self.selectionBounds || (dragBounds.top !== self.selectionBounds.top\r\n                            || dragBounds.left !== self.selectionBounds.left\r\n                            || dragBounds.bottom !== self.selectionBounds.bottom\r\n                            || dragBounds.right !== self.selectionBounds.right)) && !ctrl) {\r\n                        self.selections = [];\r\n                        sBounds = dragBounds;\r\n                        if (self.attributes.selectionMode === 'row') {\r\n                            for (i = sBounds.top; i <= sBounds.bottom; i += 1) {\r\n                                self.selectRow(i, true, null, true);\r\n                            }\r\n                        } else if (dragBounds.top !== -1) {\r\n                            self.selectArea(sBounds, true);\r\n                        }\r\n                    }\r\n                    self.autoScrollZone(e, x, y, ctrl);\r\n                }\r\n            }\r\n            self.cellBoundaryCrossed = false;\r\n            self.rowBoundaryCrossed = false;\r\n            self.columnBoundaryCrossed = false;\r\n            self.draw(true);\r\n        };\r\n        self.click = function (e, overridePos) {\r\n            var i,\r\n                startingBounds = JSON.stringify(self.getSelectionBounds()),\r\n                ctrl = (e.ctrlKey || e.metaKey || self.attributes.persistantSelectionMode),\r\n                pos = overridePos || self.getLayerPos(e);\r\n            self.currentCell = self.getCellAt(pos.x, pos.y);\r\n            if (self.currentCell.grid !== undefined) {\r\n                return;\r\n            }\r\n            function checkSelectionChange() {\r\n                var ev, sb = self.getSelectionBounds();\r\n                if (startingBounds === JSON.stringify(sb)) {\r\n                    return;\r\n                }\r\n                ev = {\r\n                    selections: self.selections,\r\n                    selectionBounds: self.getSelectionBounds()\r\n                };\r\n                Object.defineProperty(ev, 'selectedData', {\r\n                    get: function () {\r\n                        return self.getSelectedData();\r\n                    }\r\n                });\r\n                self.dispatchEvent('selectionchanged', ev);\r\n            }\r\n            if (self.input) {\r\n                self.endEdit();\r\n            }\r\n            if (self.ignoreNextClick) {\r\n                self.ignoreNextClick = false;\r\n                return;\r\n            }\r\n            i = self.currentCell;\r\n            if (self.dispatchEvent('click', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            if (['rowHeaderCell', 'columnHeaderCell'].indexOf(self.currentCell.style) === -1 && !ctrl) {\r\n                self.setActiveCell(i.columnIndex, i.rowIndex);\r\n            }\r\n            if (self.currentCell.context === 'cell') {\r\n                if (self.currentCell.style === 'cornerCell') {\r\n                    self.selectAll();\r\n                    self.draw();\r\n                    checkSelectionChange();\r\n                    return;\r\n                }\r\n                if (self.currentCell.style === 'columnHeaderCell') {\r\n                    if (self.attributes.columnHeaderClickBehavior === 'sort') {\r\n                        if (self.orderBy === i.header.name) {\r\n                            self.orderDirection = self.orderDirection === 'asc' ? 'desc' : 'asc';\r\n                        } else {\r\n                            self.orderDirection = 'asc';\r\n                        }\r\n                        self.order(i.header.name, self.orderDirection);\r\n                        checkSelectionChange();\r\n                        return;\r\n                    }\r\n                    if (self.attributes.columnHeaderClickBehavior === 'select') {\r\n                        self.selectColumn(i.header.index, ctrl, e.shiftKey);\r\n                        self.draw();\r\n                        return;\r\n                    }\r\n                }\r\n                self.selections[i.rowIndex] = self.selections[i.rowIndex] || [];\r\n                if (((self.attributes.selectionMode === 'row') || self.currentCell.style === 'rowHeaderCell')) {\r\n                    if (self.currentCell.style === 'rowHeaderCell'\r\n                            && self.attributes.tree && pos.x > 0\r\n                            && pos.x - self.currentCell.x < self.style.treeArrowWidth\r\n                            + self.style.treeArrowMarginLeft\r\n                            + self.style.treeArrowMarginRight + self.style.treeArrowClickRadius\r\n                            && pos.y - self.currentCell.y < self.style.treeArrowHeight\r\n                            + self.style.treeArrowMarginTop + self.style.treeArrowClickRadius\r\n                            && pos.y > 0) {\r\n                        self.toggleTree(i.rowIndex);\r\n                        return;\r\n                    }\r\n                }\r\n                if (e.shiftKey && !ctrl) {\r\n                    self.selectionBounds = self.getSelectionBounds();\r\n                    self.selectArea(undefined, false);\r\n                }\r\n            }\r\n            checkSelectionChange();\r\n            self.draw(true);\r\n        };\r\n        self.dragResizeColumn = function (e) {\r\n            var pos, x, y;\r\n            pos = self.getLayerPos(e);\r\n            x = self.resizingStartingWidth + pos.x - self.dragStart.x;\r\n            y = self.resizingStartingHeight + pos.y - self.dragStart.y;\r\n            if (x < self.style.minColumnWidth) {\r\n                x = self.style.minColumnWidth;\r\n            }\r\n            if (y < self.style.minRowHeight) {\r\n                y = self.style.minRowHeight;\r\n            }\r\n            if (self.dispatchEvent('resizecolumn', {x: x, y: y, draggingItem: self.draggingItem})) { return false; }\r\n            if (self.scrollBox.scrollLeft > self.scrollBox.scrollWidth - self.attributes.resizeScrollZone\r\n                    && self.dragMode === 'ew-resize') {\r\n                self.resize(true);\r\n                self.scrollBox.scrollLeft += x;\r\n            }\r\n            if (self.dragMode === 'ew-resize') {\r\n                self.sizes.columns[self.draggingItem.header.style === 'rowHeaderCell'\r\n                       ? 'cornerCell' : self.draggingItem.sortColumnIndex] = x;\r\n                if (['rowHeaderCell', 'cornerCell'].indexOf(self.draggingItem.header.style) !== -1) {\r\n                    self.resize(true);\r\n                }\r\n                self.resizeChildGrids();\r\n                return;\r\n            }\r\n            if (self.dragMode === 'ns-resize') {\r\n                if (self.draggingItem.rowOpen) {\r\n                    self.sizes.trees[self.draggingItem.rowIndex] = y;\r\n                } else if (self.attributes.globalRowResize) {\r\n                    self.style.cellHeight = y;\r\n                } else {\r\n                    self.sizes.rows[self.draggingItem.rowIndex] = y;\r\n                }\r\n                self.dispatchEvent('resizerow', {row: y});\r\n                self.resizeChildGrids();\r\n                return;\r\n            }\r\n            self.ellipsisCache = {};\r\n        };\r\n        self.stopDragResize = function () {\r\n            self.resize();\r\n            document.body.removeEventListener('mousemove', self.dragResizeColumn, false);\r\n            document.body.removeEventListener('mouseup', self.stopDragResize, false);\r\n            self.setStorageData();\r\n            self.draw(true);\r\n            self.ignoreNextClick = true;\r\n        };\r\n        self.scrollGrid = function (e) {\r\n            var pos = self.getLayerPos(e);\r\n            if (self.attributes.scrollPointerLock && self.pointerLockPosition\r\n                    && ['horizontal-scroll-box', 'vertical-scroll-box'].indexOf(self.scrollStartMode) !== -1) {\r\n                self.pointerLockPosition.x += e.movementX;\r\n                self.pointerLockPosition.y += e.movementY;\r\n                self.pointerLockPosition.x = Math.min(self.width - self.style.scrollBarWidth, Math.max(0, self.pointerLockPosition.x));\r\n                self.pointerLockPosition.y = Math.min(self.height - self.style.scrollBarWidth, Math.max(0, self.pointerLockPosition.y));\r\n                pos = self.pointerLockPosition;\r\n            }\r\n            self.scrollMode = self.getCellAt(pos.x, pos.y).context;\r\n            if (self.scrollMode === 'horizontal-scroll-box' && self.scrollStartMode !== 'horizontal-scroll-box') {\r\n                self.scrollStartMode = 'horizontal-scroll-box';\r\n                self.dragStart = pos;\r\n                self.scrollStart.left = self.scrollBox.scrollLeft;\r\n                clearTimeout(self.scrollTimer);\r\n                return;\r\n            }\r\n            if (self.scrollMode === 'vertical-scroll-box' && self.scrollStartMode !== 'vertical-scroll-box') {\r\n                self.scrollStartMode = 'vertical-scroll-box';\r\n                self.dragStart = pos;\r\n                self.scrollStart.top = self.scrollBox.scrollTop;\r\n                clearTimeout(self.scrollTimer);\r\n                return;\r\n            }\r\n            if (self.scrollStartMode === 'vertical-scroll-box'\r\n                    && self.scrollMode !== 'vertical-scroll-box') {\r\n                self.scrollMode = 'vertical-scroll-box';\r\n            }\r\n            if (self.scrollStartMode === 'horizontal-scroll-box'\r\n                    && self.scrollMode !== 'horizontal-scroll-box') {\r\n                self.scrollMode = 'horizontal-scroll-box';\r\n            }\r\n            clearTimeout(self.scrollTimer);\r\n            if (self.scrollModes.indexOf(self.scrollMode) === -1) {\r\n                return;\r\n            }\r\n            if (self.scrollMode === 'vertical-scroll-box') {\r\n                self.scrollBox.scrollTop = self.scrollStart.top + ((pos.y - self.dragStart.y)\r\n                    / self.scrollBox.heightBoxRatio);\r\n            } else if (self.scrollMode === 'vertical-scroll-top') {\r\n                self.scrollBox.scrollTop -= (self.page * self.style.cellHeight);\r\n                self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n            } else if (self.scrollMode === 'vertical-scroll-bottom') {\r\n                self.scrollBox.scrollTop += (self.page * self.style.cellHeight);\r\n                self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n            }\r\n            if (self.scrollMode === 'horizontal-scroll-box') {\r\n                self.scrollBox.scrollLeft = self.scrollStart.left + ((pos.x - self.dragStart.x)\r\n                    / self.scrollBox.widthBoxRatio);\r\n            } else if (self.scrollMode === 'horizontal-scroll-right') {\r\n                self.scrollBox.scrollLeft += self.attributes.selectionScrollIncrement;\r\n                self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n            } else if (self.scrollMode === 'horizontal-scroll-left') {\r\n                self.scrollBox.scrollLeft -= self.attributes.selectionScrollIncrement;\r\n                self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n            }\r\n        };\r\n        self.stopScrollGrid = function () {\r\n            clearTimeout(self.scrollTimer);\r\n            if (document.exitPointerLock) {\r\n                document.exitPointerLock();\r\n            }\r\n            document.removeEventListener('mousemove', self.scrollGrid, false);\r\n        };\r\n        self.dragReorder = function (e) {\r\n            var pos, x, y,\r\n                columReorder = self.dragMode === 'column-reorder',\r\n                rowReorder = self.dragMode === 'row-reorder';\r\n            pos = self.getLayerPos(e);\r\n            x = pos.x - self.dragStart.x;\r\n            y = pos.y - self.dragStart.y;\r\n            if (!self.attributes.allowColumnReordering && columReorder) {\r\n                return;\r\n            }\r\n            if (!self.attributes.allowRowReordering && rowReorder) {\r\n                return;\r\n            }\r\n            if (self.dispatchEvent('reordering', {\r\n                    NativeEvent: e,\r\n                    source: self.dragStartObject,\r\n                    target: self.currentCell,\r\n                    dragMode: self.dragMode\r\n                })) {\r\n                return;\r\n            }\r\n            if (Math.abs(x) > self.attributes.reorderDeadZone || Math.abs(y) > self.attributes.reorderDeadZone) {\r\n                self.reorderObject = self.draggingItem;\r\n                self.reorderTarget = self.currentCell;\r\n                self.reorderObject.dragOffset = {\r\n                    x: x,\r\n                    y: y\r\n                };\r\n                self.autoScrollZone(e, columReorder ? pos.x : -1, rowReorder ? pos.y : -1, false);\r\n            }\r\n        };\r\n        self.stopDragReorder = function (e) {\r\n            var oIndex,\r\n                tIndex,\r\n                cr = {\r\n                    'row-reorder': self.orders.rows,\r\n                    'column-reorder': self.orders.columns\r\n                },\r\n                i = {\r\n                    'row-reorder': 'rowIndex',\r\n                    'column-reorder': 'sortColumnIndex'\r\n                }[self.dragMode];\r\n            document.body.removeEventListener('mousemove', self.dragReorder, false);\r\n            document.body.removeEventListener('mouseup', self.stopDragReorder, false);\r\n            if (self.reorderObject\r\n                    && self.reorderTarget\r\n                    && ((self.dragMode === 'column-reorder' && self.reorderTarget.sortColumnIndex > -1\r\n                        && self.reorderTarget.sortColumnIndex < self.getSchema().length)\r\n                    || (self.dragMode === 'row-reorder' && self.reorderTarget.rowIndex > -1\r\n                        && self.reorderTarget.rowIndex < self.data.length))\r\n                    && self.reorderObject[i] !== self.reorderTarget[i]\r\n                    && !self.dispatchEvent('reorder', {\r\n                        NativeEvent: e,\r\n                        source: self.reorderObject,\r\n                        target: self.reorderTarget,\r\n                        dragMode: self.dragMode\r\n                    })) {\r\n                self.ignoreNextClick = true;\r\n                oIndex = cr[self.dragMode].indexOf(self.reorderObject[i]);\r\n                tIndex = cr[self.dragMode].indexOf(self.reorderTarget[i]);\r\n                cr[self.dragMode].splice(oIndex, 1);\r\n                cr[self.dragMode].splice(tIndex, 0, self.reorderObject[i]);\r\n                if(self.dragMode === 'column-reorder') {\r\n                  self.orders.columns = cr[self.dragMode];\r\n                } else {\r\n                  self.orders.rows = cr[self.dragMode];\r\n                }\r\n                self.resize();\r\n                self.setStorageData();\r\n            }\r\n            self.reorderObject = undefined;\r\n            self.reorderTarget = undefined;\r\n            self.draw(true);\r\n        };\r\n        self.dragMove = function (e) {\r\n            if (self.dispatchEvent('moving', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            var pos = self.getLayerPos(e);\r\n            self.moveOffset = {\r\n                x: self.currentCell.columnIndex - self.dragStartObject.columnIndex,\r\n                y: self.currentCell.rowIndex - self.dragStartObject.rowIndex\r\n            };\r\n            if (Math.abs(pos.x) > self.attributes.reorderDeadZone || Math.abs(pos.y) > self.attributes.reorderDeadZone) {\r\n                setTimeout(function () {\r\n                    self.autoScrollZone(e, pos.x, pos.y, false);\r\n                }, 1);\r\n            }\r\n        };\r\n        self.stopDragMove = function (e) {\r\n            document.body.removeEventListener('mousemove', self.dragMove, false);\r\n            document.body.removeEventListener('mouseup', self.stopDragMove, false);\r\n            var b = self.getSelectionBounds();\r\n            if (self.dispatchEvent('endmove', {NativeEvent: e, cell: self.currentCell})) {\r\n                self.movingSelection = undefined;\r\n                self.moveOffset = undefined;\r\n                self.draw(true);\r\n                return;\r\n            }\r\n            if (self.moveOffset) {\r\n                self.moveTo(self.movingSelection, b.left + self.moveOffset.x, b.top + self.moveOffset.y);\r\n                self.moveSelection(self.moveOffset.x, self.moveOffset.y);\r\n            }\r\n            self.movingSelection = undefined;\r\n            self.moveOffset = undefined;\r\n            self.draw(true);\r\n        };\r\n        self.freezeMove = function (e) {\r\n            if (self.dispatchEvent('freezemoving', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            var pos = self.getLayerPos(e);\r\n            self.ignoreNextClick = true;\r\n            self.freezeMarkerPosition = pos;\r\n            if (self.currentCell && self.currentCell.rowIndex !== undefined && self.dragMode === 'frozen-row-marker') {\r\n                self.scrollBox.scrollTop = 0;\r\n                self.frozenRow = self.currentCell.rowIndex + 1;\r\n            }\r\n            if (self.currentCell && self.currentCell.columnIndex !== undefined && self.dragMode === 'frozen-column-marker') {\r\n                self.scrollBox.scrollLeft = 0;\r\n                self.frozenColumn = self.currentCell.columnIndex + 1;\r\n            }\r\n            if (Math.abs(pos.x) > self.attributes.reorderDeadZone || Math.abs(pos.y) > self.attributes.reorderDeadZone) {\r\n                setTimeout(function () {\r\n                    self.autoScrollZone(e, pos.x, pos.y, false);\r\n                }, 1);\r\n            }\r\n        };\r\n        self.stopFreezeMove = function (e) {\r\n            document.body.removeEventListener('mousemove', self.freezeMove, false);\r\n            document.body.removeEventListener('mouseup', self.stopFreezeMove, false);\r\n            self.freezeMarkerPosition = undefined;\r\n            if (self.dispatchEvent('endfreezemove', {NativeEvent: e, cell: self.currentCell})) {\r\n                self.frozenRow = self.startFreezeMove.x;\r\n                self.frozenColumn = self.startFreezeMove.y;\r\n                self.draw(true);\r\n                return;\r\n            }\r\n            self.draw(true);\r\n        };\r\n        self.mousedown = function (e, overridePos) {\r\n            self.lastMouseDownTarget = e.target;\r\n            if (self.dispatchEvent('mousedown', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            if (e.button === 2 || self.input) { return; }\r\n            var ctrl = (e.ctrlKey || e.metaKey),\r\n                move = /-move/.test(self.dragMode),\r\n                freeze = /frozen-row-marker|frozen-column-marker/.test(self.dragMode),\r\n                resize = /-resize/.test(self.dragMode);\r\n            self.dragStart = overridePos || self.getLayerPos(e);\r\n            self.scrollStart = {\r\n                left: self.scrollBox.scrollLeft,\r\n                top: self.scrollBox.scrollTop\r\n            };\r\n            self.dragStartObject = self.getCellAt(self.dragStart.x, self.dragStart.y);\r\n            self.dragAddToSelection = !self.dragStartObject.selected;\r\n            if (!ctrl && !e.shiftKey && !/(vertical|horizontal)-scroll-(bar|box)/\r\n                    .test(self.dragStartObject.context)\r\n                    && self.currentCell\r\n                    && !self.currentCell.isColumnHeader\r\n                    && !move\r\n                    && !freeze\r\n                    && !resize) {\r\n                self.selections = [];\r\n            }\r\n            if (self.dragStartObject.isGrid) {\r\n                return;\r\n            }\r\n            if (self.scrollModes.indexOf(self.dragStartObject.context) !== -1) {\r\n                self.scrollMode = self.dragStartObject.context;\r\n                self.scrollStartMode = self.dragStartObject.context;\r\n                self.scrollGrid(e);\r\n                if (self.attributes.scrollPointerLock\r\n                        && ['horizontal-scroll-box', 'vertical-scroll-box'].indexOf(self.scrollStartMode) !== -1) {\r\n                    self.pointerLockPosition = {\r\n                        x: self.dragStart.x,\r\n                        y: self.dragStart.y\r\n                    };\r\n                    self.canvas.requestPointerLock();\r\n                }\r\n                document.addEventListener('mousemove', self.scrollGrid, false);\r\n                document.addEventListener('mouseup', self.stopScrollGrid, false);\r\n                self.ignoreNextClick = true;\r\n                return;\r\n            }\r\n            if (self.dragMode === 'cell') {\r\n                self.selecting = true;\r\n                if ((self.attributes.selectionMode === 'row' || self.dragStartObject.columnIndex === -1)\r\n                        && self.dragStartObject.rowIndex > -1) {\r\n                    self.selectRow(self.dragStartObject.rowIndex, ctrl, null);\r\n                } else if (self.attributes.selectionMode !== 'row') {\r\n                    self.mousemove(e);\r\n                }\r\n                return;\r\n            }\r\n            if (move) {\r\n                self.draggingItem = self.dragItem;\r\n                self.movingSelection = self.selections.concat([]);\r\n                self.dragging = self.dragStartObject;\r\n                if (self.dispatchEvent('beginmove', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n                document.body.addEventListener('mousemove', self.dragMove, false);\r\n                document.body.addEventListener('mouseup', self.stopDragMove, false);\r\n                return self.mousemove(e);\r\n            }\r\n            if (freeze) {\r\n                self.draggingItem = self.dragItem;\r\n                self.startFreezeMove = {\r\n                    x: self.frozenRow,\r\n                    y: self.frozenColumn\r\n                };\r\n                if (self.dispatchEvent('beginfreezemove', {NativeEvent: e})) { return; }\r\n                document.body.addEventListener('mousemove', self.freezeMove, false);\r\n                document.body.addEventListener('mouseup', self.stopFreezeMove, false);\r\n                return self.mousemove(e);\r\n            }\r\n            if (resize) {\r\n                self.draggingItem = self.dragItem;\r\n                if (self.draggingItem.rowOpen) {\r\n                    self.resizingStartingHeight = self.sizes.trees[self.draggingItem.rowIndex];\r\n                } else {\r\n                    self.resizingStartingHeight = self.sizes.rows[self.draggingItem.rowIndex] || self.style.cellHeight;\r\n                }\r\n                self.resizingStartingWidth = self.sizes.columns[self.draggingItem.header.style === 'rowHeaderCell'\r\n                       ? 'cornerCell' : self.draggingItem.sortColumnIndex] || self.draggingItem.width;\r\n                document.body.addEventListener('mousemove', self.dragResizeColumn, false);\r\n                document.body.addEventListener('mouseup', self.stopDragResize, false);\r\n                return;\r\n            }\r\n            if (['row-reorder', 'column-reorder'].indexOf(self.dragMode) !== -1) {\r\n                self.draggingItem = self.dragStartObject;\r\n                document.body.addEventListener('mousemove', self.dragReorder, false);\r\n                document.body.addEventListener('mouseup', self.stopDragReorder, false);\r\n                return;\r\n            }\r\n        };\r\n        self.mouseup = function (e) {\r\n            clearTimeout(self.scrollTimer);\r\n            self.cellBoundaryCrossed = true;\r\n            self.rowBoundaryCrossed = true;\r\n            self.columnBoundaryCrossed = true;\r\n            self.selecting = undefined;\r\n            self.draggingItem = undefined;\r\n            self.dragStartObject = undefined;\r\n            if (self.dispatchEvent('mouseup', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus && e.target !== self.canvas) {\r\n                return;\r\n            }\r\n            if (self.currentCell && self.currentCell.grid !== undefined) {\r\n                return;\r\n            }\r\n            if (self.contextMenu || self.input) { return; }\r\n            if (self.dragStart && self.isInGrid(self.dragStart)) {\r\n                self.controlInput.focus();\r\n            }\r\n            e.preventDefault();\r\n        };\r\n        // gets the horizontal adjacent cells as well as first/last based on column visibility\r\n        self.getAdjacentCells = function () {\r\n            var x,\r\n                i,\r\n                s = self.getSchema(),\r\n                o = {};\r\n            for (x = 0; x < s.length; x += 1) {\r\n                i = self.orders.columns[x];\r\n                if (!s[i].hidden) {\r\n                    if (o.first === undefined) {\r\n                        o.first = x;\r\n                        o.left = x;\r\n                    }\r\n                    o.last = x;\r\n                    if (x > self.activeCell.columnIndex && o.right === undefined) {\r\n                        o.right = x;\r\n                    }\r\n                    if (x < self.activeCell.columnIndex) {\r\n                        o.left = x;\r\n                    }\r\n                }\r\n            }\r\n            if (o.right === undefined) {\r\n                o.right = o.last;\r\n            }\r\n            return o;\r\n        };\r\n        self.keydown = function (e) {\r\n            var i,\r\n                ev,\r\n                adjacentCells = self.getAdjacentCells(),\r\n                x = self.activeCell.columnIndex,\r\n                y = self.activeCell.rowIndex,\r\n                ctrl = (e.ctrlKey || e.metaKey),\r\n                last = self.data.length - 1,\r\n                s = self.getSchema(),\r\n                cols = s.length - 1;\r\n            if (self.dispatchEvent('keydown', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            if (self.attributes.showNewRow) {\r\n                last += 1;\r\n            }\r\n            if (e.keyCode === 9) {\r\n                e.preventDefault();\r\n            }\r\n            // esc\r\n            if (e.keyCode === 27) {\r\n                self.selections = [];\r\n                self.draw(true);\r\n            // ctrl + a\r\n            } else if (ctrl && e.keyCode === 65) {\r\n                self.selectAll();\r\n            //ArrowDown\r\n            } else if (e.keyCode === 40) {\r\n                y += 1;\r\n            //ArrowUp\r\n            } else if (e.keyCode === 38) {\r\n                y -= 1;\r\n            //ArrowLeft Tab\r\n            } else if (e.keyCode === 37 || (e.shiftKey && e.keyCode === 9)) {\r\n                x = adjacentCells.left;\r\n            //ArrowRight Tab\r\n            } else if (e.keyCode === 39 || (!e.shiftKey && e.keyCode === 9)) {\r\n                x = adjacentCells.right;\r\n            //PageUp\r\n            } else if (e.keyCode === 33) {\r\n                y -= self.page;\r\n                e.preventDefault();\r\n            //PageDown\r\n            } else if (e.keyCode === 34) {\r\n                y += self.page;\r\n                e.preventDefault();\r\n            //Home ArrowUp\r\n            } else if (e.keyCode === 36 || (ctrl && e.keyCode === 38)) {\r\n                y = 0;\r\n            //End ArrowDown\r\n            } else if (e.keyCode === 35 || (ctrl && e.keyCode === 40)) {\r\n                y = self.data.length - 1;\r\n            //ArrowRight\r\n            } else if (ctrl && e.keyCode === 39) {\r\n                x = adjacentCells.last;\r\n            //ArrowLeft\r\n            } else if (ctrl && e.keyCode === 37) {\r\n                x = adjacentCells.first;\r\n            }\r\n            //Enter\r\n            if (e.keyCode === 13) {\r\n                return self.beginEditAt(x, y, e);\r\n            }\r\n            //Space\r\n            if (e.keyCode === 32) {\r\n                self.selections = [];\r\n                self.selections[Math.max(y, 0)] = [];\r\n                self.selections[Math.max(y, 0)].push(x);\r\n                self.selectionBounds = self.getSelectionBounds();\r\n                if (self.attributes.selectionMode === 'row') {\r\n                    for (i = self.selectionBounds.top; i <= self.selectionBounds.bottom; i += 1) {\r\n                        self.selectRow(i, ctrl, null, true);\r\n                    }\r\n                } else {\r\n                    self.selectArea(undefined, ctrl);\r\n                }\r\n                e.preventDefault();\r\n                self.draw(true);\r\n                return;\r\n            }\r\n            if (x < 0 || Number.isNaN(x)) {\r\n                x = adjacentCells.first;\r\n            }\r\n            if (y > last) {\r\n                y = last;\r\n            }\r\n            if (y < 0 || Number.isNaN(y)) {\r\n                y = 0;\r\n            }\r\n            if (x > cols) {\r\n                x = adjacentCells.last;\r\n            }\r\n            // TODO - most likley some column order related bugs in key based selection\r\n            // Arrows\r\n            if (e.shiftKey && [37, 38, 39, 40].indexOf(e.keyCode) !== -1) {\r\n                self.selections[Math.max(y, 0)] = self.selections[Math.max(y, 0)] || [];\r\n                self.selections[Math.max(y, 0)].push(x);\r\n                self.selectionBounds = self.getSelectionBounds();\r\n                self.selectArea(undefined, ctrl);\r\n                self.draw(true);\r\n            }\r\n            if (x !== self.activeCell.columnIndex || y !== self.activeCell.rowIndex) {\r\n                self.scrollIntoView(\r\n                  x !== self.activeCell.columnIndex ? x : undefined,\r\n                  y !== self.activeCell.rowIndex && !Number.isNaN(y) ? y : undefined\r\n                );\r\n\r\n                self.setActiveCell(x, y);\r\n                if (!e.shiftKey && self.attributes.selectionFollowsActiveCell) {\r\n                    if (!ctrl) {\r\n                        self.selections = [];\r\n                    }\r\n                    self.selections[y] = self.selections[y] || [];\r\n                    self.selections[y].push(x);\r\n                    ev = {\r\n                        selectedData: self.getSelectedData(),\r\n                        selections: self.selections,\r\n                        selectionBounds: self.getSelectionBounds()\r\n                    };\r\n                    Object.defineProperty(ev, 'selectedData', {\r\n                        get: function () {\r\n                            return self.getSelectedData();\r\n                        }\r\n                    });\r\n                    self.dispatchEvent('selectionchanged', ev);\r\n                }\r\n                self.draw(true);\r\n            }\r\n        };\r\n        self.keyup = function (e) {\r\n            if (self.dispatchEvent('keyup', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n        };\r\n        self.keypress = function (e) {\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            if (self.dispatchEvent('keypress', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n        };\r\n        self.dblclick = function (e) {\r\n            if (self.dispatchEvent('dblclick', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            if (!self.hasFocus) {\r\n                return;\r\n            }\r\n            if (self.currentCell.context === 'ew-resize'\r\n                    && self.currentCell.style === 'columnHeaderCell') {\r\n                self.fitColumnToValues(self.currentCell.header.name);\r\n            } else if (self.currentCell.context === 'ew-resize'\r\n                    && self.currentCell.style === 'cornerCell') {\r\n                self.autosize();\r\n            } else if (['cell', 'activeCell'].indexOf(self.currentCell.style) !== -1) {\r\n                self.beginEditAt(self.currentCell.columnIndex, self.currentCell.rowIndex);\r\n            }\r\n        };\r\n        self.scrollWheel = function (e) {\r\n            var l,\r\n                t,\r\n                ev = e,\r\n                deltaX = e.deltaX === undefined ? e.NativeEvent.deltaX : e.deltaX,\r\n                deltaY = e.deltaY === undefined ? e.NativeEvent.deltaY : e.deltaY,\r\n                deltaMode = e.deltaMode === undefined ? e.NativeEvent.deltaMode : e.deltaMode;\r\n            if (wheeling) {\r\n                return;\r\n            }\r\n            if (self.dispatchEvent('wheel', {NativeEvent: e})) {\r\n                return;\r\n            }\r\n            var e = e.NativeEvent || e;\r\n            self.touchHaltAnimation = true;\r\n            l = self.scrollBox.scrollLeft;\r\n            t = self.scrollBox.scrollTop;\r\n            if (self.hasFocus) {\r\n                //BUG Issue 42: https://github.com/TonyGermaneri/canvas-datagrid/issues/42\r\n                //https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n                if (deltaMode === 1) {\r\n                    // line mode = 17 pixels per line\r\n                    deltaY = deltaY * 17;\r\n                }\r\n                if ((self.scrollBox.scrollTop  < self.scrollBox.scrollHeight && deltaY > 0)\r\n                        || (self.scrollBox.scrollLeft < self.scrollBox.scrollWidth && deltaX > 0)\r\n                        || (self.scrollBox.scrollTop > 0 && deltaY < 0)\r\n                        || (self.scrollBox.scrollLeft > 0 && deltaX < 0)) {\r\n                    ev.preventDefault(e);\r\n                }\r\n                wheeling = setTimeout(function () {\r\n                    wheeling = undefined;\r\n                    self.scrollBox.scrollTo(deltaX + l, deltaY + t);\r\n                }, 1);\r\n            }\r\n        };\r\n        self.pasteItem = function (clipData, x, y, mimeType) {\r\n            var l, s = self.getVisibleSchema(), yi = y - 1, sel = [];\r\n            function normalizeRowData(importingRow, existingRow, offsetX, schema, mimeType, rowIndex) {\r\n                var r = existingRow;\r\n                if (!Array.isArray(importingRow) && importingRow !== null && typeof importingRow === 'object') {\r\n                    importingRow = Object.keys(importingRow).map(function (colKey) {\r\n                        return importingRow[colKey];\r\n                    });\r\n                }\r\n                if (/^text\\/html/.test(mimeType)) {\r\n                    importingRow = importingRow.substring(4, importingRow.length - 5).split('</td><td>');\r\n                }\r\n                if (typeof importingRow === 'string') {\r\n                    importingRow = [importingRow];\r\n                }\r\n                sel[rowIndex] = [];\r\n                importingRow.forEach(function (cellData, colIndex) {\r\n                    var cName = schema[colIndex + offsetX].name;\r\n                    if (importingRow[colIndex] === undefined || importingRow[colIndex] === null) {\r\n                        r[cName] = existingRow[cName];\r\n                        return;\r\n                    }\r\n                    sel[rowIndex].push(colIndex + offsetX);\r\n                    r[cName] = importingRow[colIndex];\r\n                });\r\n                return r;\r\n            }\r\n            if (/^text\\/html/.test(mimeType)) {\r\n                if (!/^(<meta[^>]+>)?<table>/.test(clipData.substring(0, 29))) {\r\n                    console.warn('Unrecognized HTML format.  HTML must be a simple table, e.g.: <table><tr><td>data</td></tr></table>.  Data with the mime type text/html not in this format will not be imported as row data.');\r\n                    return;\r\n                }\r\n                // strip table beginning and ending off, then split at rows\r\n                clipData = clipData.substring(clipData.indexOf('<table><tr>') + 11, clipData.length - 13).split('</tr><tr>');\r\n                // ditch any headers on the table\r\n                clipData = clipData.filter(function (row) {\r\n                    return !/^<th>|^<thead>/.test(row);\r\n                });\r\n            } else {\r\n                clipData = clipData.split('\\n');\r\n            }\r\n            l = clipData.length;\r\n            clipData.forEach(function (rowData) {\r\n                yi += 1;\r\n                var i = self.orders.rows[yi];\r\n                self.data[i] = normalizeRowData(rowData, self.data[i], x, s, mimeType, i);\r\n            });\r\n            self.selections = sel;\r\n            return l;\r\n        };\r\n        self.getNextVisibleColumnIndex = function (visibleColumnIndex) {\r\n            var x, s = self.getVisibleSchema();\r\n            for (x = 0; x < s.length; x += 1) {\r\n                if (s[x].columnIndex === visibleColumnIndex) {\r\n                    return s[x + 1].columnIndex;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n        self.getVisibleColumnIndexOf = function (columnIndex) {\r\n            var x, s = self.getVisibleSchema();\r\n            for (x = 0; x < s.length; x += 1) {\r\n                if (s[x].columnIndex === columnIndex) {\r\n                    return x;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n        self.paste = function (e) {\r\n            var d;\r\n            function getItem(dti) {\r\n                var type = dti.type;\r\n                dti.getAsString(function (s) {\r\n                    self.pasteItem(s, self.getVisibleColumnIndexOf(self.activeCell.columnIndex), self.activeCell.rowIndex, type);\r\n                    self.draw();\r\n                });\r\n            }\r\n            d = Array.prototype.filter.call(e.clipboardData.items, function (dti) {\r\n                return dti.type === 'text/html';\r\n            })[0] || Array.prototype.filter(function (dti) {\r\n                return dti.type === 'text/csv';\r\n            })[0] || Array.prototype.filter(function (dti) {\r\n                return dti.type === 'text/plain';\r\n            })[0];\r\n            if (!d) {\r\n                console.warn('Cannot find supported clipboard data type.  Supported types are text/html, text/csv, text/plain.');\r\n                return;\r\n            }\r\n            getItem(d);\r\n        };\r\n        self.cut = function (e) {\r\n            self.copy(e);\r\n            self.forEachSelectedCell(function (data, index, colName) {\r\n                data[index][colName] = '';\r\n            });\r\n        };\r\n        self.copy = function (e) {\r\n            if (self.dispatchEvent('copy', {NativeEvent: e})) { return; }\r\n            if (!self.hasFocus || !e.clipboardData) { return; }\r\n            var t,\r\n                d,\r\n                data = (self.data || []),\r\n                tableRows = [],\r\n                textRows = [],\r\n                outputHeaders = {},\r\n                outputHeaderKeys,\r\n                sData = self.getSelectedData(),\r\n                s = self.getSchema();\r\n            function htmlSafe(v) {\r\n                return v.replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n            }\r\n            function fCopyCell(v) {\r\n                v = v === null || v === undefined ? '' : v;\r\n                return '<td>' + (typeof v === 'string' ? htmlSafe(v) : v) + '</td>';\r\n            }\r\n            function addHeaders(headers, useHtml) {\r\n                if (!s.length || headers.length < 2) { return ''; }\r\n                var h = [];\r\n                if (useHtml) {\r\n                    h.push('<tr>');\r\n                }\r\n                s.forEach(function (column, columnIndex) {\r\n                    // intentional redefinition of column\r\n                    column = s[self.orders.columns[columnIndex]];\r\n                    if (!column.hidden && headers.indexOf(column.name) !== -1) {\r\n                        var ev = {NativeEvent: e, column: column};\r\n                        if(self.dispatchEvent('copyonschema', ev)) {\r\n                            column = ev.column;\r\n                        }\r\n\r\n                        var hVal = (column.name || column.title) || '';\r\n                        if (useHtml) {\r\n                            h.push('<th>' + htmlSafe(hVal) + '</th>');\r\n                        } else {\r\n                            h.push('\"' + hVal.replace(/\"/g, '\"\"') + '\"');\r\n                        }\r\n                    }\r\n                });\r\n                h.push(useHtml ? '</tr>' : '\\n');\r\n                return h.join(useHtml ? '' : ',');\r\n            }\r\n            function addCellValue(val, trRow, textRow, column) {\r\n                // escape strings\r\n                if (val !== null\r\n                        && val !== false\r\n                        && val !== undefined\r\n                        && val.replace) {\r\n                    trRow.push(fCopyCell(val));\r\n                    textRow.push('\"' + val.replace(/\"/g, '\"\"') + '\"');\r\n                    return;\r\n                }\r\n                if (val !== undefined) {\r\n                    textRow.push(val);\r\n                    trRow.push(fCopyCell(val));\r\n                    return;\r\n                }\r\n                // issue #66\r\n                textRow.push('');\r\n                trRow.push('<td>&nbsp;</td>');\r\n            }\r\n            if (sData.length > 0) {\r\n                sData.forEach(function (row) {\r\n                    var rowKeys = Object.keys(row);\r\n                    if (row) {\r\n                        var trRow = [],\r\n                            textRow = [],\r\n                            sSorted = [];\r\n                        // HACK: https://github.com/TonyGermaneri/canvas-datagrid/issues/181\r\n                        // I can't use sort here or O(1), so hacks\r\n                        s.forEach(function (column, columnIndex) {\r\n                            sSorted.push(s[self.orders.columns[columnIndex]]);\r\n                        });\r\n                        sSorted.forEach(function (column, columnIndex) {\r\n                            if (rowKeys.indexOf(column.name) !== -1) {\r\n                                outputHeaders[column.name] = true;\r\n                                // escape strings\r\n                                addCellValue(row[column.name], trRow, textRow, column);\r\n                            }\r\n                        });\r\n                        tableRows.push(trRow.join(''));\r\n                        textRows.push(textRow.join(','));\r\n                    }\r\n                });\r\n                outputHeaderKeys = Object.keys(outputHeaders);\r\n                t = addHeaders(outputHeaderKeys) + textRows.join('\\n');\r\n                d = '<table>' + addHeaders(outputHeaderKeys, true) + '<tr>' + tableRows.join('</tr><tr>') + '</tr></table>';\r\n                if (outputHeaderKeys.length === 1) {\r\n                    // if there was only one cell selected, remove the quotes from the string\r\n                    t = t.substring(1, t.length -1);\r\n                }\r\n                e.clipboardData.setData('text/html', d);\r\n                e.clipboardData.setData('text/plain', t);\r\n                e.clipboardData.setData('text/csv', t);\r\n                e.clipboardData.setData('application/json', JSON.stringify(sData));\r\n                e.preventDefault();\r\n            }\r\n        };\r\n        return;\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/events.js\n// module id = 4\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true, plusplus: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        var touchTimerMs = 50,\r\n            debounceTouchMove,\r\n            touchMoving,\r\n            touchScrollTimeout;\r\n        self.scrollAnimation = {};\r\n        self.touchDelta = {};\r\n        self.touchAnimateTo = {};\r\n        self.animationFrames = 0;\r\n        self.getTouchPos = function (e, touchIndex) {\r\n            var t = touchIndex ? e.touches[touchIndex] : e.touches[0],\r\n                rect = self.canvas.getBoundingClientRect(),\r\n                pos;\r\n            if (!t) { return; }\r\n            pos = {\r\n                x: t.clientX - rect.left,\r\n                y: t.clientY - rect.top\r\n            };\r\n            if (self.isChildGrid) {\r\n                pos.x -= self.canvasOffsetLeft;\r\n                pos.y -= self.canvasOffsetTop;\r\n            }\r\n            return {\r\n                x: pos.x,\r\n                y: pos.y,\r\n                rect: rect\r\n            };\r\n        };\r\n        // shamelessly stolen from from https://gist.github.com/gre/1650294\r\n        self.easingFunctions = {\r\n            linear: function (t) { return t; },\r\n            easeInQuad: function (t) { return t * t; },\r\n            easeOutQuad: function (t) { return t * (2 - t); },\r\n            easeInOutQuad: function (t) { return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; },\r\n            easeInCubic: function (t) { return t * t * t; },\r\n            easeOutCubic: function (t) { return (--t) * t * t + 1; },\r\n            easeInOutCubic: function (t) { return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; },\r\n            easeInQuart: function (t) { return t * t * t * t; },\r\n            easeOutQuart: function (t) { return 1 - (--t) * t * t * t; },\r\n            easeInOutQuart: function (t) { return t < 0.5 ? 8 * t  * t  * t * t : 1 - 8 * (--t) * t * t * t; },\r\n            easeInQuint: function (t) { return t * t * t * t * t; },\r\n            easeOutQuint: function (t) { return 1 + (--t) * t *  t * t * t; },\r\n            easeInOutQuint: function (t) { return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t; }\r\n        };\r\n        self.easing = function (t, b, c, d) {\r\n            return c * self.easingFunctions[self.attributes.touchEasingMethod](t / d) + b;\r\n        };\r\n        self.calculatePPSTimed = function () {\r\n            self.xPPST = -((self.touchDelta.x - self.touchSigmaTimed.x) / (self.touchDelta.t - self.touchSigmaTimed.t));\r\n            self.yPPST = -((self.touchDelta.y - self.touchSigmaTimed.y) / (self.touchDelta.t - self.touchSigmaTimed.t));\r\n            self.touchSigmaTimed = {\r\n                x: self.touchDelta.x,\r\n                y: self.touchDelta.y,\r\n                t: performance.now()\r\n            };\r\n        };\r\n        self.calculatePPS = function () {\r\n            self.xPPS = -((self.touchDelta.x - self.touchSigma.x) / (self.touchDelta.t - self.touchSigma.t));\r\n            self.yPPS = -((self.touchDelta.y - self.touchSigma.y) / (self.touchDelta.t - self.touchSigma.t));\r\n            self.touchSigma = {\r\n                x: self.touchDelta.x,\r\n                y: self.touchDelta.y,\r\n                t: performance.now()\r\n            };\r\n        };\r\n        self.touchEndAnimation = function () {\r\n            if (!self.canvas || !self.scrollBox.scrollTo) { return requestAnimationFrame(self.touchEndAnimation); }\r\n            var n = performance.now(),\r\n                d = self.attributes.touchReleaseAnimationDurationMs,\r\n                t;\r\n            t = n - self.touchDelta.t;\r\n            self.animationFrames += 1;\r\n            self.scrollAnimation.x = self.easing(t, self.touchDelta.scrollLeft, self.touchAnimateTo.x, d);\r\n            self.scrollAnimation.y = self.easing(t, self.touchDelta.scrollTop, self.touchAnimateTo.y, d);\r\n            if (t > d || (self.scrollAnimation.y === self.scrollBox.scrollTop\r\n                    && self.scrollAnimation.x === self.scrollBox.scrollLeft) || self.stopAnimation) {\r\n                return;\r\n            }\r\n            self.scrollBox.scrollTo(self.scrollAnimation.x, self.scrollAnimation.y);\r\n            requestAnimationFrame(self.touchEndAnimation);\r\n        };\r\n        self.touchEditCell = function (cell) {\r\n            self.beginEditAt(cell.columnIndex, cell.rowIndex);\r\n        };\r\n        self.touchCell = function (e) {\r\n            return function () {\r\n                clearInterval(self.calculatePPSTimer);\r\n                var i, pos = self.getTouchPos(e);\r\n                if (Math.abs(self.touchDelta.x) + Math.abs(self.touchDelta.y) < self.attributes.touchDeadZone) {\r\n                    i = self.getCellAt(pos.x, pos.y);\r\n                    if (!i) { return; }\r\n                    if (self.touchingCell && self.touchingCell.rowIndex === i.rowIndex\r\n                            && self.touchingCell.columnIndex === i.columnIndex) {\r\n                        self.touchEditCell(i);\r\n                        return;\r\n                    }\r\n                    if (self.input && self.input.editCell) {\r\n                        self.endEdit();\r\n                    }\r\n                    self.touchingCell = i;\r\n                    self.selectArea({\r\n                        top: i.rowIndex,\r\n                        bottom: i.rowIndex,\r\n                        left: i.columnIndex,\r\n                        right: i.columnIndex\r\n                    });\r\n                    self.draw(true);\r\n                }\r\n            };\r\n        };\r\n        self.touchstart = function (e) {\r\n            if (e.changedTouches[0]) {\r\n                self.touchStart = self.getTouchPos(e);\r\n                self.startingCell = self.getCellAt(self.touchStart.x, self.touchStart.y, true);\r\n            }\r\n            if (self.dispatchEvent('touchstart', {NativeEvent: e, cell: self.startingCell})) { return; }\r\n            self.disposeContextMenu();\r\n            clearInterval(self.calculatePPSTimer);\r\n            clearTimeout(self.touchContextTimeout);\r\n            self.touchStartEvent = e;\r\n            self.stopAnimation = true;\r\n            self.animationFrames = 0;\r\n            self.stopPropagation(e);\r\n            e.preventDefault();\r\n            if (e.touches.length === 1 && e.changedTouches[0] && !self.zoomAltered) {\r\n                self.touchLength = 1;\r\n                self.touchStart = self.touchStart || self.touchStart1;\r\n                self.touchScrollStart = {\r\n                    x: self.scrollBox.scrollLeft,\r\n                    y: self.scrollBox.scrollTop,\r\n                    t: performance.now()\r\n                };\r\n                self.touchDelta = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    scrollLeft: self.scrollBox.scrollLeft,\r\n                    scrollTop: self.scrollBox.scrollTop,\r\n                    t: self.touchScrollStart.t\r\n                };\r\n                self.touchSigma = {\r\n                    x: self.touchDelta.x,\r\n                    y: self.touchDelta.y,\r\n                    t: self.touchDelta.t\r\n                };\r\n                self.touchSigmaTimed = {\r\n                    x: self.touchDelta.x,\r\n                    y: self.touchDelta.y,\r\n                    t: self.touchDelta.t\r\n                };\r\n                self.touchContextTimeout = setTimeout(function () {\r\n                    self.contextmenuEvent(e, self.touchStart);\r\n                }, self.attributes.touchContextMenuTimeMs);\r\n                self.calculatePPSTimer = setInterval(self.calculatePPSTimed, touchTimerMs);\r\n                if (self.startingCell && (self.startingCell.isGrid || ['tree', 'inherit'].indexOf(self.startingCell.context) !== -1)) {\r\n                    self.hasFocus = false;\r\n                    return;\r\n                }\r\n                self.hasFocus = true;\r\n                if (self.startingCell.isHeader) {\r\n                    if (self.startingCell.isRowHeader) {\r\n                        self.selectArea({\r\n                            top: self.startingCell.rowIndex,\r\n                            bottom: self.startingCell.rowIndex,\r\n                            left: 0,\r\n                            right: self.getVisibleSchema().length - 1,\r\n                        });\r\n                        self.draw(true);\r\n                    } else if (self.startingCell.isColumnHeader) {\r\n                        if (self.attributes.columnHeaderClickBehavior === 'sort') {\r\n                            if (self.orderBy === self.startingCell.header.name) {\r\n                                self.orderDirection = self.orderDirection === 'asc' ? 'desc' : 'asc';\r\n                            } else {\r\n                                self.orderDirection = 'asc';\r\n                            }\r\n                            self.order(self.startingCell.header.name, self.orderDirection);\r\n                        }\r\n                        if (self.attributes.columnHeaderClickBehavior === 'select') {\r\n                            self.selectArea({\r\n                                top: 0,\r\n                                bottom: self.data.length - 1,\r\n                                left: self.startingCell.columnIndex,\r\n                                right: self.startingCell.columnIndex,\r\n                            });\r\n                            self.draw(true);\r\n                        }\r\n                    }\r\n                    self.touchEndEvents(e);\r\n                    return;\r\n                }\r\n            }\r\n            if (self.zoomAltered) { return; }\r\n            document.body.addEventListener('touchmove', self.touchmove, {passive: false});\r\n            document.body.addEventListener('touchend', self.touchend, false);\r\n            document.body.addEventListener('touchcancel', self.touchcancel, false);\r\n            self.draw(true);\r\n        };\r\n        self.touchSelect = function (cell, handleType) {\r\n            if (cell.rowIndex === undefined || cell.columnIndex === undefined) { return; }\r\n            self.touchSelecting = true;\r\n            var bounds = self.getSelectionBounds();\r\n            if (handleType === 'selection-handle-bl'\r\n                    && cell.rowIndex >= bounds.top\r\n                    && cell.columnIndex <= bounds.right) {\r\n                bounds.bottom = cell.rowIndex;\r\n                bounds.left = cell.columnIndex;\r\n            } else if (handleType === 'selection-handle-tl'\r\n                    && cell.rowIndex <= bounds.bottom\r\n                    && cell.columnIndex <= bounds.right) {\r\n                bounds.top = cell.rowIndex;\r\n                bounds.left = cell.columnIndex;\r\n            } else if (handleType === 'selection-handle-tr'\r\n                    && cell.rowIndex <= bounds.bottom\r\n                    && cell.columnIndex >= bounds.left) {\r\n                bounds.top = cell.rowIndex;\r\n                bounds.right = cell.columnIndex;\r\n            } else if (handleType === 'selection-handle-br'\r\n                    && cell.rowIndex >= bounds.top\r\n                    && cell.columnIndex >= bounds.left) {\r\n                bounds.bottom = cell.rowIndex;\r\n                bounds.right = cell.columnIndex;\r\n            }\r\n            if (self.attributes.selectionMode === 'row' || cell.rowIndex === -1) {\r\n                bounds.left = 0;\r\n                bounds.right = self.getSchema().length - 1;\r\n            } else {\r\n                bounds.left = Math.max(0, bounds.left);\r\n            }\r\n            self.selectArea(bounds);\r\n            self.draw(true);\r\n        };\r\n        function touchMove(e) {\r\n            var ch, rw, rScrollZone, lScrollZone, bScrollZone, tScrollZone, sbw, t1, t2;\r\n            if (self.dispatchEvent('beforetouchmove', {NativeEvent: e})) { return; }\r\n            clearTimeout(touchScrollTimeout);\r\n            if (e.changedTouches[0]) {\r\n                self.touchPosition = self.getTouchPos(e);\r\n            }\r\n            if (e.changedTouches[1]) {\r\n                self.touchPosition1 = self.getTouchPos(e, 1);\r\n            }\r\n            if (Math.abs(self.touchDelta.x) + Math.abs(self.touchDelta.y) > self.attributes.touchDeadZone) {\r\n                clearTimeout(self.touchContextTimeout);\r\n            }\r\n            if (e.touches.length === 2 && self.touchPosition && self.touchPosition1) {\r\n                t1 = self.touchPosition.y;\r\n                t2 = self.touchPosition1.y;\r\n                if (!self.zoomDeltaStart) {\r\n                    self.zoomDeltaStart = Math.abs(t1 - t2);\r\n                    self.startScale = self.scale;\r\n                }\r\n                self.touchLength = 2;\r\n                self.scaleDelta = self.zoomDeltaStart - Math.abs(t1 - t2);\r\n                self.scale = self.startScale - (self.scaleDelta * self.attributes.touchZoomSensitivity);\r\n                self.scale = Math.min(Math.max(self.scale, self.attributes.touchZoomMin), self.attributes.touchZoomMax);\r\n                self.zoomAltered = true;\r\n                self.resize(true);\r\n                self.resizeChildGrids();\r\n                return;\r\n            }\r\n            if (self.zoomAltered) { return; }\r\n            self.touchLength = 1;\r\n            self.touchPosition = self.touchPosition || self.touchPosition1;\r\n            ch = self.getColumnHeaderCellHeight();\r\n            rw = self.getRowHeaderCellWidth();\r\n            rScrollZone = self.width - self.style.scrollBarWidth - self.touchPosition.x < self.attributes.selectionScrollZone;\r\n            lScrollZone = self.touchPosition.x - rw < self.attributes.selectionScrollZone;\r\n            bScrollZone = self.height - self.style.scrollBarWidth - self.touchPosition.y < self.attributes.selectionScrollZone;\r\n            tScrollZone = self.touchPosition.y - ch < self.attributes.selectionScrollZone;\r\n            sbw = self.style.scrollBarWidth;\r\n            function touchScroll() {\r\n                var x = self.scrollBox.scrollLeft,\r\n                    y = self.scrollBox.scrollTop;\r\n                x += (rScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                y += (bScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                y -= (tScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                x -= (lScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                self.scrollBox.scrollTo(x, y);\r\n                touchScrollTimeout = setTimeout(touchScroll, self.attributes.scrollRepeatRate);\r\n            }\r\n            e.stopPropagation();\r\n            self.touchDelta = {\r\n                x: self.touchPosition.x - self.touchStart.x,\r\n                y: self.touchPosition.y - self.touchStart.y,\r\n                scrollLeft: self.scrollBox.scrollLeft,\r\n                scrollTop: self.scrollBox.scrollTop,\r\n                t: performance.now()\r\n            };\r\n            self.currentCell = self.getCellAt(self.touchPosition.x, self.touchPosition.y);\r\n            self.dispatchEvent('touchmove', {NativeEvent: e, cell: self.currentCell});\r\n            self.calculatePPS();\r\n            self.touchDuration = performance.now() - self.touchScrollStart.t;\r\n            self.stopAnimation = true;\r\n            self.animationFrames = 0;\r\n            if (self.touchSelecting && (rScrollZone || lScrollZone || tScrollZone || bScrollZone)) {\r\n                touchScroll();\r\n            }\r\n            if (/vertical-scroll-/.test(self.startingCell.style)) {\r\n                self.scrollBox.scrollTop = self.scrollBox.scrollHeight\r\n                    * ((self.touchPosition.y - ch - sbw) / (self.scrollBox.height - sbw - ch));\r\n                return;\r\n            }\r\n            if (/horizontal-scroll-/.test(self.startingCell.style)) {\r\n                self.scrollBox.scrollLeft = self.scrollBox.scrollWidth\r\n                    * ((self.touchPosition.x - rw - sbw) / (self.scrollBox.width - sbw - rw));\r\n                return;\r\n            }\r\n            if (/selection-handle-/.test(self.startingCell.style)) {\r\n                self.touchSelect(self.currentCell, self.startingCell.style);\r\n                return;\r\n            }\r\n            self.scrollBox.scrollTo(self.touchScrollStart.x - self.touchDelta.x,\r\n                self.touchScrollStart.y - self.touchDelta.y);\r\n        };\r\n        self.touchmove = function (e) {\r\n            if (touchMoving) {\r\n                return;\r\n            }\r\n            requestAnimationFrame(function () {\r\n                touchMoving = true;\r\n                touchMove(e);\r\n                touchMoving = false;\r\n            });\r\n        };\r\n        self.touchEndEvents = function (e) {\r\n            self.zoomDeltaStart = undefined;\r\n            self.touchSelecting = false;\r\n            clearInterval(self.touchScrollTimeout);\r\n            clearInterval(self.touchContextTimeout);\r\n            clearInterval(self.calculatePPSTimer);\r\n            e.stopPropagation();\r\n            document.body.removeEventListener('touchmove', self.touchmove, {passive: false});\r\n            document.body.removeEventListener('touchend', self.touchend, false);\r\n            document.body.removeEventListener('touchcancel', self.touchcancel, false);\r\n        };\r\n        self.touchend = function (e) {\r\n            if (self.dispatchEvent('touchend', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            self.zoomDeltaStart = undefined;\r\n            if (e.changedTouches[0]) {\r\n                self.touchPosition = undefined;\r\n            }\r\n            if (e.changedTouches[1]) {\r\n                self.touchPosition1 = undefined;\r\n            }\r\n            if (self.zoomAltered) {\r\n                if (e.touches.length === 0) {\r\n                    self.zoomAltered = false;\r\n                }\r\n                return;\r\n            }\r\n            var dz = Math.abs(self.touchDelta.x) + Math.abs(self.touchDelta.y) < self.attributes.touchDeadZone;\r\n            if (isNaN(self.xPPS)) {\r\n                self.xPPS = 0;\r\n            }\r\n            if (isNaN(self.yPPS)) {\r\n                self.yPPS = 0;\r\n            }\r\n            if (isNaN(self.xPPST)) {\r\n                self.xPPST = 0;\r\n            }\r\n            if (isNaN(self.yPPST)) {\r\n                self.yPPST = 0;\r\n            }\r\n            self.touchAnimateTo.x = self.xPPS * self.attributes.touchReleaseAcceleration;\r\n            self.touchAnimateTo.y = self.yPPS * self.attributes.touchReleaseAcceleration;\r\n            self.calculatePPSTimed();\r\n            if (dz && !self.contextMenu) {\r\n                self.touchCell(self.touchStartEvent)();\r\n            } else if (self.animationFrames === 0\r\n                    && (Math.abs(self.xPPST) > self.attributes.scrollAnimationPPSThreshold\r\n                        || Math.abs(self.yPPST) > self.attributes.scrollAnimationPPSThreshold)\r\n                    && !/-scroll-/.test(self.startingCell.style)\r\n                    && !dz) {\r\n                self.stopAnimation = false;\r\n                self.touchEndAnimation();\r\n            }\r\n            self.touchEndEvents(e);\r\n        };\r\n        self.touchcancel = function (e) {\r\n            if (self.dispatchEvent('touchcancel', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            self.touchEndEvents(e);\r\n        };\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/touch.js\n// module id = 5\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals HTMLElement: false, Reflect: false, define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self, ctor) {\r\n        self.scale = 1;\r\n        self.orders = {\r\n            rows: [],\r\n            columns: []\r\n        };\r\n        self.appliedInlineStyles = {};\r\n        self.cellGridAttributes = {};\r\n        self.treeGridAttributes = {};\r\n        self.visibleRowHeights = [];\r\n        self.hasFocus = false;\r\n        self.activeCell = {\r\n            columnIndex: 0,\r\n            rowIndex: 0\r\n        };\r\n        self.innerHTML = '';\r\n        self.storageName = 'canvasDataGrid';\r\n        self.invalidSearchExpClass = 'canvas-datagrid-invalid-search-regExp';\r\n        self.localStyleLibraryStorageKey = 'canvas-datagrid-user-style-library';\r\n        self.dataType = 'application/x-canvas-datagrid';\r\n        self.orderBy = null;\r\n        self.orderDirection = 'asc';\r\n        self.orderings = {\r\n            columns: [],\r\n            add: function (orderBy, orderDirection, sortFunction) {\r\n                self.orderings.columns = self.orderings.columns.filter(function (col) {\r\n                    return col.orderBy !== orderBy;\r\n                });\r\n                self.orderings.columns.push({\r\n                    orderBy: orderBy,\r\n                    orderDirection: orderDirection,\r\n                    sortFunction: sortFunction\r\n                });\r\n            },\r\n            sort: function () {\r\n                self.orderings.columns.forEach(function (col) {\r\n                    self.data.sort(col.sortFunction(col.orderBy, col.orderDirection));\r\n                });\r\n            }\r\n        };\r\n        self.columnFilters = {};\r\n        self.filters = {};\r\n        self.frozenRow = 0;\r\n        self.frozenColumn = 0;\r\n        self.ellipsisCache = {};\r\n        self.scrollCache = { x: [], y: [] };\r\n        self.scrollBox = {};\r\n        self.visibleRows = [];\r\n        self.visibleCells = [];\r\n        self.sizes = {\r\n            rows: {},\r\n            columns: {},\r\n            trees: {}\r\n        };\r\n        self.currentFilter = function () {\r\n            return true;\r\n        };\r\n        self.selections = [];\r\n        self.hovers = {};\r\n        self.attributes = {};\r\n        self.style = {};\r\n        self.formatters = {};\r\n        self.sorters = {};\r\n        self.parsers = {};\r\n        self.schemaHashes = {};\r\n        self.events = {};\r\n        self.changes = [];\r\n        self.scrollIndexTop = 0;\r\n        self.scrollPixelTop = 0;\r\n        self.scrollIndexLeft = 0;\r\n        self.scrollPixelLeft = 0;\r\n        self.childGrids = {};\r\n        self.openChildren = {};\r\n        self.scrollModes = [\r\n            'vertical-scroll-box',\r\n            'vertical-scroll-top',\r\n            'vertical-scroll-bottom',\r\n            'horizontal-scroll-box',\r\n            'horizontal-scroll-right',\r\n            'horizontal-scroll-left'\r\n        ];\r\n        self.componentL1Events = {};\r\n        self.eventNames = ['afterdraw', 'afterrendercell', 'attributechanged', 'beforebeginedit',\r\n            'beforecreatecellgrid', 'beforedraw', 'beforeendedit', 'beforerendercell', 'beforerendercellgrid',\r\n            'beginedit', 'cellmouseout', 'cellmouseover', 'click', 'collapsetree', 'contextmenu', 'copy',\r\n            'datachanged', 'dblclick', 'endedit', 'expandtree', 'formatcellvalue', 'keydown', 'keypress',\r\n            'keyup', 'mousedown', 'mousemove', 'mouseup', 'newrow', 'ordercolumn', 'rendercell', 'rendercellgrid',\r\n            'renderorderbyarrow', 'rendertext', 'rendertreearrow', 'reorder', 'reordering', 'resize',\r\n            'resizecolumn', 'resizerow', 'schemachanged', 'scroll', 'selectionchanged', 'stylechanged',\r\n            'touchcancel', 'touchend', 'touchmove', 'touchstart', 'wheel'];\r\n        self.mouse = { x: 0, y: 0};\r\n        self.getSelectedData = function (expandToRow) {\r\n            var d = [], s = self.getSchema(), l = self.data.length;\r\n            if (l === 0) { return []; }\r\n            self.selections.forEach(function (row, index) {\r\n                if (!row) { return; }\r\n                if (index === l) { return; }\r\n                if (row.length === 0) {\r\n                    d[index] = null;\r\n                    return;\r\n                }\r\n                d[index] = {};\r\n                row.forEach(function (col) {\r\n                    var orderedIndex;\r\n                    if (col === -1 || !s[col]) { return; }\r\n                    orderedIndex = self.orders.columns[col];\r\n                    if (!expandToRow && s[orderedIndex].hidden) { return; }\r\n                    if (self.data[index]) {\r\n                        d[index][s[orderedIndex].name] = self.data[index][s[orderedIndex].name];\r\n                    }\r\n                });\r\n            });\r\n            return d;\r\n        };\r\n        self.getColumnHeaderCellHeight = function () {\r\n            if (!self.attributes.showColumnHeaders) { return 0; }\r\n            return ((self.sizes.rows[-1] || self.style.columnHeaderCellHeight) * self.scale);\r\n        };\r\n        self.getRowHeaderCellWidth = function () {\r\n            if (!self.attributes.showRowHeaders) { return 0; }\r\n            return (self.sizes.columns[-1] || self.style.rowHeaderCellWidth) * self.scale;\r\n        };\r\n        self.setStorageData = function () {\r\n            if (!self.attributes.saveAppearance || !self.attributes.name) { return; }\r\n            var visibility = {};\r\n            self.getSchema().forEach(function (column) {\r\n                visibility[column.name] = !column.hidden;\r\n            });\r\n            localStorage.setItem(self.storageName + '-' + self.attributes.name, JSON.stringify({\r\n                sizes: {\r\n                    rows: self.sizes.rows,\r\n                    columns: self.sizes.columns\r\n                },\r\n                orders: {\r\n                    rows: self.orders.rows,\r\n                    columns: self.orders.columns\r\n                },\r\n                orderBy: self.orderBy,\r\n                orderDirection: self.orderDirection,\r\n                visibility: visibility\r\n            }));\r\n        };\r\n        self.getSchema = function () {\r\n            return self.schema || self.tempSchema || [];\r\n        };\r\n        function fillArray(low, high) {\r\n            var i = [], x;\r\n            for (x = low; x <= high; x += 1) {\r\n                i[x] = x;\r\n            }\r\n            return i;\r\n        }\r\n        self.createColumnOrders = function () {\r\n            var s = self.getSchema();\r\n            self.orders.columns = fillArray(0, s.length - 1);\r\n        };\r\n        self.createRowOrders = function () {\r\n            self.orders.rows = fillArray(0, self.data.length - 1);\r\n        };\r\n        self.getVisibleSchema = function () {\r\n            return self.getSchema().filter(function (col) {\r\n                return !col.hidden;\r\n            });\r\n        };\r\n        self.applyDefaultValue = function (row, header) {\r\n            var d = header.defaultValue || '';\r\n            if (typeof d === 'function') {\r\n                d = d.apply(self.intf, [header]);\r\n            }\r\n            row[header.name] = d;\r\n        };\r\n        self.createNewRowData = function () {\r\n            self.newRow = {};\r\n            self.getSchema().forEach(function forEachHeader(header) {\r\n                self.applyDefaultValue(self.newRow, header);\r\n            });\r\n        };\r\n        self.getSchemaNameHash = function (key) {\r\n            var n = 0;\r\n            while (self.schemaHashes[key]) {\r\n                n += 1;\r\n                key = key + n;\r\n            }\r\n            return key;\r\n        };\r\n        self.filter = function (type) {\r\n            var f = self.filters[type];\r\n            if (!f && type !== undefined) {\r\n                console.warn('Cannot find filter for type %s, falling back to substring match.', type);\r\n                f = self.filters.string;\r\n            }\r\n            return f;\r\n        };\r\n        self.applyFilter = function () {\r\n            self.refreshFromOrigialData();\r\n            Object.keys(self.columnFilters).forEach(function (filter) {\r\n                var header = self.getHeaderByName(filter);\r\n                if (!header) {\r\n                    return;\r\n                }\r\n                self.currentFilter = header.filter || self.filter(header.type || 'string');\r\n                self.data = self.data.filter(function (row) {\r\n                    return self.currentFilter(row[filter], self.columnFilters[filter]);\r\n                });\r\n            });\r\n            self.resize();\r\n            self.draw(true);\r\n        };\r\n        self.applyDataTransforms = function () {\r\n            self.applyFilter();\r\n            self.orderings.sort();\r\n        }\r\n        self.getBestGuessDataType = function (columnName, data) {\r\n            var t, x, l = data.length;\r\n            for (x = 0; x < l; x += 1) {\r\n                if (data[x] !== undefined && data[x] !== null && [null, undefined].indexOf(data[x][columnName]) !== -1) {\r\n                    t = typeof data[x];\r\n                    return t === 'object' ? 'string' : t;\r\n                }\r\n            }\r\n            return 'string';\r\n        };\r\n        self.drawChildGrids = function () {\r\n            Object.keys(self.childGrids).forEach(function (gridKey) {\r\n                self.childGrids[gridKey].draw();\r\n            });\r\n        };\r\n        self.resizeChildGrids = function () {\r\n            Object.keys(self.childGrids).forEach(function (gridKey) {\r\n                self.childGrids[gridKey].resize();\r\n            });\r\n        };\r\n        self.autoScrollZone = function (e, x, y, ctrl) {\r\n            var setTimer,\r\n                rowHeaderCellWidth = self.getRowHeaderCellWidth(),\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight();\r\n            if (y !== -1) {\r\n                if (x > self.width - self.attributes.selectionScrollZone && x < self.width) {\r\n                    self.scrollBox.scrollLeft += self.attributes.selectionScrollIncrement;\r\n                    setTimer = true;\r\n                }\r\n                if (x - self.attributes.selectionScrollZone - rowHeaderCellWidth < 0) {\r\n                    self.scrollBox.scrollLeft -= self.attributes.selectionScrollIncrement;\r\n                    setTimer = true;\r\n                }\r\n            }\r\n            if (y !== -1) {\r\n                if (y > self.height - self.attributes.selectionScrollZone && y < self.height) {\r\n                    self.scrollBox.scrollTop += self.attributes.selectionScrollIncrement;\r\n                    setTimer = true;\r\n                }\r\n                if (y - self.attributes.selectionScrollZone - columnHeaderCellHeight < 0) {\r\n                    self.scrollBox.scrollTop -= self.attributes.selectionScrollIncrement;\r\n                    setTimer = true;\r\n                }\r\n            }\r\n            if (setTimer && !ctrl && self.currentCell && self.currentCell.columnIndex !== -1) {\r\n                self.scrollTimer = setTimeout(self.mousemove, self.attributes.scrollRepeatRate, e);\r\n            }\r\n        };\r\n        self.refreshFromOrigialData = function () {\r\n            self.data = self.originalData.filter(function (row) {\r\n                return true;\r\n            });\r\n        };\r\n        self.validateColumn = function (c, s) {\r\n            if (!c.name) {\r\n                throw new Error('A column must contain at least a name.');\r\n            }\r\n            if (s.filter(function (i) { return i.name === c.name; }).length > 0) {\r\n                throw new Error('A column with the name '\r\n                    + c.name + ' already exists and cannot be added again.');\r\n            }\r\n            return true;\r\n        };\r\n        self.setDefaults = function (obj1, obj2, key, def) {\r\n            obj1[key] = obj2[key] === undefined ? def : obj2[key];\r\n        };\r\n        self.setAttributes = function () {\r\n            self.defaults.attributes.forEach(function eachAttribute(i) {\r\n                self.setDefaults(self.attributes, self.args, i[0], i[1]);\r\n            });\r\n        };\r\n        self.setStyle = function () {\r\n            self.defaults.styles.forEach(function eachStyle(i) {\r\n                self.setDefaults(self.style, self.args.style || {}, i[0], i[1]);\r\n            });\r\n        };\r\n        self.autosize = function (colName) {\r\n            self.getVisibleSchema().forEach(function (col, colIndex) {\r\n                if (col.name === colName || colName === undefined) {\r\n                    self.sizes.columns[colIndex]\r\n                        = Math.max(self.findColumnMaxTextLength(col.name), self.style.minColumnWidth);\r\n                }\r\n            });\r\n            self.sizes.columns[-1] = self.findColumnMaxTextLength('cornerCell');\r\n        };\r\n        self.dispose = function () {\r\n            if (!self.isChildGrid && self.canvas && self.canvas.parentNode) {\r\n                self.canvas.parentNode.removeChild(self.canvas);\r\n            }\r\n            if(!self.isChildGrid) {\r\n                document.body.removeChild(self.controlInput)\r\n            }\r\n            self.eventParent.removeEventListener('mouseup', self.mouseup, false);\r\n            self.eventParent.removeEventListener('mousedown', self.mousedown, false);\r\n            self.eventParent.removeEventListener('dblclick', self.dblclick, false);\r\n            self.eventParent.removeEventListener('click', self.click, false);\r\n            self.eventParent.removeEventListener('mousemove', self.mousemove);\r\n            self.eventParent.removeEventListener('wheel', self.scrollWheel, false);\r\n            self.canvas.removeEventListener('contextmenu', self.contextmenu, false);\r\n            self.canvas.removeEventListener('copy', self.copy);\r\n            self.controlInput.removeEventListener('copy', self.copy);\r\n            self.controlInput.removeEventListener('cut', self.cut);\r\n            self.controlInput.removeEventListener('paste', self.paste);\r\n            self.controlInput.removeEventListener('keypress', self.keypress, false);\r\n            self.controlInput.removeEventListener('keyup', self.keyup, false);\r\n            self.controlInput.removeEventListener('keydown', self.keydown, false);\r\n            window.removeEventListener('resize', self.resize);\r\n            if (self.observer && self.observer.disconnect) {\r\n                self.observer.disconnect();\r\n            }\r\n        };\r\n        self.tryLoadStoredSettings = function () {\r\n            var s;\r\n            self.reloadStoredValues();\r\n            if (self.storedSettings\r\n                    && typeof self.storedSettings.orders === 'object'\r\n                    && self.storedSettings.orders !== null) {\r\n                if (self.storedSettings.orders.rows.length >= (self.data || []).length) {\r\n                    self.orders.rows = self.storedSettings.orders.rows;\r\n                }\r\n                s = self.getSchema();\r\n                if (self.storedSettings.orders.columns.length === s.length) {\r\n                    self.orders.columns = self.storedSettings.orders.columns;\r\n                }\r\n                self.orderBy = self.storedSettings.orderBy === undefined\r\n                    ? s[0].name : self.storedSettings.orderBy;\r\n                self.orderDirection = self.storedSettings.orderDirection === undefined\r\n                    ? 'asc' : self.storedSettings.orderDirection;\r\n                if (self.storedSettings.orderBy !== undefined && self.getHeaderByName(self.orderBy) && self.orderDirection) {\r\n                    self.order(self.orderBy, self.orderDirection);\r\n                }\r\n            }\r\n        };\r\n        self.getDomRoot = function () {\r\n            return self.shadowRoot ? self.shadowRoot.host : self.parentNode;\r\n        };\r\n        self.getFontName = function (fontStyle) {\r\n            return fontStyle.replace(/\\d+\\.?\\d*px/, '');\r\n        };\r\n        self.getFontHeight = function (fontStyle) {\r\n            return parseFloat(fontStyle, 10);\r\n        };\r\n        self.parseStyleValue = function (key) {\r\n            if (/Font/.test(key)) {\r\n                self.style[key + 'Height'] = self.getFontHeight(self.style[key]);\r\n                self.style[key + 'Name'] = self.getFontName(self.style[key]);\r\n                return;\r\n            }\r\n            // when inheriting styles from already instantiated grids, don't parse already parsed values.\r\n            if (key === 'moveOverlayBorderSegments' && typeof self.style[key] === 'string') {\r\n                self.style[key] = self.style[key].split(',')\r\n                    .map(function (i) { return parseInt(i, 10); });\r\n            }\r\n        };\r\n        self.initProp = function (propName) {\r\n            if (!self.args[propName]) { return; }\r\n            Object.keys(self.args[propName]).forEach(function (key) {\r\n                self[propName][key] = self.args[propName][key];\r\n            });\r\n        };\r\n        self.getStyleProperty = function (key) {\r\n            if (self.styleKeys.indexOf(key) === -1) {\r\n                return self.parentNodeStyle[key];\r\n            }\r\n            return self.style[key];\r\n        };\r\n        self.setStyleProperty = function (key, value, supressDrawAndEvent) {\r\n            var isDim = ['height', 'width', 'minHeight', 'minWidth', 'maxHeight', 'maxWidth'].indexOf(key) !== -1;\r\n            if (self.styleKeys.indexOf(key) === -1) {\r\n                self.parentNodeStyle[key] = value;\r\n            } else {\r\n                if (/-/.test(key)) {\r\n                    key = self.dehyphenateProperty(key);\r\n                }\r\n                self.style[key] = value;\r\n                self.parseStyleValue(key);\r\n            }\r\n            if (isDim) {\r\n                self.resize();\r\n            }\r\n            if (!supressDrawAndEvent) {\r\n                self.draw(true);\r\n                self.dispatchEvent('stylechanged', {name: 'style', value: value});\r\n            }\r\n        };\r\n        self.reloadStoredValues = function () {\r\n            if (self.attributes.name && self.attributes.saveAppearance) {\r\n                try {\r\n                    self.storedSettings = localStorage.getItem(self.storageName + '-' + self.attributes.name);\r\n                } catch (e) {\r\n                    console.warn(\"Error loading stored values. \" + e.message);\r\n                    self.storedSettings = undefined;\r\n                }\r\n                if (self.storedSettings) {\r\n                    try {\r\n                        self.storedSettings = JSON.parse(self.storedSettings);\r\n                    } catch (e) {\r\n                        console.warn('could not read settings from localStore', e);\r\n                        self.storedSettings = undefined;\r\n                    }\r\n                }\r\n                if (self.storedSettings) {\r\n                    if (typeof self.storedSettings.sizes === 'object'\r\n                            && self.storedSettings.sizes !== null) {\r\n                        self.sizes.rows = self.storedSettings.sizes.rows;\r\n                        self.sizes.columns = self.storedSettings.sizes.columns;\r\n                        ['trees', 'columns', 'rows'].forEach(function (i) {\r\n                            if (!self.sizes[i]) {\r\n                                self.sizes[i] = {};\r\n                            }\r\n                        });\r\n                    }\r\n                    if (typeof self.storedSettings.visibility === 'object') {\r\n                        self.getSchema().forEach(function (column) {\r\n                            if (self.storedSettings.visibility && self.storedSettings.visibility[column.name] !== undefined) {\r\n                                column.hidden = !self.storedSettings.visibility[column.name];\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        self.init = function () {\r\n            if (self.initialized) { return; }\r\n            function addStyleKeyIfNoneExists(key) {\r\n                if (self.styleKeys.indexOf(key) === -1) {\r\n                    self.styleKeys.push(key);\r\n                }\r\n            }\r\n            var publicStyleKeyIntf = {};\r\n            self.setAttributes();\r\n            self.setStyle();\r\n            self.initScrollBox();\r\n            self.setDom();\r\n            self.nodeType = 'canvas-datagrid';\r\n            self.ie = /Trident/.test(window.navigator.userAgent);\r\n            self.edge = /Edge/.test(window.navigator.userAgent);\r\n            self.webKit = /WebKit/.test(window.navigator.userAgent);\r\n            self.moz = /Gecko/.test(window.navigator.userAgent);\r\n            self.mobile = /Mobile/i.test(window.navigator.userAgent);\r\n            self.cursorGrab = 'grab';\r\n            self.cursorGrabing = 'grabbing';\r\n            self.cursorGrab = self.webKit ? '-webkit-grab' : self.cursorGrab;\r\n            self.cursorGrabing = self.moz ? '-webkit-grabbing' : self.cursorGrabbing;\r\n            self.pointerLockPosition = {x: 0, y: 0};\r\n            Object.keys(self.style).forEach(self.parseStyleValue);\r\n            self.intf.moveSelection = self.moveSelection;\r\n            self.intf.moveTo = self.moveTo;\r\n            self.intf.addEventListener = self.addEventListener;\r\n            self.intf.removeEventListener = self.removeEventListener;\r\n            self.intf.dispatchEvent = self.dispatchEvent;\r\n            /**\r\n             * Releases grid resources and removes grid elements.\r\n             * @memberof canvasDatagrid\r\n             * @name dispose\r\n             * @method\r\n             */\r\n            self.intf.dispose = self.dispose;\r\n            /**\r\n             * Appends the grid to another element later.  Not implemented.\r\n             * @memberof canvasDatagrid\r\n             * @name appendTo\r\n             * @method\r\n             * @param {number} el The element to append the grid to.\r\n             */\r\n            self.intf.appendTo = self.appendTo;\r\n            self.intf.getVisibleCellByIndex = self.getVisibleCellByIndex;\r\n            self.intf.filters = self.filters;\r\n            self.intf.sorters = self.sorters;\r\n            self.intf.autosize = self.autosize;\r\n            self.intf.beginEditAt = self.beginEditAt;\r\n            self.intf.endEdit = self.endEdit;\r\n            self.intf.setActiveCell = self.setActiveCell;\r\n            self.intf.forEachSelectedCell = self.forEachSelectedCell;\r\n            self.intf.scrollIntoView = self.scrollIntoView;\r\n            self.intf.clearChangeLog = self.clearChangeLog;\r\n            self.intf.gotoCell = self.gotoCell;\r\n            self.intf.gotoRow = self.gotoRow;\r\n            self.intf.getHeaderByName = self.getHeaderByName;\r\n            self.intf.findColumnScrollLeft = self.findColumnScrollLeft;\r\n            self.intf.findRowScrollTop = self.findRowScrollTop;\r\n            self.intf.fitColumnToValues = self.fitColumnToValues;\r\n            self.intf.findColumnMaxTextLength = self.findColumnMaxTextLength;\r\n            self.intf.disposeContextMenu = self.disposeContextMenu;\r\n            self.intf.getCellAt = self.getCellAt;\r\n            self.intf.isCellVisible = self.isCellVisible;\r\n            self.intf.isRowVisible = self.isRowVisible;\r\n            self.intf.isColumnVisible = self.isColumnVisible;\r\n            self.intf.order = self.order;\r\n            self.intf.draw = self.draw;\r\n            self.intf.isComponent = self.isComponent;\r\n            self.intf.selectArea = self.selectArea;\r\n            self.intf.clipElement = self.clipElement;\r\n            self.intf.getSchemaFromData = self.getSchemaFromData;\r\n            self.intf.setFilter = self.setFilter;\r\n            self.intf.selectRow = self.selectRow;\r\n            self.intf.parentGrid = self.parentGrid;\r\n            self.intf.toggleTree = self.toggleTree;\r\n            self.intf.expandTree = self.expandTree;\r\n            self.intf.collapseTree = self.collapseTree;\r\n            self.intf.canvas = self.canvas;\r\n            self.intf.context = self.ctx;\r\n            self.intf.insertRow = self.insertRow;\r\n            self.intf.deleteRow = self.deleteRow;\r\n            self.intf.addRow = self.addRow;\r\n            self.intf.insertColumn = self.insertColumn;\r\n            self.intf.deleteColumn = self.deleteColumn;\r\n            self.intf.addColumn = self.addColumn;\r\n            self.intf.getClippingRect = self.getClippingRect;\r\n            self.intf.setRowHeight = self.setRowHeight;\r\n            self.intf.setColumnWidth = self.setColumnWidth;\r\n            self.intf.resetColumnWidths = self.resetColumnWidths;\r\n            self.intf.resetRowHeights = self.resetRowHeights;\r\n            self.intf.resize = self.resize;\r\n            self.intf.selectColumn = self.selectColumn;\r\n            self.intf.selectRow = self.selectRow;\r\n            self.intf.selectAll = self.selectAll;\r\n            self.intf.selectNone = self.selectNone;\r\n            self.intf.drawChildGrids = self.drawChildGrids;\r\n            self.intf.assertPxColor = self.assertPxColor;\r\n            self.intf.clearPxColorAssertions = self.clearPxColorAssertions;\r\n            self.intf.integerToAlpha = self.integerToAlpha;\r\n            self.intf.copy = self.copy;\r\n            self.intf.setStyleProperty = self.setStyleProperty;\r\n            Object.defineProperty(self.intf, 'defaults', {\r\n                get: function () {\r\n                    return {\r\n                        styles: self.defaults.styles.reduce(function (a, i) { a[i[0]] = i[1]; return a; }, {}),\r\n                        attributes: self.defaults.attributes.reduce(function (a, i) { a[i[0]] = i[1]; return a; }, {})\r\n                    };\r\n                }\r\n            });\r\n            self.styleKeys = Object.keys(self.intf.defaults.styles);\r\n            self.styleKeys.map(function (i) { return self.hyphenateProperty(i, false); }).forEach(addStyleKeyIfNoneExists);\r\n            self.styleKeys.map(function (i) { return self.hyphenateProperty(i, true); }).forEach(addStyleKeyIfNoneExists);\r\n            self.DOMStyles = window.getComputedStyle(document.body, null);\r\n            self.styleKeys.concat(Object.keys(self.DOMStyles)).forEach(function (key) {\r\n                // unless this line is here, Object.keys() will not work on <instance>.style\r\n                publicStyleKeyIntf[key] = undefined;\r\n                Object.defineProperty(publicStyleKeyIntf, key, {\r\n                    get: function () {\r\n                        return self.getStyleProperty(key);\r\n                    },\r\n                    set: function (value) {\r\n                        if (self.initialized) {\r\n                            self.appliedInlineStyles[key] = value;\r\n                        }\r\n                        self.setStyleProperty(key, value);\r\n                    }\r\n                });\r\n            });\r\n            Object.defineProperty(self.intf, 'shadowRoot', {\r\n                get: function () {\r\n                    return self.shadowRoot;\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'activeCell', {\r\n                get: function () {\r\n                    return self.activeCell;\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'hasFocus', {\r\n                get: function () {\r\n                    return self.hasFocus;\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'style', {\r\n                get: function () {\r\n                    return publicStyleKeyIntf;\r\n                },\r\n                set: function (valueObject) {\r\n                    Object.keys(valueObject).forEach(function (key) {\r\n                        self.setStyleProperty(key, valueObject[key], true);\r\n                    });\r\n                    self.draw(true);\r\n                    self.dispatchEvent('stylechanged', {name: 'style', value: valueObject});\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'attributes', { value: {}});\r\n            Object.keys(self.attributes).forEach(function (key) {\r\n                Object.defineProperty(self.intf.attributes, key, {\r\n                    get: function () {\r\n                        return self.attributes[key];\r\n                    },\r\n                    set: function (value) {\r\n                        self.attributes[key] = value;\r\n                        if (key === 'name') {\r\n                            self.tryLoadStoredSettings();\r\n                        }\r\n                        self.draw(true);\r\n                        self.dispatchEvent('attributechanged', {name: key, value: value[key]});\r\n                    }\r\n                });\r\n            });\r\n            self.filters.string = function (value, filterFor) {\r\n                value = String(value);\r\n                var filterRegExp,\r\n                    regEnd = /\\/(i|g|m)*$/,\r\n                    pattern = regEnd.exec(filterFor),\r\n                    flags = pattern ? pattern[0].substring(1) : '',\r\n                    flagLength = flags.length;\r\n                self.invalidFilterRegEx = undefined;\r\n                if (filterFor.substring(0, 1) === '/' && pattern) {\r\n                    try {\r\n                        filterRegExp = new RegExp(filterFor.substring(1, filterFor.length - (flagLength + 1)), flags);\r\n                    } catch (e) {\r\n                        self.invalidFilterRegEx = e;\r\n                        return;\r\n                    }\r\n                    return filterRegExp.test(value);\r\n                }\r\n                return value.toString ? value.toString().toLocaleUpperCase()\r\n                    .indexOf(filterFor.toLocaleUpperCase()) !== -1 : false;\r\n            };\r\n            self.filters.number = function (value, filterFor) {\r\n                if (!filterFor) { return true; }\r\n                return value === filterFor;\r\n            };\r\n            ['formatters', 'filters', 'sorters'].forEach(self.initProp);\r\n            self.applyComponentStyle(false, self.intf);\r\n            self.reloadStoredValues();\r\n            if (self.args.data) {\r\n                self.intf.data = self.args.data;\r\n            }\r\n            if (self.intf.innerText || self.intf.textContent) {\r\n                if (self.intf.dataType === 'application/x-canvas-datagrid') {\r\n                    self.intf.dataType = 'application/json+x-canvas-datagrid';\r\n                }\r\n                self.intf.data = self.intf.innerText || self.intf.textContent;\r\n            }\r\n            if (self.args.schema) {\r\n                self.intf.schema = self.args.schema;\r\n            }\r\n            if (self.isChildGrid || !self.isComponent) {\r\n                requestAnimationFrame(function () { self.resize(true); });\r\n            } else {\r\n                self.resize(true);\r\n            }\r\n            self.initialized = true;\r\n            return self;\r\n        };\r\n        /**\r\n         * Removes focus from the grid.\r\n         * @memberof canvasDatagrid\r\n         * @name blur\r\n         * @method\r\n         */\r\n        self.intf.blur = function (e) {\r\n            self.hasFocus = false;\r\n        };\r\n        /**\r\n         * Focuses on the grid.\r\n         * @memberof canvasDatagrid\r\n         * @name focus\r\n         * @method\r\n         */\r\n        self.intf.focus = function () {\r\n            self.hasFocus = true;\r\n            self.controlInput.focus();\r\n        };\r\n        if (self.shadowRoot || self.isChildGrid) {\r\n            Object.defineProperty(self.intf, 'height', {\r\n                get: function () {\r\n                    if (self.shadowRoot) {\r\n                        return self.shadowRoot.height;\r\n                    }\r\n                    return self.parentNode.height;\r\n                },\r\n                set: function (value) {\r\n                    if (self.shadowRoot) {\r\n                        self.shadowRoot.height = value;\r\n                    } else {\r\n                        self.parentNode.height = value;\r\n                    }\r\n                    self.resize(true);\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'width', {\r\n                get: function () {\r\n                    if (self.shadowRoot) {\r\n                        return self.shadowRoot.width;\r\n                    }\r\n                    return self.parentNode.width;\r\n                },\r\n                set: function (value) {\r\n                    if (self.shadowRoot) {\r\n                        self.shadowRoot.width = value;\r\n                    } else {\r\n                        self.parentNode.width = value;\r\n                    }\r\n                    self.resize(true);\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'parentNode', {\r\n                get: function () {\r\n                    return self.parentNode;\r\n                },\r\n                set: function (value) {\r\n                    if (!self.isChildGrid) {\r\n                        throw new TypeError('Cannot set property parentNode which has only a getter');\r\n                    }\r\n                    self.parentNode = value;\r\n                }\r\n            });\r\n        }\r\n        Object.defineProperty(self.intf, 'visibleRowHeights', {\r\n            get: function () {\r\n                return self.visibleRowHeights;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'openChildren', {\r\n            get: function () {\r\n                return self.openChildren;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'childGrids', {\r\n            get: function () {\r\n                return Object.keys(self.childGrids).map(function (gridId) {\r\n                    return self.childGrids[gridId];\r\n                });\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'isChildGrid', {\r\n            get: function () {\r\n                return self.isChildGrid;\r\n            }\r\n        });\r\n        Object.defineProperty(self, 'cursor', {\r\n            get: function () {\r\n                return self.parentNodeStyle.cursor;\r\n            },\r\n            set: function (value) {\r\n                if (value === 'cell') { value = 'default'; }\r\n                if (self.currentCursor !== value) {\r\n                    self.parentNodeStyle.cursor = value;\r\n                    self.currentCursor = value;\r\n                }\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'orderDirection', {\r\n            get: function () {\r\n                return self.orderDirection;\r\n            },\r\n            set: function (value) {\r\n                if (value !== 'desc') {\r\n                    value = 'asc';\r\n                }\r\n                self.orderDirection = value;\r\n                self.order(self.orderBy, self.orderDirection);\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'orderBy', {\r\n            get: function () {\r\n                return self.orderBy;\r\n            },\r\n            set: function (value) {\r\n                if (self.getSchema().find(function (col) {\r\n                        return col.name === value;\r\n                    }) === undefined) {\r\n                    throw new Error('Cannot sort by unknown column name.');\r\n                }\r\n                self.orderBy = value;\r\n                self.order(self.orderBy, self.orderDirection);\r\n            }\r\n        });\r\n        if (self.isComponent) {\r\n            Object.defineProperty(self.intf, 'offsetHeight', {\r\n                get: function () {\r\n                    return self.canvas.offsetHeight;\r\n                }\r\n            });\r\n            Object.defineProperty(self.intf, 'offsetWidth', {\r\n                get: function () {\r\n                    return self.canvas.offsetWidth;\r\n                }\r\n            });\r\n        }\r\n        Object.defineProperty(self.intf, 'scrollHeight', {\r\n            get: function () {\r\n                return self.scrollBox.scrollHeight;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'scrollWidth', {\r\n            get: function () {\r\n                return self.scrollBox.scrollWidth;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'scrollTop', {\r\n            get: function () {\r\n                return self.scrollBox.scrollTop;\r\n            },\r\n            set: function (value) {\r\n                self.scrollBox.scrollTop = value;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'scrollLeft', {\r\n            get: function () {\r\n                return self.scrollBox.scrollLeft;\r\n            },\r\n            set: function (value) {\r\n                self.scrollBox.scrollLeft = value;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'sizes', {\r\n            get: function () {\r\n                return self.sizes;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'parentDOMNode', {\r\n            get: function () {\r\n                return self.parentDOMNode;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'input', {\r\n            get: function () {\r\n                return self.input;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'controlInput', {\r\n            get: function () {\r\n                return self.controlInput;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'currentCell', {\r\n            get: function () {\r\n                return self.currentCell;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'visibleCells', {\r\n            get: function () {\r\n                return self.visibleCells;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'visibleRows', {\r\n            get: function () {\r\n                return self.visibleRows;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'selections', {\r\n            get: function () {\r\n                return self.selections;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'dragMode', {\r\n            get: function () {\r\n                return self.dragMode;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'changes', {\r\n            get: function () {\r\n                return self.changes;\r\n            }\r\n        });\r\n        self.intf.formatters = self.formatters;\r\n        Object.defineProperty(self.intf, 'dataType', {\r\n            get: function () {\r\n                return self.dataType;\r\n            },\r\n            set: function (value) {\r\n                if (!self.parsers[value]) {\r\n                    throw new Error('No parser for MIME type ' + value);\r\n                }\r\n                self.dataType = value;\r\n            }\r\n        });\r\n        self.eventNames.forEach(function (eventName) {\r\n            Object.defineProperty(self.intf, 'on' + eventName, {\r\n                get: function () {\r\n                    return self.componentL1Events[eventName];\r\n                },\r\n                set: function (value) {\r\n                    self.events[eventName] = [];\r\n                    self.componentL1Events[eventName] = value;\r\n                    if (!value) { return; }\r\n                    self.addEventListener(eventName, value);\r\n                }\r\n            });\r\n        });\r\n        Object.defineProperty(self.intf, 'frozenRow', {\r\n            get: function () {\r\n                return self.frozenRow;\r\n            },\r\n            set: function (val) {\r\n                if (isNaN(val)) {\r\n                    throw new TypeError('Expected value for frozenRow to be a number.');\r\n                }\r\n                if (self.visibleRows.length < val) {\r\n                    throw new RangeError('Cannot set a value larger than the number of visible rows.');\r\n                }\r\n                self.frozenRow = val;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'frozenColumn', {\r\n            get: function () {\r\n                return self.frozenColumn;\r\n            },\r\n            set: function (val) {\r\n                if (isNaN(val)) {\r\n                    throw new TypeError('Expected value for frozenRow to be a number.');\r\n                }\r\n                if (self.getVisibleSchema().length < val) {\r\n                    throw new RangeError('Cannot set a value larger than the number of visible columns.');\r\n                }\r\n                self.frozenColumn = val;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'scrollIndexRect', {\r\n            get: function () {\r\n                return {\r\n                    top: self.scrollIndexTop,\r\n                    right: self.scrollIndexRight,\r\n                    bottom: self.scrollIndexBottom,\r\n                    left: self.scrollIndexLeft\r\n                };\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'scrollPixelRect', {\r\n            get: function () {\r\n                return {\r\n                    top: self.scrollPixelTop,\r\n                    right: self.scrollPixelRight,\r\n                    bottom: self.scrollPixelBottom,\r\n                    left: self.scrollPixelLeft\r\n                };\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'rowOrder', {\r\n            get: function () {\r\n                return self.orders.rows;\r\n            },\r\n            set: function (val) {\r\n                if (!Array.isArray(val)) {\r\n                    throw new TypeError('Value must be an array.');\r\n                }\r\n                if (!self.data || val.length < self.data.length) {\r\n                    throw new RangeError('Array length must be equal to or greater than number of rows.');\r\n                }\r\n                self.orders.rows = val;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'columnOrder', {\r\n            get: function () {\r\n                return self.orders.columns;\r\n            },\r\n            set: function (val) {\r\n                if (!Array.isArray(val)) {\r\n                    throw new TypeError('Value must be an array.');\r\n                }\r\n                if (val.length < self.getSchema().length) {\r\n                    throw new RangeError('Array length must be equal to or greater than number of columns.');\r\n                }\r\n                self.orders.columns = val;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'selectionBounds', {\r\n            get: function () {\r\n                return self.getSelectionBounds();\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'selectedRows', {\r\n            get: function () {\r\n                return self.getSelectedData(true);\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'selectedCells', {\r\n            get: function () {\r\n                return self.getSelectedData();\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'visibleSchema', {\r\n            get: function () {\r\n                return self.getVisibleSchema().map(function eachDataRow(col) {\r\n                    return col;\r\n                });\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'treeGridAttributes', {\r\n            get: function () {\r\n                return self.treeGridAttributes;\r\n            },\r\n            set: function setTreeGridAttributes(value) {\r\n                self.treeGridAttributes = value;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'cellGridAttributes', {\r\n            get: function () {\r\n                return self.cellGridAttributes;\r\n            },\r\n            set: function setCellGridAttributes(value) {\r\n                self.cellGridAttributes = value;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'ctx', {\r\n            get: function () {\r\n                return self.ctx;\r\n            }\r\n        });\r\n        Object.defineProperty(self.intf, 'schema', {\r\n            get: function schemaGetter() {\r\n                return self.getSchema();\r\n            },\r\n            set: function schemaSetter(value) {\r\n                if (value === undefined) {\r\n                    // Issue #89 - allow schema to be set to initialized state\r\n                    self.schema = undefined;\r\n                    self.tempSchema = undefined;\r\n                    self.dispatchEvent('schemachanged', {schema: undefined});\r\n                    return;\r\n                }\r\n                if (!Array.isArray(value) || typeof value[0] !== 'object') {\r\n                    throw new Error('Schema must be an array of objects.');\r\n                }\r\n                if (value[0].name === undefined) {\r\n                    throw new Error('Expected schema to contain an object with at least a name property.');\r\n                }\r\n                self.schema = value.map(function eachSchemaColumn(column, index) {\r\n                    column.width = column.width || self.style.cellWidth;\r\n                    column.filter = column.filter || self.filter(column.type);\r\n                    column.type = column.type || 'string';\r\n                    column.index = index;\r\n                    column.columnIndex = index;\r\n                    column.rowIndex = -1;\r\n                    return column;\r\n                });\r\n                self.tempSchema = undefined;\r\n                self.createNewRowData();\r\n                self.createColumnOrders();\r\n                self.tryLoadStoredSettings();\r\n                if (self.storedSettings && typeof self.storedSettings.visibility === 'object') {\r\n                    self.schema.forEach(function hideEachSchemaColumn(column, index) {\r\n                        if (self.storedSettings && self.storedSettings.visibility[column.name] !== undefined) {\r\n                            column.hidden = !self.storedSettings.visibility[column.name];\r\n                        }\r\n                    });\r\n                }\r\n                self.resize(true);\r\n                self.dispatchEvent('schemachanged', {schema: self.schema});\r\n            }\r\n        });\r\n        /**\r\n         * Gets an array of currently registered MIME types.\r\n         * @memberof canvasDatagrid\r\n         * @name getDataTypes\r\n         * @method\r\n         */\r\n        self.intf.getTypes = function () {\r\n            return Object.keys(self.parsers);\r\n        };\r\n        self.parseInnerHtml = function (data) {\r\n            if (!data || /^ +$/.test(data)) {\r\n                return [];\r\n            }\r\n            try {\r\n                data = JSON.parse(data);\r\n            } catch (e) {\r\n                console.warn(Error('Cannot parse application/json+x-canvas-datagrid formated data. '\r\n                    + e.message + '  \\nNote: canvas-datagrid.innerHTML is for string data only.  '\r\n                    + 'Use the canvas-datagrid.data property to set object data.'));\r\n            }\r\n            return data;\r\n        };\r\n        self.parsers['application/json+x-canvas-datagrid'] = function (data, callback) {\r\n            self.parsers['application/x-canvas-datagrid'](self.parseInnerHtml(data), function (data, schema) {\r\n                return callback(data, schema);\r\n            });\r\n        };\r\n        self.parsers['application/x-canvas-datagrid'] = function (data, callback) {\r\n            return callback(data);\r\n        };\r\n        self.intf.parsers = self.parsers;\r\n        // send to dataType ETL function to extract from input data\r\n        // and transform into native [{}, {}] format\r\n        self.etl = function (data, callback) {\r\n            if (!self.intf.parsers[self.dataType]) {\r\n                throw new Error('Unsupported data type.');\r\n            }\r\n            self.intf.parsers[self.dataType](data, function (data, schema) {\r\n                if (Array.isArray(schema)) {\r\n                    self.schema = schema;\r\n                }\r\n                // Issue #89 - allow schema to be auto-created every time data is set\r\n                if (self.attributes.autoGenerateSchema) {\r\n                    self.schema = self.getSchemaFromData(data);\r\n                }\r\n                if (!self.schema) {\r\n                    self.tempSchema = self.getSchemaFromData(data);\r\n                }\r\n                if (self.getSchema()) {\r\n                    self.createColumnOrders();\r\n                }\r\n                // set the unfiltered/sorted data array\r\n                self.originalData = data;\r\n                // apply filter, sort, etc to incoming dataset\r\n                self.applyDataTransforms();\r\n                // empty data was set\r\n                if (!self.schema && (self.data || []).length === 0) {\r\n                    self.tempSchema = [{name: ''}];\r\n                }\r\n                self.fitColumnToValues('cornerCell', true);\r\n                if ((self.tempSchema && !self.schema) || self.attributes.autoGenerateSchema) {\r\n                    self.createColumnOrders();\r\n                    self.dispatchEvent('schemachanged', {schema: self.tempSchema});\r\n                }\r\n                callback();\r\n            });\r\n        };\r\n        Object.defineProperty(self.intf, 'data', {\r\n            get: function dataGetter() {\r\n                return self.data;\r\n            },\r\n            set: function dataSetter(value) {\r\n                self.etl(value, function () {\r\n                    self.changes = [];\r\n                    self.createNewRowData();\r\n                    if (self.attributes.autoResizeColumns && self.data.length > 0\r\n                            && self.storedSettings === undefined) {\r\n                        self.autosize();\r\n                    }\r\n                    // set the header column to fit the numbers in it\r\n                    self.fitColumnToValues('cornerCell', true);\r\n                    self.createRowOrders();\r\n                    self.tryLoadStoredSettings();\r\n                    self.dispatchEvent('datachanged', {data: self.data});\r\n                    self.resize(true);\r\n                });\r\n            }\r\n        });\r\n        self.initScrollBox = function () {\r\n            var sHeight = 0,\r\n                sWidth = 0,\r\n                scrollTop = 0,\r\n                scrollLeft = 0,\r\n                scrollHeight = 0,\r\n                scrollWidth = 0,\r\n                scrollBoxHeight = 20,\r\n                scrollBoxWidth = 20;\r\n            function setScrollTop(value, preventScrollEvent) {\r\n                if (isNaN(value)) {\r\n                    throw new Error('ScrollTop value must be a number');\r\n                }\r\n                if (value < 0) {\r\n                    value = 0;\r\n                }\r\n                if (value > scrollHeight) {\r\n                    value = scrollHeight;\r\n                }\r\n                if (scrollHeight < 0) {\r\n                    value = 0;\r\n                }\r\n                scrollTop = value;\r\n                if (!preventScrollEvent) {\r\n                    self.scroll();\r\n                }\r\n            }\r\n            function setScrollLeft(value, preventScrollEvent) {\r\n                if (isNaN(value)) {\r\n                    throw new Error('ScrollLeft value must be a number');\r\n                }\r\n                if (value < 0) {\r\n                    value = 0;\r\n                }\r\n                if (value > scrollWidth) {\r\n                    value = scrollWidth;\r\n                }\r\n                if (scrollWidth < 0) {\r\n                    value = 0;\r\n                }\r\n                scrollLeft = value;\r\n                if (!preventScrollEvent) {\r\n                    self.scroll();\r\n                }\r\n            }\r\n            self.scrollBox.toString = function () {\r\n                return '{\"width\": ' + scrollWidth.toFixed(2)\r\n                    + ', \"height\": ' + scrollHeight.toFixed(2)\r\n                    + ', \"left\": ' + scrollLeft.toFixed(2)\r\n                    + ', \"top\": ' + scrollTop.toFixed(2)\r\n                    + ', \"widthRatio\": ' + self.scrollBox.widthBoxRatio.toFixed(5)\r\n                    + ', \"heightRatio\": ' + self.scrollBox.heightBoxRatio.toFixed(5) + '}';\r\n            };\r\n            self.scrollBox.scrollTo = function (x, y, supressDrawEvent) {\r\n                setScrollLeft(x, true);\r\n                setScrollTop(y, supressDrawEvent);\r\n            };\r\n            Object.defineProperty(self.scrollBox, 'scrollBoxHeight', {\r\n                get: function () {\r\n                    return scrollBoxHeight;\r\n                },\r\n                set: function (value) {\r\n                    scrollBoxHeight = value;\r\n                }\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'scrollBoxWidth', {\r\n                get: function () {\r\n                    return scrollBoxWidth;\r\n                },\r\n                set: function (value) {\r\n                    scrollBoxWidth = value;\r\n                }\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'height', {\r\n                get: function () {\r\n                    return sHeight;\r\n                },\r\n                set: function (value) {\r\n                    sHeight = value;\r\n                }\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'width', {\r\n                get: function () {\r\n                    return sWidth;\r\n                },\r\n                set: function (value) {\r\n                    sWidth = value;\r\n                }\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'scrollTop', {\r\n                get: function () {\r\n                    return scrollTop;\r\n                },\r\n                set: setScrollTop\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'scrollLeft', {\r\n                get: function () {\r\n                    return scrollLeft;\r\n                },\r\n                set: setScrollLeft\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'scrollHeight', {\r\n                get: function () {\r\n                    return scrollHeight;\r\n                },\r\n                set: function (value) {\r\n                    if (scrollTop > value) {\r\n                        scrollTop = Math.max(value, 0);\r\n                    }\r\n                    scrollHeight = value;\r\n                }\r\n            });\r\n            Object.defineProperty(self.scrollBox, 'scrollWidth', {\r\n                get: function () {\r\n                    return scrollWidth;\r\n                },\r\n                set: function (value) {\r\n                    if (scrollLeft > value) {\r\n                        scrollLeft = Math.max(value, 0);\r\n                    }\r\n                    scrollWidth = value;\r\n                }\r\n            });\r\n        };\r\n        return;\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/intf.js\n// module id = 6\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false, Event: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        var zIndexTop, hoverScrollTimeout, autoCompleteContext;\r\n        function applyContextItemStyle(contextItemContainer) {\r\n            self.createInlineStyle(contextItemContainer, 'canvas-datagrid-context-menu-item' + (self.mobile ? '-mobile' : ''));\r\n            contextItemContainer.addEventListener('mouseover', function () {\r\n                self.createInlineStyle(contextItemContainer, 'canvas-datagrid-context-menu-item:hover');\r\n            });\r\n            contextItemContainer.addEventListener('mouseout', function () {\r\n                self.createInlineStyle(contextItemContainer, 'canvas-datagrid-context-menu-item');\r\n            });\r\n        }\r\n        function createContextMenu(ev, pos, items, parentContextMenu) {\r\n            var container = document.createElement('div'),\r\n                upArrow = document.createElement('div'),\r\n                downArrow = document.createElement('div'),\r\n                children = [],\r\n                selectedIndex = -1,\r\n                intf = {},\r\n                rect;\r\n            if (!Array.isArray(items)) { throw new Error('createContextMenu expects an array.'); }\r\n            function createItems() {\r\n                items.forEach(function (item) {\r\n                    var contextItemContainer = document.createElement('div'),\r\n                        childMenuArrow;\r\n                    function removeChildContext(e) {\r\n                        if (e.relatedTarget === container\r\n                                || item.contextMenu.container === e.relatedTarget\r\n                                || childMenuArrow === e.relatedTarget\r\n                                || (contextItemContainer === e.relatedTarget)\r\n                                || item.contextMenu.container.contains(e.relatedTarget)\r\n                                ) { return; }\r\n                        item.contextMenu.dispose();\r\n                        children.splice(children.indexOf(item.contextMenu), 1);\r\n                        item.contextMenu = undefined;\r\n                        contextItemContainer.removeEventListener('mouseout', removeChildContext);\r\n                        container.removeEventListener('mouseout', removeChildContext);\r\n                        contextItemContainer.setAttribute('contextOpen', '0');\r\n                        contextItemContainer.setAttribute('opening', '0');\r\n                    }\r\n                    function contextAddCallback(items) {\r\n                        // check yet again if the user hasn't moved off\r\n                        if (contextItemContainer.getAttribute('opening') !== '1' ||\r\n                                contextItemContainer.getAttribute('contextOpen') === '1') {\r\n                            return;\r\n                        }\r\n                        var cPos = contextItemContainer.getBoundingClientRect();\r\n                        cPos = {\r\n                            left: cPos.left + self.style.childContextMenuMarginLeft + container.offsetWidth,\r\n                            top: cPos.top + self.style.childContextMenuMarginTop,\r\n                            bottom: cPos.bottom,\r\n                            right: cPos.right\r\n                        };\r\n                        item.contextMenu = createContextMenu(ev, cPos, items, intf);\r\n                        contextItemContainer.setAttribute('contextOpen', '1');\r\n                        contextItemContainer.addEventListener('mouseout', removeChildContext);\r\n                        container.addEventListener('mouseout', removeChildContext);\r\n                        children.push(item.contextMenu);\r\n                    }\r\n                    function createChildContext() {\r\n                        var i;\r\n                        if (contextItemContainer.getAttribute('contextOpen') === '1') {\r\n                            return;\r\n                        }\r\n                        contextItemContainer.setAttribute('opening', '1');\r\n                        if (typeof item.items === 'function') {\r\n                            i  = item.items.apply(intf, [function (items) {\r\n                                contextAddCallback(items);\r\n                            }]);\r\n                            if (i !== undefined && Array.isArray(i)) {\r\n                                contextAddCallback(i);\r\n                            }\r\n                            return;\r\n                        }\r\n                        contextAddCallback(item.items);\r\n                    }\r\n                    function addItem(item) {\r\n                        function addContent(content) {\r\n                            if (content === null) { return; }\r\n                            if (typeof content === 'function') {\r\n                                return addContent(content(ev));\r\n                            }\r\n                            if (typeof content === 'object') {\r\n                                contextItemContainer.appendChild(content);\r\n                                return;\r\n                            }\r\n                            applyContextItemStyle(contextItemContainer);\r\n                            contextItemContainer.innerHTML = content;\r\n                            return;\r\n                        }\r\n                        addContent(item.title);\r\n                        item.contextItemContainer = contextItemContainer;\r\n                        if ((item.items && item.items.length > 0) || typeof item.items === 'function') {\r\n                            childMenuArrow = document.createElement('div');\r\n                            self.createInlineStyle(childMenuArrow, 'canvas-datagrid-context-child-arrow');\r\n                            childMenuArrow.innerHTML = self.style.childContextMenuArrowHTML;\r\n                            contextItemContainer.appendChild(childMenuArrow);\r\n                            contextItemContainer.addEventListener('mouseover', createChildContext);\r\n                            contextItemContainer.addEventListener('mouseout', function () {\r\n                                contextItemContainer.setAttribute('opening', '0');\r\n                            });\r\n                        }\r\n                        if (item.click) {\r\n                            contextItemContainer.addEventListener('click', function (ev) {\r\n                                item.click.apply(self, [ev]);\r\n                            });\r\n                        }\r\n                    }\r\n                    addItem(item);\r\n                    container.appendChild(contextItemContainer);\r\n                });\r\n            }\r\n            function clickIndex(idx) {\r\n                items[idx].contextItemContainer.dispatchEvent(new Event('click'));\r\n            }\r\n            function checkArrowVisibility() {\r\n                if (container.scrollTop > 0) {\r\n                    self.parentDOMNode.appendChild(upArrow);\r\n                } else if (upArrow.parentNode) {\r\n                    upArrow.parentNode.removeChild(upArrow);\r\n                }\r\n                if (container.scrollTop >= container.scrollHeight - container.offsetHeight && downArrow.parentNode) {\r\n                    downArrow.parentNode.removeChild(downArrow);\r\n                } else if (container.scrollHeight - container.offsetHeight > 0\r\n                        && !(container.scrollTop >= container.scrollHeight - container.offsetHeight)) {\r\n                    self.parentDOMNode.appendChild(downArrow);\r\n                }\r\n            }\r\n            function startHoverScroll(type) {\r\n                return function t() {\r\n                    var a = self.attributes.contextHoverScrollAmount;\r\n                    if (type === 'up' && container.scrollTop === 0) { return; }\r\n                    if (type === 'down' && container.scrollTop === container.scrollHeight) { return; }\r\n                    container.scrollTop += (type === 'up' ? -a : a);\r\n                    hoverScrollTimeout = setTimeout(t, self.attributes.contextHoverScrollRateMs, type);\r\n                };\r\n            }\r\n            function endHoverScroll(type) {\r\n                return function () {\r\n                    clearTimeout(hoverScrollTimeout);\r\n                };\r\n            }\r\n            function init() {\r\n                var loc = {},\r\n                    s = self.scrollOffset(self.canvas);\r\n                if (zIndexTop === undefined) {\r\n                    zIndexTop = self.style.contextMenuZIndex;\r\n                }\r\n                createItems();\r\n                self.createInlineStyle(container, 'canvas-datagrid-context-menu' + (self.mobile ? '-mobile' : ''));\r\n                loc.x = pos.left - s.left;\r\n                loc.y = pos.top - s.top;\r\n                loc.height = 0;\r\n                zIndexTop += 1;\r\n                container.style.position = 'absolute';\r\n                upArrow.style.color = self.style.contextMenuArrowColor;\r\n                downArrow.style.color = self.style.contextMenuArrowColor;\r\n                [upArrow, downArrow].forEach(function (el) {\r\n                    el.style.textAlign = 'center';\r\n                    el.style.position = 'absolute';\r\n                    el.style.zIndex = zIndexTop + 1;\r\n                });\r\n                container.style.zIndex = zIndexTop;\r\n                if (parentContextMenu && parentContextMenu.inputDropdown) {\r\n                    container.style.maxHeight = window.innerHeight - loc.y - self.style.autocompleteBottomMargin + 'px';\r\n                    container.style.minWidth = pos.width + 'px';\r\n                    loc.y += pos.height;\r\n                }\r\n                if (self.mobile) {\r\n                    container.style.width = pos.width + 'px';\r\n                }\r\n                container.style.left = loc.x + 'px';\r\n                container.style.top = loc.y + 'px';\r\n                container.addEventListener('scroll', checkArrowVisibility);\r\n                container.addEventListener('wheel', function (e) {\r\n                    if (self.hasFocus) {\r\n                        container.scrollTop += e.deltaY;\r\n                        container.scrollLeft += e.deltaX;\r\n                    }\r\n                    checkArrowVisibility();\r\n                });\r\n                upArrow.innerHTML = self.style.contextMenuArrowUpHTML;\r\n                downArrow.innerHTML = self.style.contextMenuArrowDownHTML;\r\n                container.appendChild(upArrow);\r\n                document.body.appendChild(downArrow);\r\n                document.body.appendChild(container);\r\n                rect = container.getBoundingClientRect();\r\n                // TODO: fix !(parentContextMenu && parentContextMenu.inputDropdown) state (autocomplete)\r\n                if (rect.bottom > window.innerHeight) {\r\n                    if (!(parentContextMenu && parentContextMenu.inputDropdown)) {\r\n                        loc.y -= (rect.bottom + self.style.contextMenuWindowMargin) - window.innerHeight;\r\n                    }\r\n                    if (loc.y < 0) { loc.y = self.style.contextMenuWindowMargin; }\r\n                    if (container.offsetHeight > window.innerHeight - self.style.contextMenuWindowMargin) {\r\n                        container.style.height = window.innerHeight - (self.style.contextMenuWindowMargin * 2) + 'px';\r\n                    }\r\n                }\r\n                if (rect.right > window.innerWidth) {\r\n                    loc.x -= rect.right - window.innerWidth + self.style.contextMenuWindowMargin;\r\n                }\r\n                if (loc.x < 0) { loc.x = self.style.contextMenuWindowMargin; }\r\n                if (loc.y < 0) { loc.y = self.style.contextMenuWindowMargin; }\r\n                container.style.left = loc.x + 'px';\r\n                container.style.top = loc.y + 'px';\r\n                rect = container.getBoundingClientRect();\r\n                upArrow.style.top = rect.top + 'px';\r\n                downArrow.style.top = rect.top + rect.height - downArrow.offsetHeight + 'px';\r\n                upArrow.style.left = rect.left + 'px';\r\n                downArrow.style.left = rect.left + 'px';\r\n                downArrow.style.width = container.offsetWidth + 'px';\r\n                upArrow.style.width = container.offsetWidth + 'px';\r\n                downArrow.addEventListener('mouseover', startHoverScroll('down'));\r\n                downArrow.addEventListener('mouseout', endHoverScroll('down'));\r\n                upArrow.addEventListener('mouseover', startHoverScroll('up'));\r\n                upArrow.addEventListener('mouseout', endHoverScroll('up'));\r\n                checkArrowVisibility();\r\n            }\r\n            intf.parentGrid = self.intf;\r\n            intf.parentContextMenu = parentContextMenu;\r\n            intf.container = container;\r\n            init();\r\n            intf.clickIndex = clickIndex;\r\n            intf.rect = rect;\r\n            intf.items = items;\r\n            intf.upArrow = upArrow;\r\n            intf.downArrow = downArrow;\r\n            intf.dispose = function () {\r\n                clearTimeout(hoverScrollTimeout);\r\n                children.forEach(function (c) {\r\n                    c.dispose();\r\n                });\r\n                [downArrow, upArrow, container].forEach(function (el) {\r\n                    if (el.parentNode) { el.parentNode.removeChild(el); }\r\n                });\r\n            };\r\n            Object.defineProperty(intf, 'selectedIndex', {\r\n                get: function () {\r\n                    return selectedIndex;\r\n                },\r\n                set: function (value) {\r\n                    if (typeof value !== 'number' || isNaN(value || !isFinite(value))) {\r\n                        throw new Error('Context menu selected index must be a sane number.');\r\n                    }\r\n                    selectedIndex = value;\r\n                    if (selectedIndex > items.length - 1) {\r\n                        selectedIndex = items.length - 1;\r\n                    }\r\n                    if (selectedIndex < 0) {\r\n                        selectedIndex = 0;\r\n                    }\r\n                    items.forEach(function (item, index) {\r\n                        if (index === selectedIndex) {\r\n                            return self.createInlineStyle(item.contextItemContainer, 'canvas-datagrid-context-menu-item:hover');\r\n                        }\r\n                        self.createInlineStyle(item.contextItemContainer, 'canvas-datagrid-context-menu-item');\r\n                    });\r\n                }\r\n            });\r\n            return intf;\r\n        }\r\n        function createFilterContextMenuItems(e) {\r\n            var filterContainer = document.createElement('div'),\r\n                filterLabel = document.createElement('div'),\r\n                filterAutoCompleteButton = document.createElement('button'),\r\n                filterInput = document.createElement('input'),\r\n                n = e.cell && e.cell.header ? e.cell.header.title || e.cell.header.name : '',\r\n                autoCompleteItems,\r\n                iRect;\r\n            function checkRegExpErrorState() {\r\n                filterInput.style.background = self.style.contextFilterInputBackground;\r\n                filterInput.style.color = self.style.contextFilterInputColor;\r\n                if (self.invalidFilterRegEx) {\r\n                    filterInput.style.background = self.style.contextFilterInvalidRegExpBackground;\r\n                    filterInput.style.color = self.style.contextFilterInvalidRegExpColor;\r\n                }\r\n            }\r\n            function fillAutoComplete() {\r\n                var count = 0;\r\n                autoCompleteItems = {};\r\n                self.data.forEach(function (row) {\r\n                    var value = row[e.cell.header.name];\r\n                    if (autoCompleteItems[value] || count > self.attributes.maxAutoCompleteItems) { return; }\r\n                    count += 1;\r\n                    autoCompleteItems[value] = {\r\n                        title: self.formatters[e.cell.header.type || 'string']({ cell: { value: value }}),\r\n                        click: function (e) {\r\n                            filterInput.value = value;\r\n                            e.stopPropagation();\r\n                            filterInput.dispatchEvent(new Event('keyup'));\r\n                            self.disposeAutocomplete();\r\n                            return;\r\n                        }\r\n                    };\r\n                });\r\n                autoCompleteItems = Object.keys(autoCompleteItems).map(function (key) {\r\n                    return autoCompleteItems[key];\r\n                });\r\n            }\r\n            function createAutoCompleteContext(ev) {\r\n                if (ev && [40, 38, 13, 9].indexOf(ev.keyCode) !== -1) { return; }\r\n                fillAutoComplete();\r\n                iRect = filterInput.getBoundingClientRect();\r\n                if (autoCompleteContext) {\r\n                    autoCompleteContext.dispose();\r\n                    autoCompleteContext = undefined;\r\n                }\r\n                autoCompleteContext = createContextMenu(e, {\r\n                    left: iRect.left,\r\n                    top: iRect.top,\r\n                    right: iRect.right,\r\n                    bottom: iRect.bottom,\r\n                    height: iRect.height,\r\n                    width: iRect.width\r\n                }, autoCompleteItems, {inputDropdown: true});\r\n                autoCompleteContext.selectedIndex = 0;\r\n            }\r\n            self.createInlineStyle(filterLabel, 'canvas-datagrid-context-menu-label');\r\n            self.createInlineStyle(filterAutoCompleteButton, 'canvas-datagrid-context-menu-filter-button');\r\n            self.createInlineStyle(filterInput, 'canvas-datagrid-context-menu-filter-input');\r\n            checkRegExpErrorState();\r\n            filterInput.onclick = self.disposeAutocomplete;\r\n            filterInput.addEventListener('keydown', function (e) {\r\n                //down\r\n                if (e.keyCode === 40) {\r\n                    autoCompleteContext.selectedIndex += 1;\r\n                }\r\n                //up\r\n                if (e.keyCode === 38) {\r\n                    autoCompleteContext.selectedIndex -= 1;\r\n                }\r\n                //enter\r\n                if (e.keyCode === 13) {\r\n                    autoCompleteContext.clickIndex(autoCompleteContext.selectedIndex);\r\n                    self.disposeContextMenu();\r\n                }\r\n                //tab\r\n                if (e.keyCode === 9) {\r\n                    autoCompleteContext.clickIndex(autoCompleteContext.selectedIndex);\r\n                    e.preventDefault();\r\n                }\r\n                //esc\r\n                if (e.keyCode === 27) {\r\n                    self.disposeContextMenu();\r\n                }\r\n            });\r\n            filterInput.addEventListener('keyup', function () {\r\n                self.setFilter(e.cell.header.name, filterInput.value);\r\n            });\r\n            filterInput.addEventListener('keyup', createAutoCompleteContext);\r\n            ['focus', 'blur', 'keydown', 'keyup', 'change'].forEach(function (en) {\r\n                filterInput.addEventListener(en, checkRegExpErrorState);\r\n            });\r\n            filterInput.value = e.cell.header ? self.columnFilters[e.cell.header.name] || '' : '';\r\n            filterLabel.innerHTML = self.attributes.filterOptionText.replace(/%s/g, n);\r\n            filterAutoCompleteButton.onclick = function () {\r\n                if (autoCompleteContext) {\r\n                    return self.disposeAutocomplete();\r\n                }\r\n                createAutoCompleteContext();\r\n            };\r\n            filterAutoCompleteButton.innerHTML = self.style.contextFilterButtonHTML;\r\n            filterContainer.addEventListener('click', function (e) {\r\n                return e.stopPropagation();\r\n            });\r\n            filterContainer.appendChild(filterLabel);\r\n            filterContainer.appendChild(filterInput);\r\n            filterContainer.appendChild(filterAutoCompleteButton);\r\n            e.items.push({\r\n                title: filterContainer\r\n            });\r\n            if (Object.keys(self.columnFilters).length) {\r\n                Object.keys(self.columnFilters).forEach(function (cf) {\r\n                    var h = self.getHeaderByName(cf);\r\n                    e.items.push({\r\n                        title: self.attributes.removeFilterOptionText.replace(/%s/g, h.title || h.name),\r\n                        click: function removeFilterClick(e) {\r\n                            e.preventDefault();\r\n                            self.setFilter(cf, '');\r\n                            self.controlInput.focus();\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        function addDefaultContextMenuItem(e) {\r\n            var isNormalCell = !(e.cell.isBackground || e.cell.isColumnHeaderCellCap\r\n                    || e.cell.isScrollBar || e.cell.isCorner || e.cell.isRowHeader)\r\n                    && e.cell.header;\r\n            if (self.attributes.showFilter && isNormalCell) {\r\n                createFilterContextMenuItems(e);\r\n            }\r\n            if (self.attributes.showCopy\r\n                    && self.selections.reduce(function (p, r) {\r\n                        return p + r.length;\r\n                    }, 0) > 0) {\r\n                e.items.push({\r\n                    title: self.attributes.copyText,\r\n                    click: function () {\r\n                        document.execCommand('copy');\r\n                        self.disposeContextMenu();\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n            }\r\n            if (self.attributes.showPaste && self.clipBoardData) {\r\n                e.items.push({\r\n                    title: self.attributes.pasteText,\r\n                    click: function () {\r\n                        self.paste(self.clipBoardData, e.cell.columnIndex, e.cell.rowIndex);\r\n                        self.draw();\r\n                    }\r\n                });\r\n            }\r\n            if (self.attributes.showColumnSelector) {\r\n                e.items.push({\r\n                    title: self.attributes.columnSelectorText,\r\n                    items: function () {\r\n                        var d = [];\r\n                        self.getSchema().forEach(function (column) {\r\n                            function toggleColumnVisibility(e) {\r\n                                column.hidden = !column.hidden;\r\n                                self.dispatchEvent('togglecolumn', {column: column, hidden: column.hidden});\r\n                                e.preventDefault();\r\n                                self.stopPropagation(e);\r\n                                self.disposeContextMenu();\r\n                                self.resize(true);\r\n                                self.setStorageData();\r\n                            }\r\n                            var el = document.createElement('div');\r\n                            applyContextItemStyle(el);\r\n                            el.addEventListener('touchstart', toggleColumnVisibility);\r\n                            el.addEventListener('click', toggleColumnVisibility);\r\n                            el.innerHTML = (column.hidden ? self.attributes.columnSelectorHiddenText\r\n                                    : self.attributes.columnSelectorVisibleText)\r\n                                    + (column.title || column.name);\r\n                            d.push({\r\n                                title: el\r\n                            });\r\n                        });\r\n                        return d;\r\n                    }\r\n                });\r\n                if (e.cell && e.cell.header && e.cell.columnIndex > -1) {\r\n                    e.items.push({\r\n                        title: self.attributes.hideColumnText\r\n                            .replace(/%s/ig, e.cell.header.title || e.cell.header.name),\r\n                        click: function (ev) {\r\n                            self.getSchema()[e.cell.columnIndex].hidden = true;\r\n                            ev.preventDefault();\r\n                            self.stopPropagation(ev);\r\n                            self.disposeContextMenu();\r\n                            self.setStorageData();\r\n                            setTimeout(function () { self.resize(true); }, 10);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            if (self.attributes.saveAppearance && self.attributes.showClearSettingsOption\r\n                    && (Object.keys(self.sizes.rows).length > 0\r\n                        || Object.keys(self.sizes.columns).length > 0)) {\r\n                e.items.push({\r\n                    title: self.attributes.clearSettingsOptionText,\r\n                    click: function (e) {\r\n                        e.preventDefault();\r\n                        self.sizes.rows = {};\r\n                        self.sizes.columns = {};\r\n                        self.createRowOrders();\r\n                        self.createColumnOrders();\r\n                        self.storedSettings = undefined;\r\n                        self.dispatchEvent('resizecolumn', {columnWidth: self.style.cellWidth});\r\n                        self.dispatchEvent('resizerow', {cellHeight: self.style.cellHeight});\r\n                        self.setStorageData();\r\n                        self.resize(true);\r\n                        self.disposeContextMenu();\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n            }\r\n            if (self.attributes.allowSorting && self.attributes.showOrderByOption && isNormalCell) {\r\n                e.items.push({\r\n                    title: self.attributes.showOrderByOptionTextAsc.replace('%s', e.cell.header.title || e.cell.header.name),\r\n                    click: function (ev) {\r\n                        ev.preventDefault();\r\n                        self.order(e.cell.header.name, 'asc');\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n                e.items.push({\r\n                    title: self.attributes.showOrderByOptionTextDesc.replace('%s', e.cell.header.title || e.cell.header.name),\r\n                    click: function (ev) {\r\n                        ev.preventDefault();\r\n                        self.order(e.cell.header.name, 'desc');\r\n                        self.disposeContextMenu();\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        self.disposeAutocomplete = function () {\r\n            if (autoCompleteContext) {\r\n                autoCompleteContext.dispose();\r\n                autoCompleteContext = undefined;\r\n            }\r\n        };\r\n        self.disposeContextMenu = function () {\r\n            document.removeEventListener('click', self.disposeContextMenu);\r\n            zIndexTop = self.style.contextMenuZIndex;\r\n            self.disposeAutocomplete();\r\n            if (self.contextMenu) {\r\n                self.contextMenu.dispose();\r\n            }\r\n            self.contextMenu = undefined;\r\n        };\r\n        self.contextmenuEvent = function (e, overridePos) {\r\n            if (!self.hasFocus && e.target !== self.canvas) {\r\n                return;\r\n            }\r\n            function createDiposeEvent() {\r\n                requestAnimationFrame(function () {\r\n                    document.addEventListener('click', self.disposeContextMenu);\r\n                    document.removeEventListener('mouseup', createDiposeEvent);\r\n                });\r\n            }\r\n            var contextPosition,\r\n                items = [],\r\n                pos = overridePos || self.getLayerPos(e),\r\n                ev = {\r\n                    NativeEvent: e,\r\n                    cell: self.getCellAt(pos.x, pos.y),\r\n                    items: items\r\n                };\r\n            if (!ev.cell.isGrid) {\r\n                addDefaultContextMenuItem(ev);\r\n            }\r\n            if (self.dispatchEvent('contextmenu', ev)) {\r\n                return;\r\n            }\r\n            if (!ev.cell.isGrid) {\r\n                if (self.contextMenu) {\r\n                    self.disposeContextMenu();\r\n                }\r\n                contextPosition = {\r\n                    left: pos.x + pos.rect.left\r\n                        + self.style.contextMenuMarginLeft + self.canvasOffsetLeft,\r\n                    top: pos.y + pos.rect.top\r\n                        + self.style.contextMenuMarginTop + self.canvasOffsetTop,\r\n                    right: ev.cell.width + ev.cell.x + pos.rect.left,\r\n                    bottom: ev.cell.height + ev.cell.y + pos.rect.top,\r\n                    height: ev.cell.height,\r\n                    width: ev.cell.width\r\n                };\r\n                if (self.mobile) {\r\n                    contextPosition.left = self.style.mobileContextMenuMargin + 'px';\r\n                    contextPosition.width = self.width - (self.style.mobileContextMenuMargin * 2) + 'px';\r\n                }\r\n                self.contextMenu = createContextMenu(ev, contextPosition, items);\r\n                document.addEventListener('mouseup', createDiposeEvent);\r\n                e.preventDefault();\r\n            }\r\n        };\r\n        return;\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/contextMenu.js\n// module id = 7\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        self.getClippingRect = function (ele) {\r\n            var boundingRect = self.position(self.parentNode),\r\n                eleRect = self.position(ele),\r\n                s = self.scrollOffset(self.canvas),\r\n                clipRect = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    h: 0,\r\n                    w: 0\r\n                },\r\n                parentRect = {\r\n                    x: -Infinity,\r\n                    y: -Infinity,\r\n                    h: Infinity,\r\n                    w: Infinity\r\n                },\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n                rowHeaderCellWidth = self.getRowHeaderCellWidth();\r\n            boundingRect.top -= s.top;\r\n            boundingRect.left -= s.left;\r\n            eleRect.top -= s.top;\r\n            eleRect.left -= s.left;\r\n            clipRect.h = boundingRect.top + boundingRect.height - ele.offsetTop - self.style.scrollBarWidth;\r\n            clipRect.w = boundingRect.left + boundingRect.width - ele.offsetLeft - self.style.scrollBarWidth;\r\n            clipRect.x = boundingRect.left + (eleRect.left * -1) + rowHeaderCellWidth;\r\n            clipRect.y = boundingRect.top + (eleRect.top * -1) + columnHeaderCellHeight;\r\n            return {\r\n                x: clipRect.x > parentRect.x ? clipRect.x : parentRect.x,\r\n                y: clipRect.y > parentRect.y ? clipRect.y : parentRect.y,\r\n                h: clipRect.h < parentRect.h ? clipRect.h : parentRect.h,\r\n                w: clipRect.w < parentRect.w ? clipRect.w : parentRect.w\r\n            };\r\n        };\r\n        self.clipElement = function (ele) {\r\n            var clipRect = self.getClippingRect(ele);\r\n            if (clipRect.w < 0) { clipRect.w = 0; }\r\n            if (clipRect.h < 0) { clipRect.h = 0; }\r\n            ele.style.clip = 'rect('\r\n                + clipRect.y + 'px,'\r\n                + clipRect.w + 'px,'\r\n                + clipRect.h + 'px,'\r\n                + clipRect.x + 'px'\r\n                + ')';\r\n            // INFO https://developer.mozilla.org/en-US/docs/Web/CSS/clip\r\n            // clip has been \"deprecated\" for clipPath.  Of course nothing but chrome\r\n            // supports clip path, so we'll keep using clip until someday clipPath becomes\r\n            // more widely support.  The code below works correctly, but setting clipPath and clip\r\n            // at the same time has undesirable results.\r\n            // ele.style.clipPath = 'polygon('\r\n            //     + clipRect.x + 'px ' + clipRect.y + 'px,'\r\n            //     + clipRect.x + 'px ' + clipRect.h + 'px,'\r\n            //     + clipRect.w + 'px ' + clipRect.h + 'px,'\r\n            //     + clipRect.w + 'px ' + clipRect.y + 'px'\r\n            //     + ')';\r\n        };\r\n        self.scrollOffset = function (e) {\r\n            var x = 0, y = 0, scrollingElement = document.scrollingElement || { scrollLeft: 0, scrollTop: 0 };\r\n            while (e.parentNode && e.nodeName !== 'CANVAS-DATAGRID' && e !== self.intf) {\r\n                if (e.nodeType !== 'canvas-datagrid-tree'\r\n                        && e.nodeType !== 'canvas-datagrid-cell') {\r\n                    x -= e.scrollLeft;\r\n                    y -= e.scrollTop;\r\n                }\r\n                e = e.parentNode;\r\n            }\r\n            return {\r\n                left: x - scrollingElement.scrollLeft,\r\n                top: y - scrollingElement.scrollTop\r\n            };\r\n        };\r\n        self.resizeEditInput = function () {\r\n            if (self.input && self.input.editCell) {\r\n                var pos = self.canvas.getBoundingClientRect(),\r\n                    s = self.scrollOffset(self.intf),\r\n                    bm = self.style.gridBorderCollapse === 'collapse' ? 1 : 2,\r\n                    borderWidth = (self.style.cellBorderWidth * bm),\r\n                    cell = self.getVisibleCellByIndex(self.input.editCell.columnIndex, self.input.editCell.rowIndex)\r\n                        || {x: -100, y: -100, height: 0, width: 0};\r\n                if (self.mobile) {\r\n                    self.input.style.left = '0';\r\n                    self.input.style.top = (self.height - self.style.mobileEditInputHeight) - borderWidth - 1 + 'px';\r\n                    self.input.style.height = self.style.mobileEditInputHeight + 'px';\r\n                    self.input.style.width = self.width - borderWidth - 1 + 'px';\r\n                    return;\r\n                }\r\n                self.input.style.left = pos.left + cell.x + self.canvasOffsetLeft - s.left + 'px';\r\n                self.input.style.top = pos.top + cell.y - self.style.cellBorderWidth + self.canvasOffsetTop - s.top + 'px';\r\n                self.input.style.height = cell.height - borderWidth + 'px';\r\n                self.input.style.width = cell.width - self.style.cellPaddingLeft + 'px';\r\n                self.clipElement(self.input);\r\n            }\r\n        };\r\n        self.position = function (e, ignoreScrollOffset) {\r\n            var x = 0, y = 0, s = e, h, w;\r\n            while (e.offsetParent && e.nodeName !== 'CANVAS-DATAGRID') {\r\n                x += e.offsetLeft;\r\n                y += e.offsetTop;\r\n                h = e.offsetHeight;\r\n                w = e.offsetWidth;\r\n                e = e.offsetParent;\r\n            }\r\n            if (ignoreScrollOffset) {\r\n                return {left: x, top: y, height: h, width: w};\r\n            }\r\n            e = s;\r\n            s = self.scrollOffset(e);\r\n            return { left: x + s.left, top: y + s.top, height: h, width: w };\r\n        };\r\n        self.getLayerPos = function (e) {\r\n            var rect = self.canvas.getBoundingClientRect(),\r\n                pos = {\r\n                    x: e.clientX - rect.left,\r\n                    y: e.clientY - rect.top\r\n                };\r\n            if (self.isChildGrid) {\r\n                pos.x -= self.canvasOffsetLeft;\r\n                pos.y -= self.canvasOffsetTop;\r\n            }\r\n            return {\r\n                x: pos.x,\r\n                y: pos.y,\r\n                rect: rect\r\n            };\r\n        };\r\n        /**\r\n         * Ends editing, optionally aborting the edit.\r\n         * @memberof canvasDatagrid\r\n         * @name endEdit\r\n         * @method\r\n         * @param {boolean} abort When true, abort the edit.\r\n         */\r\n        self.endEdit = function (abort) {\r\n            var cell = self.input.editCell,\r\n                y = cell.rowIndex;\r\n            function abortEdit() {\r\n                abort = true;\r\n            }\r\n            if (self.dispatchEvent('beforeendedit', {\r\n                    cell: cell,\r\n                    newValue: self.input.value,\r\n                    oldValue: cell.value,\r\n                    abort: abortEdit,\r\n                    input: self.input\r\n                })) { return false; }\r\n            if (self.input.value !== cell.value && !abort) {\r\n                self.changes[y] = self.changes[y] || {};\r\n                self.changes[y][cell.header.name] = self.input.value;\r\n                if (!cell.data) {\r\n                    self.data[cell.rowIndex] = {};\r\n                    cell.data = self.data[cell.rowIndex];\r\n                }\r\n                cell.data[cell.header.name] = self.input.value;\r\n                if (y === self.data.length) {\r\n                    if (self.dispatchEvent('newrow', {\r\n                            value: self.input.value,\r\n                            defaultValue: cell.value,\r\n                            aborted: abort,\r\n                            cell: cell,\r\n                            input: self.input\r\n                        })) { return false; }\r\n                    self.addRow(cell.data);\r\n                    self.createNewRowData();\r\n                }\r\n                self.draw(true);\r\n            }\r\n            if (self.input.parentNode) {\r\n                self.input.parentNode.removeChild(self.input);\r\n            }\r\n            self.intf.focus();\r\n            self.dispatchEvent('endedit', {\r\n                cell: cell,\r\n                value: self.input.value,\r\n                aborted: abort,\r\n                input: self.input\r\n            });\r\n            self.input = undefined;\r\n            return true;\r\n        };\r\n        /**\r\n         * Begins editing at cell x, row y.\r\n         * @memberof canvasDatagrid\r\n         * @name beginEditAt\r\n         * @method\r\n         * @param {number} x The column index of the cell to edit.\r\n         * @param {number} y The row index of the cell to edit.\r\n         */\r\n        self.beginEditAt = function (x, y, NativeEvent) {\r\n            if (!self.attributes.editable) { return; }\r\n            if (self.input) {\r\n                self.endEdit();\r\n            }\r\n            var cell = self.getVisibleCellByIndex(x, y),\r\n                s = self.getSchema(),\r\n                adjacentCells,\r\n                enumItems,\r\n                enu,\r\n                option,\r\n                valueInEnum;\r\n            if (!(cell && cell.header)) { return; }\r\n            //HACK for IE10, does not like literal enum\r\n            enu = cell.header['enum'];\r\n            if (self.dispatchEvent('beforebeginedit', {cell: cell, NativeEvent: NativeEvent})) { return false; }\r\n            self.scrollIntoView(x, y);\r\n            self.setActiveCell(x, y);\r\n            adjacentCells = self.getAdjacentCells();\r\n            if (enu) {\r\n                self.input = document.createElement('select');\r\n            } else {\r\n                self.input = document.createElement(self.attributes.multiLine\r\n                    ? 'textarea' : 'input');\r\n            }\r\n            cell = self.getVisibleCellByIndex(x, y);\r\n            //HACK on mobile devices sometimes edit can begin without the cell being in view, I don't know how.\r\n            if (!cell) { return; }\r\n            if (enu) {\r\n                // add enums\r\n                if (typeof enu === 'function') {\r\n                    enumItems = enu.apply(self.intf, [{cell: cell}]);\r\n                } else if (Array.isArray(enu)) {\r\n                    enumItems = enu;\r\n                }\r\n                enumItems.forEach(function (e) {\r\n                    var i = document.createElement('option'),\r\n                        val,\r\n                        title;\r\n                    if (Array.isArray(e)) {\r\n                        val = e[0];\r\n                        title = e[1];\r\n                    } else {\r\n                        val = e;\r\n                        title = e;\r\n                    }\r\n                    if (val === cell.value) { valueInEnum = true; }\r\n                    i.value = val;\r\n                    i.innerHTML = title;\r\n                    self.input.appendChild(i);\r\n                });\r\n                if (!valueInEnum) {\r\n                    option = document.createElement('option');\r\n                    option.value = cell.value;\r\n                    option.innerHTML = cell.value;\r\n                    self.input.appendChild(option);\r\n                }\r\n                self.input.addEventListener('change', function () {\r\n                    self.endEdit();\r\n                    self.draw(true);\r\n                });\r\n            }\r\n            // if the user has not prevented the default action, append to the body\r\n            if (!self.dispatchEvent('appendeditinput', {cell: cell, input:self.input})) { \r\n                document.body.appendChild(self.input);\r\n            }\r\n            self.createInlineStyle(self.input, self.mobile ? 'canvas-datagrid-edit-mobile-input' : 'canvas-datagrid-edit-input');\r\n            self.input.style.position = 'absolute';\r\n            self.input.editCell = cell;\r\n            self.resizeEditInput();\r\n            self.input.style.zIndex = self.style.editCellZIndex;\r\n            self.input.style.fontSize = (parseInt(self.style.editCellFontSize, 10) * self.scale) + 'px';\r\n            self.input.value = [null, undefined].indexOf(cell.value) !== -1 ? '' : cell.value;\r\n            self.input.focus();\r\n            self.input.addEventListener('click', self.stopPropagation);\r\n            self.input.addEventListener('dblclick', self.stopPropagation);\r\n            self.input.addEventListener('mouseup', self.stopPropagation);\r\n            self.input.addEventListener('mousedown', self.stopPropagation);\r\n            self.input.addEventListener('keydown', function (e) {\r\n                var nx = cell.columnIndex,\r\n                    ny = cell.rowIndex;\r\n                // esc\r\n                if (e.keyCode === 27) {\r\n                    self.endEdit(true);\r\n                    self.draw(true);\r\n                // enter\r\n                } else if (e.keyCode === 13\r\n                        && (!self.attributes.multiLine\r\n                            || (self.attributes.multiLine && e.shiftKey))) {\r\n                    self.endEdit();\r\n                    self.draw(true);\r\n                } else if (e.keyCode === 9) {\r\n                    e.preventDefault();\r\n                    if (!self.endEdit()) {\r\n                        return;\r\n                    }\r\n                    if (e.shiftKey) {\r\n                        nx = adjacentCells.left;\r\n                    } else {\r\n                        nx = adjacentCells.right;\r\n                    }\r\n                    if (adjacentCells.left === x && e.shiftKey) {\r\n                        nx = adjacentCells.last;\r\n                        ny -= 1;\r\n                    }\r\n                    if (adjacentCells.right === x && !e.shiftKey) {\r\n                        nx = adjacentCells.first;\r\n                        ny += 1;\r\n                    }\r\n                    if (ny < 0) {\r\n                        ny = self.data.length - 1;\r\n                    }\r\n                    if (ny > self.data.length - 1) {\r\n                        ny = 0;\r\n                    }\r\n                    self.scrollIntoView(nx, ny);\r\n                    self.beginEditAt(nx, ny, e);\r\n                }\r\n            });\r\n            self.dispatchEvent('beginedit', {cell: cell, input: self.input});\r\n        };\r\n        self.createInlineStyle = function (el, className) {\r\n            var css = {\r\n                'canvas-datagrid-context-menu-filter-input': {\r\n                    height: '19px',\r\n                    verticalAlign: 'bottom',\r\n                    marginLeft: '2px',\r\n                    padding: '0',\r\n                    background: self.style.contextFilterInputBackground,\r\n                    color: self.style.contextFilterInputColor,\r\n                    border: self.style.contextFilterInputBorder,\r\n                    borderRadius: self.style.contextFilterInputBorderRadius,\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextFilterInputFontFamily,\r\n                    fontSize: self.style.contextFilterInputFontSize\r\n                },\r\n                'canvas-datagrid-context-menu-filter-button': {\r\n                    height: '19px',\r\n                    verticalAlign: 'bottom',\r\n                    marginLeft: '2px',\r\n                    padding: '0',\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextFilterButtonBorder,\r\n                    borderRadius: self.style.contextFilterButtonBorderRadius,\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFilterButtonFontFamily,\r\n                    fontSize: self.style.contextMenuFilterButtonFontSize\r\n                },\r\n                'canvas-datagrid-context-child-arrow': {\r\n                    cssFloat: 'right',\r\n                    color: self.style.childContextMenuArrowColor,\r\n                    fontSize: self.style.contextMenuChildArrowFontSize,\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    verticalAlign: 'middle'\r\n                },\r\n                'canvas-datagrid-autocomplete': {\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextMenuBorder,\r\n                    padding: self.style.contextMenuPadding,\r\n                    borderRadius: self.style.contextMenuBorderRadius,\r\n                    opacity: self.style.contextMenuOpacity,\r\n                    position: 'absolute',\r\n                    zIndex: 9999,\r\n                    overflow: 'hidden'\r\n                },\r\n                'canvas-datagrid-autocomplete-item': {\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor\r\n                },\r\n                'canvas-datagrid-autocomplete-item:hover': {\r\n                    background: self.style.contextMenuHoverBackground,\r\n                    color: self.style.contextMenuHoverColor\r\n                },\r\n                'canvas-datagrid-canvas': {\r\n                    position: 'absolute',\r\n                    zIndex: '-1'\r\n                },\r\n                'canvas-datagrid': {\r\n                    display: 'block'\r\n                },\r\n                'canvas-datagrid-control-input': {\r\n                    position: 'fixed',\r\n                    top: '-5px',\r\n                    left: '-5px',\r\n                    border: 'none',\r\n                    opacity: '0',\r\n                    cursor: 'pointer',\r\n                    width: '1px',\r\n                    height: '1px',\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize\r\n                },\r\n                'canvas-datagrid-edit-mobile-input': {\r\n                    boxSizing: 'content-box',\r\n                    outline: 'none',\r\n                    margin: '0',\r\n                    padding: '0 0 0 0',\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.mobileEditFontFamily,\r\n                    fontSize: self.style.mobileEditFontSize,\r\n                    border: self.style.editCellBorder,\r\n                    color: self.style.editCellColor,\r\n                    background: self.style.editCellBackgroundColor,\r\n                    appearance: 'none',\r\n                    webkitAppearance: 'none',\r\n                    mozAppearance: 'none',\r\n                    borderRadius: '0'\r\n                },\r\n                'canvas-datagrid-edit-input': {\r\n                    boxSizing: 'content-box',\r\n                    outline: 'none',\r\n                    margin: '0',\r\n                    padding: '0 0 0 ' + self.style.editCellPaddingLeft + 'px',\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.editCellFontFamily,\r\n                    fontSize: self.style.editCellFontSize,\r\n                    boxShadow: self.style.editCellBoxShadow,\r\n                    border: self.style.editCellBorder,\r\n                    color: self.style.editCellColor,\r\n                    background: self.style.editCellBackgroundColor,\r\n                    appearance: 'none',\r\n                    webkitAppearance: 'none',\r\n                    mozAppearance: 'none',\r\n                    borderRadius: '0'\r\n                },\r\n                'canvas-datagrid-context-menu-item-mobile': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    color: 'inherit',\r\n                    background: 'inherit',\r\n                    margin: self.style.contextMenuItemMargin,\r\n                    borderRadius: self.style.contextMenuItemBorderRadius,\r\n                    verticalAlign: 'middle'\r\n                },\r\n                'canvas-datagrid-context-menu-item': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    color: 'inherit',\r\n                    background: 'inherit',\r\n                    margin: self.style.contextMenuItemMargin,\r\n                    borderRadius: self.style.contextMenuItemBorderRadius,\r\n                    verticalAlign: 'middle'\r\n                },\r\n                'canvas-datagrid-context-menu-item:hover': {\r\n                    background: self.style.contextMenuHoverBackground,\r\n                    color: self.style.contextMenuHoverColor\r\n                },\r\n                'canvas-datagrid-context-menu-label': {\r\n                    margin: self.style.contextMenuLabelMargin,\r\n                    display: self.style.contextMenuLabelDisplay,\r\n                    minWidth: self.style.contextMenuLabelMinWidth,\r\n                    maxWidth: self.style.contextMenuLabelMaxWidth\r\n                },\r\n                'canvas-datagrid-context-menu-mobile': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextMenuBorder,\r\n                    padding: self.style.contextMenuPadding,\r\n                    borderRadius: self.style.contextMenuBorderRadius,\r\n                    opacity: self.style.contextMenuOpacity,\r\n                    overflow: 'hidden',\r\n                    whiteSpace: 'nowrap'\r\n                },\r\n                'canvas-datagrid-context-menu': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextMenuBorder,\r\n                    padding: self.style.contextMenuPadding,\r\n                    borderRadius: self.style.contextMenuBorderRadius,\r\n                    opacity: self.style.contextMenuOpacity,\r\n                    overflow: 'hidden',\r\n                    whiteSpace: 'nowrap',\r\n                    cursor: self.style.contextMenuCursor\r\n                },\r\n                'canvas-datagrid-invalid-search-regExp': {\r\n                    background: self.style.contextMenuFilterInvalidExpresion\r\n                }\r\n            };\r\n            if (css[className]) {\r\n                Object.keys(css[className]).map(function (prop) {\r\n                    el.style[prop] = css[className][prop];\r\n                });\r\n            }\r\n            return;\r\n        };\r\n        self.appendTo = function (e) {\r\n            self.parentNode = e;\r\n            self.setDom();\r\n        };\r\n        self.setDom = function () {\r\n            if (self.isChildGrid) {\r\n                self.parentGrid = self.parentNode.parentGrid;\r\n                self.ctx = self.parentGrid.context;\r\n                self.canvas = self.parentGrid.canvas;\r\n                self.controlInput = self.parentGrid.controlInput;\r\n                self.eventParent = self.canvas;\r\n            } else {\r\n                self.controlInput = self.controlInput || document.createElement('input');\r\n                self.controlInput.onblur = self.intf.blur;\r\n                self.createInlineStyle(self.controlInput, 'canvas-datagrid-control-input');\r\n                self.isChildGrid = false;\r\n                self.parentDOMNode = self.parentNode;\r\n                self.parentIsCanvas = /^canvas$/i.test(self.parentDOMNode.tagName);\r\n                if (self.parentIsCanvas) {\r\n                    self.canvas = self.parentDOMNode;\r\n                } else {\r\n                    self.canvas = document.createElement('canvas');\r\n                    if (self.intf.createShadowRoot) {\r\n                        self.parentDOMNode.appendChild(self.canvas);\r\n                    }\r\n                }\r\n                document.body.appendChild(self.controlInput);\r\n                self.createInlineStyle(self.canvas, 'canvas-datagrid');\r\n                self.ctx = self.canvas.getContext('2d');\r\n                self.ctx.textBaseline = 'alphabetic';\r\n                self.eventParent = self.canvas;\r\n            }\r\n            self.parentNodeStyle = self.canvas.style;\r\n            self.controlInput.setAttribute('readonly', true);\r\n            self.controlInput.addEventListener('blur', function (e) {\r\n                if (e.target !== self.canvas) {\r\n                    self.hasFocus = false;\r\n                }\r\n            });\r\n            self.eventParent.addEventListener('scroll', self.resize, false);\r\n            self.eventParent.addEventListener('touchstart', self.touchstart, false);\r\n            self.eventParent.addEventListener('mouseup', self.mouseup, false);\r\n            self.eventParent.addEventListener('mousedown', self.mousedown, false);\r\n            self.eventParent.addEventListener('dblclick', self.dblclick, false);\r\n            self.eventParent.addEventListener('click', self.click, false);\r\n            self.eventParent.addEventListener('mousemove', self.mousemove);\r\n            self[self.isChildGrid ? 'parentGrid' : 'eventParent'].addEventListener('wheel', self.scrollWheel, false);\r\n            self.canvas.addEventListener('contextmenu', self.contextmenuEvent, false);\r\n            self.controlInput.addEventListener('copy', self.copy);\r\n            self.controlInput.addEventListener('cut', self.cut);\r\n            self.controlInput.addEventListener('paste', self.paste);\r\n            self.controlInput.addEventListener('keypress', self.keypress, false);\r\n            self.controlInput.addEventListener('keyup', self.keyup, false);\r\n            self.controlInput.addEventListener('keydown', self.keydown, false);\r\n            window.addEventListener('resize', self.resize);\r\n        };\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/dom.js\n// module id = 8\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        /**\r\n         * Converts a integer into a letter A - ZZZZZ...\r\n         * @memberof canvasDatagrid\r\n         * @name integerToAlpha\r\n         * @method\r\n         * @param {column} n The number to convert.\r\n         */\r\n        self.integerToAlpha = function (n) {\r\n            var ordA = 'a'.charCodeAt(0),\r\n                ordZ = 'z'.charCodeAt(0),\r\n                len = ordZ - ordA + 1,\r\n                s = '';\r\n            while (n >= 0) {\r\n                s = String.fromCharCode(n % len + ordA) + s;\r\n                n = Math.floor(n / len) - 1;\r\n            }\r\n            return s;\r\n        };\r\n        /**\r\n         * Inserts a new column before the specified index into the schema.\r\n         * @tutorial schema\r\n         * @memberof canvasDatagrid\r\n         * @name insertColumn\r\n         * @method\r\n         * @param {column} c The column to insert into the schema.\r\n         * @param {number} index The index of the column to insert before.\r\n         */\r\n        self.insertColumn = function (c, index) {\r\n            var s = self.getSchema();\r\n            if (s.length < index) {\r\n                throw new Error('Index is beyond the length of the schema.');\r\n            }\r\n            self.validateColumn(c, s);\r\n            s.splice(index, 0, c);\r\n            self.data.forEach(function (row) {\r\n                self.applyDefaultValue(row, c);\r\n            });\r\n            self.intf.schema = s;\r\n        };\r\n        /**\r\n         * Deletes a column from the schema at the specified index.\r\n         * @memberof canvasDatagrid\r\n         * @name deleteColumn\r\n         * @tutorial schema\r\n         * @method\r\n         * @param {number} index The index of the column to delete.\r\n         */\r\n        self.deleteColumn = function (index) {\r\n            var s = self.getSchema();\r\n            // remove data matching this column name from data\r\n            self.data.forEach(function (row) {\r\n                delete row[s[index].name];\r\n            });\r\n            s.splice(index, 1);\r\n            self.intf.schema = s;\r\n        };\r\n        /**\r\n         * Adds a new column into the schema.\r\n         * @tutorial schema\r\n         * @memberof canvasDatagrid\r\n         * @name addColumn\r\n         * @method\r\n         * @param {column} c The column to add to the schema.\r\n         */\r\n        self.addColumn = function (c) {\r\n            var s = self.getSchema();\r\n            self.validateColumn(c, s);\r\n            s.push(c);\r\n            self.data.forEach(function (row) {\r\n                self.applyDefaultValue(row, c);\r\n            });\r\n            self.intf.schema = s;\r\n        };\r\n        /**\r\n         * Deletes a row from the dataset at the specified index.\r\n         * @memberof canvasDatagrid\r\n         * @name deleteRow\r\n         * @method\r\n         * @param {number} index The index of the row to delete.\r\n         */\r\n        self.deleteRow = function (index) {\r\n            self.originalData.splice(index, 1);\r\n            self.setFilter();\r\n            self.resize(true);\r\n        };\r\n        /**\r\n         * Inserts a new row into the dataset before the specified index.\r\n         * @memberof canvasDatagrid\r\n         * @name insertRow\r\n         * @method\r\n         * @param {object} d data.\r\n         * @param {number} index The index of the row to insert before.\r\n         */\r\n        self.insertRow = function (d, index) {\r\n            if (self.originalData.length < index) {\r\n                throw new Error('Index is beyond the length of the dataset.');\r\n            }\r\n            self.originalData.splice(index, 0, d);\r\n            self.getSchema().forEach(function (c) {\r\n                if (d[c.name] === undefined) {\r\n                    self.applyDefaultValue(self.originalData[index], c);\r\n                }\r\n            });\r\n            self.setFilter();\r\n            self.resize(true);\r\n        };\r\n        /**\r\n         * Adds a new row into the dataset.\r\n         * @memberof canvasDatagrid\r\n         * @name addRow\r\n         * @method\r\n         * @param {object} d data.\r\n         */\r\n        self.addRow = function (d) {\r\n            self.originalData.push(d);\r\n            self.getSchema().forEach(function (c) {\r\n                if (d[c.name] === undefined) {\r\n                    self.applyDefaultValue(self.originalData[self.originalData.length - 1], c);\r\n                }\r\n            });\r\n            self.setFilter();\r\n            self.resize(true);\r\n        };\r\n        /**\r\n         * Sets the height of a given row by index number.\r\n         * @memberof canvasDatagrid\r\n         * @name setRowHeight\r\n         * @method\r\n         * @param {number} rowIndex The index of the row to set.\r\n         * @param {number} height Height to set the row to.\r\n         */\r\n        self.setRowHeight = function (rowIndex, height) {\r\n            self.sizes.rows[rowIndex] = height;\r\n            self.draw(true);\r\n        };\r\n        /**\r\n         * Sets the width of a given column by index number.\r\n         * @memberof canvasDatagrid\r\n         * @name setColumnWidth\r\n         * @method\r\n         * @param {number} colIndex The index of the column to set.\r\n         * @param {number} width Width to set the column to.\r\n         */\r\n        self.setColumnWidth = function (colIndex, width) {\r\n            self.sizes.columns[colIndex] = width;\r\n            self.draw(true);\r\n        };\r\n        /**\r\n         * Removes any changes to the width of the columns due to user or api interaction, setting them back to the schema or style default.\r\n         * @memberof canvasDatagrid\r\n         * @name resetColumnWidths\r\n         * @tutorial schema\r\n         * @method\r\n         */\r\n        self.resetColumnWidths = function () {\r\n            self.sizes.columns = {};\r\n            self.draw(true);\r\n        };\r\n        /**\r\n         * Removes any changes to the height of the rows due to user or api interaction, setting them back to the schema or style default.\r\n         * @memberof canvasDatagrid\r\n         * @name resetRowHeights\r\n         * @tutorial schema\r\n         * @method\r\n         */\r\n        self.resetRowHeights = function () {\r\n            self.sizes.rows = {};\r\n            self.draw(true);\r\n        };\r\n        /**\r\n         * Sets the value of the filter.\r\n         * @memberof canvasDatagrid\r\n         * @name setFilter\r\n         * @method\r\n         * @param {string} column Name of the column to filter.\r\n         * @param {string} value The value to filter for.\r\n         */\r\n        self.setFilter = function (column, value) {\r\n            if (column === undefined && value === undefined) {\r\n                self.columnFilters = {};\r\n            } else if (column && (value === '' || value === undefined)) {\r\n                delete self.columnFilters[column];\r\n            } else {\r\n                self.columnFilters[column] = value;\r\n            }\r\n            self.applyDataTransforms();\r\n        };\r\n        /**\r\n         * Returns the number of pixels to scroll down to line up with row rowIndex.\r\n         * @memberof canvasDatagrid\r\n         * @name findRowScrollTop\r\n         * @method\r\n         * @param {number} rowIndex The row index of the row to scroll find.\r\n         */\r\n        self.findRowScrollTop = function (rowIndex) {\r\n            if (self.scrollCache.y[rowIndex] === undefined) { throw new RangeError('Row index out of range.'); }\r\n            return self.scrollCache.y[rowIndex];\r\n        };\r\n        /**\r\n         * Returns the number of pixels to scroll to the left to line up with column columnIndex.\r\n         * @memberof canvasDatagrid\r\n         * @name findColumnScrollLeft\r\n         * @method\r\n         * @param {number} columnIndex The column index of the column to find.\r\n         */\r\n        self.findColumnScrollLeft = function (columnIndex) {\r\n            var i = Math.max(columnIndex - 1, 0);\r\n            if (self.scrollCache.x[i] === undefined) { throw new Error('Column index out of range.'); }\r\n            return self.scrollCache.x[i] - self.getColummnWidth(self.orders.columns[columnIndex]);\r\n        };\r\n        /**\r\n         * Scrolls to the cell at columnIndex x, and rowIndex y.  If you define both rowIndex and columnIndex additional calculations can be made to center the cell using the target cell's height and width.  Defining only one rowIndex or only columnIndex will result in simpler calculations.\r\n         * @memberof canvasDatagrid\r\n         * @name gotoCell\r\n         * @method\r\n         * @param {number} x The column index of the cell to scroll to.\r\n         * @param {number} y The row index of the cell to scroll to.\r\n         * @param {number} [offsetX=0] Percentage offset the cell should be from the left edge (not including headers).  The default is 0, meaning the cell will appear at the left edge. Valid values are 0 through 1. 1 = Left, 0 = Right, 0.5 = Center.\r\n         * @param {number} [offsetY=0] Percentage offset the cell should be from the top edge (not including headers).  The default is 0, meaning the cell will appear at the top edge. Valid values are 0 through 1. 1 = Bottom, 0 = Top, 0.5 = Center.\r\n         */\r\n        self.gotoCell = function (x, y, offsetX, offsetY) {\r\n            var targetX = x === undefined ? undefined : self.findColumnScrollLeft(x),\r\n                targetY = y === undefined ? undefined : self.findRowScrollTop(y),\r\n                cell,\r\n                sbw = self.scrollBox.width - (self.scrollBox.verticalBarVisible ? self.style.scrollBarWidth : 0),\r\n                sbh = self.scrollBox.height - (self.scrollBox.horizontalBarVisible ? self.style.scrollBarWidth : 0);\r\n            offsetX = offsetX === undefined ? 0 : offsetX;\r\n            offsetY = offsetY === undefined ? 0 : offsetY;\r\n            targetX -= sbw * offsetX;\r\n            targetY -= sbh * offsetY;\r\n            if (x !== undefined && y !== undefined) {\r\n                self.scrollBox.scrollTo(targetX, targetY);\r\n                requestAnimationFrame(function () {\r\n                    cell = self.getVisibleCellByIndex(x, y);\r\n                    // HACK: just don't offset if the target cell cannot be seen\r\n                    // TODO: offset does not work on very small grids, not sure why\r\n                    if (!cell) { return; }\r\n                    targetX += cell.width * offsetX;\r\n                    targetY += cell.height * offsetY;\r\n                    self.scrollBox.scrollTo(targetX, targetY);\r\n                });\r\n            } else if (x !== undefined) {\r\n                self.scrollBox.scrollLeft = targetX;\r\n            } else if (y !== undefined) {\r\n                self.scrollBox.scrollTop = targetY;\r\n            }\r\n        };\r\n        /**\r\n         * Scrolls the row y.\r\n         * @memberof canvasDatagrid\r\n         * @name gotoRow\r\n         * @method\r\n         * @param {number} y The row index of the cell to scroll to.\r\n         */\r\n        self.gotoRow = function (y) {\r\n            self.gotoCell(0, y);\r\n        };\r\n        /**\r\n         * Scrolls the cell at cell x, row y into view if it is not already.\r\n         * @memberof canvasDatagrid\r\n         * @name scrollIntoView\r\n         * @method\r\n         * @param {number} x The column index of the cell to scroll into view.\r\n         * @param {number} y The row index of the cell to scroll into view.\r\n         * @param {number} [offsetX=0] Percentage offset the cell should be from the left edge (not including headers).  The default is 0, meaning the cell will appear at the left edge. Valid values are 0 through 1. 1 = Left, 0 = Right, 0.5 = Center.\r\n         * @param {number} [offsetY=0] Percentage offset the cell should be from the top edge (not including headers).  The default is 0, meaning the cell will appear at the top edge. Valid values are 0 through 1. 1 = Bottom, 0 = Top, 0.5 = Center.\r\n         */\r\n        self.scrollIntoView = function (x, y, offsetX, offsetY) {\r\n            if (self.visibleCells.filter(function (cell) {\r\n                    return (cell.rowIndex === y || y === undefined)\r\n                        && (cell.columnIndex === x || x === undefined)\r\n                        && cell.x > 0\r\n                        && cell.y > 0\r\n                        && cell.x + cell.width < self.width\r\n                        && cell.y + cell.height < self.height;\r\n                }).length === 0) {\r\n                self.gotoCell(x, y, offsetX, offsetY);\r\n            }\r\n        };\r\n        /**\r\n         * Sets the active cell. Requires redrawing.\r\n         * @memberof canvasDatagrid\r\n         * @name setActiveCell\r\n         * @method\r\n         * @param {number} x The column index of the cell to set active.\r\n         * @param {number} y The row index of the cell to set active.\r\n         */\r\n        self.setActiveCell = function (x, y) {\r\n            if (x < 0) { x = 0; }\r\n            if (y < 0) { y = 0; }\r\n            self.activeCell = {\r\n                rowIndex: y,\r\n                columnIndex: x\r\n            };\r\n        };\r\n        /**\r\n         * Removes the selection.\r\n         * @memberof canvasDatagrid\r\n         * @name selectNone\r\n         * @param {boolean} dontDraw Suppress the draw method after the selection change.\r\n         * @method\r\n         */\r\n        self.selectNone = function (dontDraw) {\r\n            self.selections = [];\r\n            self.dispatchEvent('selectionchanged', {\r\n                selectedData: self.getSelectedData(),\r\n                selections: self.selections,\r\n                selectionBounds: self.selectionBounds\r\n            });\r\n            if (dontDraw) { return; }\r\n            self.draw();\r\n        };\r\n        /**\r\n         * Selects every visible cell.\r\n         * @memberof canvasDatagrid\r\n         * @name selectAll\r\n         * @param {boolean} dontDraw Suppress the draw method after the selection change.\r\n         * @method\r\n         */\r\n        self.selectAll = function (dontDraw) {\r\n            self.selectArea({\r\n                top: 0,\r\n                left: -1,\r\n                right: self.getSchema().length - 1,\r\n                bottom: self.data.length - 1\r\n            });\r\n            if (dontDraw) { return; }\r\n            self.draw();\r\n        };\r\n        /**\r\n         * Returns true if the selected columnIndex is selected on every row.\r\n         * @memberof canvasDatagrid\r\n         * @name isColumnSelected\r\n         * @method\r\n         * @param {number} columnIndex The column index to check.\r\n         */\r\n        self.isColumnSelected = function (columnIndex) {\r\n            var colIsSelected = true;\r\n            self.data.forEach(function (row, rowIndex) {\r\n                if (!self.selections[rowIndex] || self.selections[rowIndex].indexOf(self.orders.columns[columnIndex]) === -1) {\r\n                    colIsSelected = false;\r\n                }\r\n            });\r\n            return colIsSelected;\r\n        };\r\n        /**\r\n         * Runs the defined method on each selected cell.\r\n         * @memberof canvasDatagrid\r\n         * @name forEachSelectedCell\r\n         * @method\r\n         * @param {number} fn The function to execute.  The signature of the function is: (data, rowIndex, columnName).\r\n         * @param {number} expandToRow When true the data in the array is expanded to the entire row.\r\n         */\r\n        self.forEachSelectedCell = function (fn, expandToRow) {\r\n            var d = [], s = expandToRow ? self.getSchema() : self.getVisibleSchema(), l = self.data.length;\r\n            self.selections.forEach(function (row, index) {\r\n                if (index === l) { return; }\r\n                if (row.length === 0) {\r\n                    d[index] = null;\r\n                    return;\r\n                }\r\n                d[index] = {};\r\n                row.forEach(function (col) {\r\n                    if (col === -1 || !s[col]) { return; }\r\n                    fn(self.data, index, s[col].name);\r\n                });\r\n            });\r\n        };\r\n        /**\r\n         * Selects a column.\r\n         * @memberof canvasDatagrid\r\n         * @name selectColumn\r\n         * @method\r\n         * @param {number} columnIndex The column index to select.\r\n         * @param {boolean} toggleSelectMode When true, behaves as if you were holding control/command when you clicked the column.\r\n         * @param {boolean} shift When true, behaves as if you were holding shift when you clicked the column.\r\n         * @param {boolean} supressSelectionchangedEvent When true, prevents the selectionchanged event from firing.\r\n         */\r\n        self.selectColumn = function (columnIndex, ctrl, shift, supressEvent) {\r\n            var s, e, x;\r\n            function addCol(i) {\r\n                self.data.forEach(function (row, rowIndex) {\r\n                    self.selections[rowIndex] = self.selections[rowIndex] || [];\r\n                    if (self.selections[rowIndex].indexOf(i) === -1) {\r\n                        self.selections[rowIndex].push(i);\r\n                    }\r\n                });\r\n            }\r\n            function removeCol(i) {\r\n                self.data.forEach(function (row, rowIndex) {\r\n                    self.selections[rowIndex] = self.selections[rowIndex] || [];\r\n                    if (self.selections[rowIndex].indexOf(i) !== -1) {\r\n                        self.selections[rowIndex].splice(self.selections[rowIndex].indexOf(i), 1);\r\n                    }\r\n                });\r\n            }\r\n            if (shift) {\r\n                if (!self.activeCell) { return; }\r\n                s = Math.min(self.activeCell.columnIndex, columnIndex);\r\n                e = Math.max(self.activeCell.columnIndex, columnIndex);\r\n                for (x = s; e > x; x += 1) {\r\n                    addCol(x);\r\n                }\r\n            }\r\n            if (!ctrl && !shift) {\r\n                self.selections = [];\r\n                self.activeCell.columnIndex = columnIndex;\r\n                self.activeCell.rowIndex = self.scrollIndexTop;\r\n            }\r\n            if (ctrl && self.isColumnSelected(columnIndex)) {\r\n                removeCol(columnIndex);\r\n            } else {\r\n                addCol(columnIndex);\r\n            }\r\n            if (supressEvent) { return; }\r\n            self.dispatchEvent('selectionchanged', {\r\n                selectedData: self.getSelectedData(),\r\n                selections: self.selections,\r\n                selectionBounds: self.getSelectionBounds()\r\n            });\r\n        };\r\n        /**\r\n         * Selects a row.\r\n         * @memberof canvasDatagrid\r\n         * @name selectRow\r\n         * @method\r\n         * @param {number} rowIndex The row index to select.\r\n         * @param {boolean} ctrl When true, behaves as if you were holding control/command when you clicked the row.\r\n         * @param {boolean} shift When true, behaves as if you were holding shift when you clicked the row.\r\n         * @param {boolean} supressSelectionchangedEvent When true, prevents the selectionchanged event from firing.\r\n         */\r\n        self.selectRow = function (rowIndex, ctrl, shift, supressEvent) {\r\n            var x, st, en, s = self.getVisibleSchema();\r\n            function de() {\r\n                if (supressEvent) { return; }\r\n                self.dispatchEvent('selectionchanged', {\r\n                    selectedData: self.getSelectedData(),\r\n                    selections: self.selections,\r\n                    selectionBounds: self.selectionBounds\r\n                });\r\n            }\r\n            function addRow(ri) {\r\n                self.selections[ri] = [];\r\n                self.selections[ri].push(-1);\r\n                s.forEach(function (col, index) {\r\n                    self.selections[ri].push(self.orders.columns.indexOf(col.index));\r\n                });\r\n            }\r\n            if (self.dragAddToSelection === false || self.dragObject === undefined) {\r\n                if (self.selections[rowIndex] && self.selections[rowIndex].length - 1 === s.length) {\r\n                    if (ctrl) {\r\n                        self.selections[rowIndex] = [];\r\n                        de();\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            if (self.dragAddToSelection === true || self.dragObject === undefined) {\r\n                if (shift && self.dragObject === undefined) {\r\n                    if (!self.activeCell) { return; }\r\n                    st = Math.min(self.activeCell.rowIndex, rowIndex);\r\n                    en = Math.max(self.activeCell.rowIndex, rowIndex);\r\n                    for (x = st; en >= x; x += 1) {\r\n                        addRow(x);\r\n                    }\r\n                } else {\r\n                    addRow(rowIndex);\r\n                }\r\n            }\r\n            de();\r\n        };\r\n        /**\r\n         * Collapse a tree grid by row index.\r\n         * @memberof canvasDatagrid\r\n         * @name collapseTree\r\n         * @method\r\n         * @param {number} index The index of the row to collapse.\r\n         */\r\n        self.collapseTree = function (rowIndex) {\r\n            self.dispatchEvent('collapsetree', {\r\n                childGrid: self.childGrids[rowIndex],\r\n                data: self.data[rowIndex],\r\n                rowIndex: rowIndex\r\n            });\r\n            self.openChildren[rowIndex].blur();\r\n            self.openChildren[rowIndex].dispose();\r\n            delete self.openChildren[rowIndex];\r\n            delete self.sizes.trees[rowIndex];\r\n            delete self.childGrids[rowIndex];\r\n            self.dispatchEvent('resizerow', {\r\n                cellHeight: self.style.cellHeight\r\n            });\r\n            self.resize(true);\r\n            self.draw(true);\r\n        };\r\n        /**\r\n         * Expands a tree grid by row index.\r\n         * @memberof canvasDatagrid\r\n         * @name expandTree\r\n         * @method\r\n         * @param {number} index The index of the row to expand.\r\n         */\r\n        self.expandTree = function (rowIndex) {\r\n            var trArgs = self.args.treeGridAttributes || {},\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n                rowHeaderCellWidth = self.sizes.columns.cornerCell || self.style.rowHeaderCellWidth,\r\n                h = self.sizes.trees[rowIndex] || self.style.treeGridHeight,\r\n                treeGrid;\r\n            if (!self.childGrids[rowIndex]) {\r\n                trArgs.debug = self.attributes.debug;\r\n                trArgs.name = self.attributes.saveAppearance ? self.attributes.name + 'tree' + rowIndex : undefined;\r\n                trArgs.style = trArgs.style || self.style;\r\n                trArgs.parentNode = {\r\n                    parentGrid: self.intf,\r\n                    nodeType: 'canvas-datagrid-tree',\r\n                    offsetHeight: h,\r\n                    offsetWidth: self.width - rowHeaderCellWidth,\r\n                    header: { width: self.width - rowHeaderCellWidth },\r\n                    offsetLeft: rowHeaderCellWidth,\r\n                    offsetTop: columnHeaderCellHeight,\r\n                    offsetParent: self.intf.parentNode,\r\n                    parentNode: self.intf.parentNode,\r\n                    style: 'tree',\r\n                    data: self.data[rowIndex]\r\n                };\r\n                treeGrid = self.createGrid(trArgs);\r\n                self.childGrids[rowIndex] = treeGrid;\r\n            }\r\n            treeGrid = self.childGrids[rowIndex];\r\n            treeGrid.visible = true;\r\n            self.dispatchEvent('expandtree', {\r\n                treeGrid: treeGrid,\r\n                data: self.data[rowIndex],\r\n                rowIndex: rowIndex\r\n            });\r\n            self.openChildren[rowIndex] = treeGrid;\r\n            self.sizes.trees[rowIndex] = h;\r\n            self.dispatchEvent('resizerow', {height: self.style.cellHeight});\r\n            self.resize(true);\r\n        };\r\n        /**\r\n         * Toggles tree grid open and close by row index.\r\n         * @memberof canvasDatagrid\r\n         * @name toggleTree\r\n         * @method\r\n         * @param {number} index The index of the row to toggle.\r\n         */\r\n        self.toggleTree = function (rowIndex) {\r\n            var i = self.openChildren[rowIndex];\r\n            if (i) {\r\n                return self.collapseTree(rowIndex);\r\n            }\r\n            self.expandTree(rowIndex);\r\n        };\r\n        /**\r\n         * Returns a header from the schema by name.\r\n         * @memberof canvasDatagrid\r\n         * @name getHeaderByName\r\n         * @tutorial schema\r\n         * @method\r\n         * @returns {header} header with the selected name, or undefined.\r\n         * @param {string} name The name of the column to resize.\r\n         */\r\n        self.getHeaderByName = function (name) {\r\n            var x, i = self.getSchema();\r\n            for (x = 0; x < i.length; x += 1) {\r\n                if (i[x].name === name) {\r\n                    return i[x];\r\n                }\r\n            }\r\n        };\r\n        /**\r\n         * Resizes a column to fit the longest value in the column. Call without a value to resize all columns.\r\n         * Warning, can be slow on very large record sets (1m records ~3-5 seconds on an i7).\r\n         * @memberof canvasDatagrid\r\n         * @name fitColumnToValues\r\n         * @method\r\n         * @param {string} name The name of the column to resize.\r\n         */\r\n        self.fitColumnToValues = function (name, internal) {\r\n            if (!self.canvas) { return; }\r\n            self.sizes.columns[name === 'cornerCell' ? -1 : self.getHeaderByName(name).index]\r\n                = Math.max(self.findColumnMaxTextLength(name), self.style.minColumnWidth);\r\n            if (!internal) {\r\n                self.resize();\r\n                self.draw(true);\r\n            }\r\n        };\r\n        /**\r\n         * Checks if a cell is currently visible.\r\n         * @memberof canvasDatagrid\r\n         * @name isCellVisible\r\n         * @overload\r\n         * @method\r\n         * @returns {boolean} when true, the cell is visible, when false the cell is not currently drawn.\r\n         * @param {number} columnIndex The column index of the cell to check.\r\n         * @param {number} rowIndex The row index of the cell to check.\r\n         */\r\n        /**\r\n         * Checks if a cell is currently visible.\r\n         * @memberof canvasDatagrid\r\n         * @name isCellVisible\r\n         * @method\r\n         * @returns {boolean} when true, the cell is visible, when false the cell is not currently drawn.\r\n         * @param {cell} cell The cell to check for.  Alternatively you can pass an object { x: <x-pixel-value>, y: <y-pixel-value> }.\r\n         */\r\n        self.isCellVisible = function (cell, rowIndex) {\r\n            // overload\r\n            if (rowIndex !== undefined) {\r\n                return self.visibleCells.filter(function (c) {\r\n                    return c.columnIndex === cell && c.rowIndex === rowIndex;\r\n                }).length > 0;\r\n            }\r\n            var x, l = self.visibleCells.length;\r\n            for (x = 0; x < l; x += 1) {\r\n                if (cell.x === self.visibleCells[x].x && cell.y === self.visibleCells[x].y) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        /**\r\n         * Sets the order of the data.\r\n         * @memberof canvasDatagrid\r\n         * @name order\r\n         * @method\r\n         * @param {number} columnName Name of the column to be sorted.\r\n         * @param {string} direction `asc` for ascending or `desc` for descending.\r\n         * @param {function} [sortFunction] When defined, override the default sorting method defined in the column's schema and use this one.\r\n         * @param {bool} [dontSetStorageData] Don't store this setting for future use.\r\n         */\r\n        self.order = function (columnName, direction, sortFunction, dontSetStorageData) {\r\n            var f,\r\n                c = self.getSchema().filter(function (col) {\r\n                    return col.name === columnName;\r\n                });\r\n            if (self.dispatchEvent('beforesortcolumn', {name: columnName, direction: direction})) { return; }\r\n            self.orderBy = columnName;\r\n            self.orderDirection = direction;\r\n            if (!self.data || self.data.length === 0) { return; }\r\n            if (c.length === 0) {\r\n                throw new Error('Cannot sort.  No such column name');\r\n            }\r\n            f = sortFunction || c[0].sorter || self.sorters[c[0].type];\r\n            if (!f && c[0].type !== undefined) {\r\n                console.warn('Cannot sort type \"%s\" falling back to string sort.', c[0].type);\r\n            }\r\n            self.orderings.add(columnName, direction, (typeof f === 'function' ? f : self.sorters.string));\r\n            self.orderings.sort();\r\n            self.dispatchEvent('sortcolumn', {name: columnName, direction: direction});\r\n            self.draw(true);\r\n            if (dontSetStorageData) { return; }\r\n            self.setStorageData();\r\n        };\r\n        self.isInGrid = function (e) {\r\n            if (e.x < 0\r\n                    || e.x > self.width\r\n                    || e.y < 0\r\n                    || e.y > self.height) {\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n        /**\r\n         * Moves the current selection relative to the its current position.  Note: this method does not move the selected data, just the selection itself.\r\n         * @memberof canvasDatagrid\r\n         * @name moveSelection\r\n         * @method\r\n         * @param {number} offsetX The number of columns to offset the selection.\r\n         * @param {number} offsetY The number of rows to offset the selection.\r\n         */\r\n        self.moveSelection = function (offsetX, offsetY) {\r\n            var sel = [];\r\n            self.selections.forEach(function (row, rowIndex) {\r\n                sel[rowIndex + offsetY] = [];\r\n                row.forEach(function (colIndex) {\r\n                    sel[rowIndex + offsetY].push(colIndex + offsetX);\r\n                });\r\n            });\r\n            self.selections = sel;\r\n        };\r\n        /**\r\n         * Moves data in the provided selection to another position in the grid.  Moving data off the edge of the schema (columns/x) will truncate data.\r\n         * @memberof canvasDatagrid\r\n         * @name moveTo\r\n         * @method\r\n         * @param {array} sel 2D array representing selected rows and columns.  `canvasDatagrid.selections` is in this format and can be used here.\r\n         * @param {number} x The column index to start inserting the selection at.\r\n         * @param {number} y The row index to start inserting the selection at.\r\n         */\r\n        self.moveTo = function (sel, x, y) {\r\n            var d = self.getSelectedData(),\r\n                s = self.getVisibleSchema(),\r\n                l = sel.length,\r\n                xi,\r\n                maxRowLength = -Infinity,\r\n                minXi = Infinity,\r\n                yi = y - 1;\r\n            sel.forEach(function (row, index) {\r\n                if (index === l) { return; }\r\n                if (row.length === 0) { return; }\r\n                minXi = Math.min(self.getVisibleColumnIndexOf(x), minXi);\r\n                maxRowLength = Math.max(maxRowLength, row.length);\r\n                row.forEach(function (colIndex) {\r\n                    // intentional redef of colIndex\r\n                    colIndex = self.getVisibleColumnIndexOf(colIndex);\r\n                    if (!s[colIndex]) { return; }\r\n                    if (!self.data[index]) { self.data[index] = {}; }\r\n                    self.data[index][s[colIndex].name] = null;\r\n                });\r\n            });\r\n            sel.forEach(function (row, index) {\r\n                var lastSourceIndex;\r\n                yi += 1;\r\n                xi = self.getVisibleColumnIndexOf(x);\r\n                row.forEach(function (colIndex, cidx) {\r\n                    colIndex = self.getVisibleColumnIndexOf(colIndex);\r\n                    if (cidx > 0) {\r\n                        // this confusing bit of nonsense figures out\r\n                        // if the selection has skipped cells\r\n                        xi += colIndex - lastSourceIndex;\r\n                    }\r\n                    lastSourceIndex = colIndex;\r\n                    if (colIndex === -1\r\n                            || !s[xi]\r\n                            || !s[colIndex]\r\n                            || self.data.length - 1 < yi\r\n                            || yi < 0) { return; }\r\n                    if (!self.data[yi]) { self.data[yi] = {}; }\r\n                    self.data[yi][s[xi].name] = d[index][s[colIndex].name];\r\n                });\r\n            });\r\n        };\r\n        /**\r\n         * Checks if a given column is visible.\r\n         * @memberof canvasDatagrid\r\n         * @name isColumnVisible\r\n         * @method\r\n         * @returns {boolean} When true, the column is visible.\r\n         * @param {number} columnIndex Column index.\r\n         */\r\n        self.isColumnVisible = function (columnIndex) {\r\n            return self.visibleCells.filter(function (c) {\r\n                return c.columnIndex === columnIndex;\r\n            }).length > 0;\r\n        };\r\n        /**\r\n         * Checks if a given row is visible.\r\n         * @memberof canvasDatagrid\r\n         * @name isRowVisible\r\n         * @method\r\n         * @returns {boolean} When true, the row is visible.\r\n         * @param {number} rowIndex Row index.\r\n         */\r\n        self.isRowVisible = function (rowIndex) {\r\n            return self.visibleCells.filter(function (c) {\r\n                return c.rowIndex === rowIndex;\r\n            }).length > 0;\r\n        };\r\n        /**\r\n         * Gets the cell at columnIndex and rowIndex.\r\n         * @memberof canvasDatagrid\r\n         * @name getVisibleCellByIndex\r\n         * @method\r\n         * @returns {cell} cell at the selected location.\r\n         * @param {number} x Column index.\r\n         * @param {number} y Row index.\r\n         */\r\n        self.getVisibleCellByIndex = function (x, y) {\r\n            return self.visibleCells.filter(function (c) {\r\n                return c.columnIndex === x && c.rowIndex === y;\r\n            })[0];\r\n        };\r\n        /**\r\n         * Gets the cell at grid pixel coordinate x and y.  Author's note.  This function ties drawing and events together.  This is a very complex function and is core to the component.\r\n         * @memberof canvasDatagrid\r\n         * @name getCellAt\r\n         * @method\r\n         * @returns {cell} cell at the selected location.\r\n         * @param {number} x Number of pixels from the left.\r\n         * @param {number} y Number of pixels from the top.\r\n         */\r\n        self.getCellAt = function (x, y, useTouchScrollZones) {\r\n            function getBorder(entitiy) {\r\n                if (entitiy.x + entitiy.width - (self.attributes.borderResizeZone * 0.4) < x && entitiy.x + entitiy.width + (self.attributes.borderResizeZone * 0.6) > x) {\r\n                    return 'r';\r\n                }\r\n                if (entitiy.x - (self.attributes.borderResizeZone * 0.4) < x && entitiy.x + (self.attributes.borderResizeZone * 0.6) > x) {\r\n                    return 'l';\r\n                }\r\n                if (entitiy.y + entitiy.height - (self.attributes.borderResizeZone * 0.4) < y && entitiy.y + entitiy.height + (self.attributes.borderResizeZone * 0.6) > y) {\r\n                    return 'b';\r\n                }\r\n                if (entitiy.y - (self.attributes.borderResizeZone * 0.4) < y && entitiy.y + (self.attributes.borderResizeZone * 0.6) > y) {\r\n                    return 't';\r\n                }\r\n            }\r\n            if (!self.visibleCells) { return; }\r\n            var border,\r\n                tsz = useTouchScrollZones ? self.attributes.touchScrollZone : 0,\r\n                moveMode = self.attributes.borderDragBehavior === 'move',\r\n                i,\r\n                l = self.visibleCells.length,\r\n                moveBorder,\r\n                xBorderBehavior = moveMode ? self.cursorGrab : 'ew-resize',\r\n                yBorderBehavior = moveMode ? self.cursorGrab : 'ns-resize',\r\n                cell,\r\n                entitiy;\r\n            if (!self.visibleCells || !self.visibleCells.length) { return; }\r\n            self.hasFocus = true;\r\n            if (!(y < self.height\r\n                && y > 0\r\n                && x < self.width\r\n                && x > 0)) {\r\n                self.hasFocus = false;\r\n                return {\r\n                    dragContext: 'inherit',\r\n                    context: 'inherit'\r\n                };\r\n            }\r\n            for (i = 0; i < l; i += 1) {\r\n                cell = self.visibleCells[i];\r\n                // interactive dimensions of the cell.  used for touch \"over size\" zones\r\n                entitiy = {\r\n                    x: cell.x,\r\n                    y: cell.y,\r\n                    height: cell.height,\r\n                    width: cell.width\r\n                };\r\n                if (useTouchScrollZones && /(vertical|horizontal)-scroll-/.test(cell.style)) {\r\n                    entitiy.x -= tsz;\r\n                    entitiy.y -= tsz;\r\n                    entitiy.height += tsz;\r\n                    entitiy.width += tsz;\r\n                }\r\n                if (entitiy.x - self.style.cellBorderWidth < x\r\n                        && entitiy.x + entitiy.width + self.style.cellBorderWidth > x\r\n                        && entitiy.y - self.style.cellBorderWidth < y\r\n                        && entitiy.y + entitiy.height + self.style.cellBorderWidth > y) {\r\n                    if (/frozen-row-marker/.test(cell.style)) {\r\n                        cell.dragContext = cell.style;\r\n                        cell.context = 'row-resize';\r\n                        return cell;\r\n                    }\r\n                    if (/frozen-column-marker/.test(cell.style)) {\r\n                        cell.dragContext = cell.style;\r\n                        cell.context = 'col-resize';\r\n                        return cell;\r\n                    }\r\n                    if (/selection-handle-/.test(cell.style)) {\r\n                        cell.dragContext = cell.style;\r\n                        cell.context = 'crosshair';\r\n                        return cell;\r\n                    }\r\n                    if (/vertical-scroll-(bar|box)/.test(cell.style)) {\r\n                        cell.dragContext = 'vertical-scroll-box';\r\n                        cell.context = 'vertical-scroll-box';\r\n                        cell.isScrollBar = true;\r\n                        cell.isVerticalScrollBar = true;\r\n                        if (y > self.scrollBox.box.v.y + self.scrollBox.scrollBoxHeight) {\r\n                            cell.dragContext = 'vertical-scroll-bottom';\r\n                            cell.context = 'vertical-scroll-bottom';\r\n                        } else if (y < self.scrollBox.box.v.y) {\r\n                            cell.dragContext = 'vertical-scroll-top';\r\n                            cell.context = 'vertical-scroll-top';\r\n                        }\r\n                        self.cursor = 'default';\r\n                        return cell;\r\n                    }\r\n                    if (/horizontal-scroll-(bar|box)/.test(cell.style)) {\r\n                        cell.dragContext = 'horizontal-scroll-box';\r\n                        cell.context = 'horizontal-scroll-box';\r\n                        cell.isScrollBar = true;\r\n                        cell.isHorizontalScrollBar = true;\r\n                        if (x > self.scrollBox.box.h.x + self.scrollBox.scrollBoxWidth) {\r\n                            cell.dragContext = 'horizontal-scroll-right';\r\n                            cell.context = 'horizontal-scroll-right';\r\n                        } else if (x < self.scrollBox.box.h.x) {\r\n                            cell.dragContext = 'horizontal-scroll-left';\r\n                            cell.context = 'horizontal-scroll-left';\r\n                        }\r\n                        self.cursor = 'default';\r\n                        return cell;\r\n                    }\r\n                    border = getBorder(entitiy);\r\n                    // check if the border of this cell is the border of the selection and if so show move cursor in move mode\r\n                    moveBorder = moveMode && cell.selectionBorder && cell.selectionBorder.indexOf(border) !== -1;\r\n                    if (['l', 'r'].indexOf(border) !== -1\r\n                            && (self.attributes.allowColumnResize || moveBorder)\r\n                            && ((self.attributes.allowColumnResizeFromCell && cell.isNormal) || !cell.isNormal || moveBorder)\r\n                            && ((self.attributes.allowRowHeaderResize && (cell.isRowHeader || cell.isCorner)) || !(cell.isRowHeader && cell.isCorner))) {\r\n                        if (((cell.isColumnHeader || cell.isCorner) || (self.attributes.allowColumnResizeFromCell && cell.isNormal)) && border === 'r') {\r\n                            cell.context = 'ew-resize';\r\n                            cell.dragContext = 'ew-resize';\r\n                            return cell;\r\n                        }\r\n                        if (!(cell.isColumnHeader || cell.isCorner) && moveBorder) {\r\n                            cell.context = xBorderBehavior;\r\n                            cell.dragContext = border + '-move';\r\n                            return cell;\r\n                        }\r\n                    }\r\n                    if (['t', 'b'].indexOf(border) !== -1\r\n                            && cell.rowIndex > -1\r\n                            && (self.attributes.allowRowResize || moveBorder)\r\n                            && ((self.attributes.allowRowResizeFromCell && cell.isNormal) || !cell.isNormal || moveBorder)\r\n                            && !cell.isColumnHeader) {\r\n                        if (((cell.isRowHeader || cell.isCorner) || (self.attributes.allowRowResizeFromCell && cell.isNormal)) && border === 'b') {\r\n                            cell.context = 'ns-resize';\r\n                            cell.dragContext = 'ns-resize';\r\n                            return cell;\r\n                        }\r\n                        if (!(cell.isRowHeader || cell.isCorner) && moveBorder) {\r\n                            cell.context = yBorderBehavior;\r\n                            cell.dragContext = border + '-move';\r\n                            return cell;\r\n                        }\r\n                    }\r\n                    if (cell.style === 'columnHeaderCell') {\r\n                        cell.context = 'cell';\r\n                        cell.dragContext = 'column-reorder';\r\n                        return cell;\r\n                    }\r\n                    if (cell.style === 'rowHeaderCell') {\r\n                        if ((self.attributes.rowGrabZoneSize + (cell.y - self.style.cellBorderWidth) < y)\r\n                                || !self.attributes.allowRowReordering) {\r\n                            cell.dragContext = 'cell';\r\n                            cell.context = 'cell';\r\n                        } else {\r\n                            cell.context = self.cursorGrab;\r\n                            cell.dragContext = 'row-reorder';\r\n                        }\r\n                        return cell;\r\n                    }\r\n                    if (cell.isGrid) {\r\n                        self.hasFocus = false;\r\n                        cell.dragContext = 'cell-grid';\r\n                        cell.context = 'cell-grid';\r\n                        return cell;\r\n                    }\r\n                    if (cell.style === 'tree-grid') {\r\n                        self.hasFocus = false;\r\n                        cell.dragContext = 'tree';\r\n                        cell.context = 'tree';\r\n                        return cell;\r\n                    }\r\n                    cell.dragContext = 'cell';\r\n                    cell.context = 'cell';\r\n                    return cell;\r\n                }\r\n            }\r\n            self.hasFocus = true;\r\n            self.cursor = 'default';\r\n            return {\r\n                dragContext: 'background',\r\n                context: 'background',\r\n                style: 'background',\r\n                isBackground: true\r\n            };\r\n        };\r\n        /**\r\n         * Gets the bounds of current selection. \r\n         * @returns {rect} selection.\r\n         * @memberof canvasDatagrid\r\n         * @name getSelectionBounds\r\n         * @method\r\n         */\r\n        self.getSelectionBounds = function () {\r\n            var low = {x: Infinity, y: Infinity},\r\n                high = {x: -Infinity, y: -Infinity};\r\n            self.selections.forEach(function (row, rowIndex) {\r\n                var maxCol, minCol;\r\n                low.y = rowIndex < low.y ? rowIndex : low.y;\r\n                high.y = rowIndex > high.y ? rowIndex : high.y;\r\n                maxCol = Math.max.apply(null, row);\r\n                minCol = Math.min.apply(null, row);\r\n                low.x = minCol < low.x ? minCol : low.x;\r\n                high.x = maxCol > high.x ? maxCol : high.x;\r\n            });\r\n            return {\r\n                top: low.y,\r\n                left: low.x,\r\n                bottom: high.y,\r\n                right: high.x\r\n            };\r\n        };\r\n        /**\r\n         * Returns an auto generated schema based on data structure.\r\n         * @memberof canvasDatagrid\r\n         * @name getSchemaFromData\r\n         * @method\r\n         * @tutorial schema\r\n         * @returns {schema} schema A schema based on the first item in the data array.\r\n         */\r\n        self.getSchemaFromData = function (d) {\r\n            d = d || self.data;\r\n            return Object.keys(d[0] || {' ': ''}).map(function mapEachSchemaColumn(key, index) {\r\n                var type = self.getBestGuessDataType(key, d),\r\n                    i = {\r\n                        name: key,\r\n                        title: isNaN(parseInt(key, 10)) ? key : self.integerToAlpha(key).toUpperCase(),\r\n                        index: index,\r\n                        type: type,\r\n                        filter: self.filter(type)\r\n                    };\r\n                if (self.storedSettings\r\n                        && self.storedSettings.visibility\r\n                        && self.storedSettings.visibility[i.name] !== undefined) {\r\n                    i.hidden = !self.storedSettings.visibility[i.name];\r\n                }\r\n                return i;\r\n            });\r\n        };\r\n        /**\r\n         * Clears the change log grid.changes that keeps track of changes to the data set.\r\n         * This does not undo changes or alter data it is simply a convince array to keep\r\n         * track of changes made to the data since last this method was called.\r\n         * @memberof canvasDatagrid\r\n         * @name clearChangeLog\r\n         * @method\r\n         */\r\n        self.clearChangeLog = function () {\r\n            self.changes = [];\r\n        };\r\n        /**\r\n         * Selects an area of the grid.\r\n         * @memberof canvasDatagrid\r\n         * @name selectArea\r\n         * @method\r\n         * @param {rect} bounds A rect object representing the selected values.\r\n         */\r\n        self.selectArea = function (bounds, ctrl) {\r\n            self.selectionBounds = bounds || self.selectionBounds;\r\n            var ev, x, y, s = self.getSchema();\r\n            if (!ctrl) {\r\n                self.selections = [];\r\n            }\r\n            if (self.selectionBounds.top < -1\r\n                    || self.selectionBounds.bottom > self.data.length\r\n                    || self.selectionBounds.left < -1\r\n                    || self.selectionBounds.right > s.length) {\r\n                throw new Error('Impossible selection area');\r\n            }\r\n            for (x = self.selectionBounds.top; x <= self.selectionBounds.bottom; x += 1) {\r\n                self.selections[x] = [];\r\n                for (y = self.selectionBounds.left; y <= self.selectionBounds.right; y += 1) {\r\n                    if (self.selections[x].indexOf(y) === -1) {\r\n                        self.selections[x].push(y);\r\n                    }\r\n                }\r\n            }\r\n            ev = {\r\n                selections: self.selections,\r\n                selectionBounds: self.selectionBounds\r\n            };\r\n            Object.defineProperty(ev, 'selectedData', {\r\n                get: function () {\r\n                    return self.getSelectedData();\r\n                }\r\n            });\r\n            self.dispatchEvent('selectionchanged', ev);\r\n        };\r\n        /**\r\n         * Returns the maximum text width for a given column by column name.\r\n         * @memberof canvasDatagrid\r\n         * @name findColumnMaxTextLength\r\n         * @method\r\n         * @returns {number} The number of pixels wide the maximum width value in the selected column.\r\n         * @param {string} name The name of the column to calculate the value's width of.\r\n         */\r\n        self.findColumnMaxTextLength = function (name) {\r\n            var m = -Infinity;\r\n            if (name === 'cornerCell') {\r\n                self.ctx.font = self.style.rowHeaderCellFont;\r\n                return self.ctx.measureText((self.data.length + (self.attributes.showNewRow ? 1 : 0)).toString()).width\r\n                    + self.style.autosizePadding + self.style.autosizeHeaderCellPadding\r\n                    + self.style.rowHeaderCellPaddingRight\r\n                    + self.style.rowHeaderCellPaddingLeft\r\n                    + (self.attributes.tree ? self.style.treeArrowWidth\r\n                        + self.style.treeArrowMarginLeft + self.style.treeArrowMarginRight : 0);\r\n            }\r\n            self.getSchema().forEach(function (col) {\r\n                if (col.name !== name) { return; }\r\n                self.ctx.font = self.style.columnHeaderCellFont;\r\n                var t = self.ctx.measureText(col.title || col.name).width\r\n                    + self.style.headerCellPaddingRight\r\n                    + self.style.headerCellPaddingLeft;\r\n                m = t > m ? t : m;\r\n            });\r\n            self.data.forEach(function (row) {\r\n                self.ctx.font = self.style.cellFont;\r\n                var t = self.ctx.measureText(row[name]).width\r\n                    + self.style.cellPaddingRight\r\n                    + self.style.cellPaddingLeft + self.style.cellAutoResizePadding;\r\n                m = t > m ? t : m;\r\n            });\r\n            return m;\r\n        };\r\n        /**\r\n         * Gets the total width of all header columns.\r\n         * @memberof canvasDatagrid\r\n         * @name getHeaderWidth\r\n         * @method\r\n         */\r\n        self.getHeaderWidth = function () {\r\n            return self.getVisibleSchema().reduce(function (total, header) {\r\n                return total + (header.width || self.style.cellWidth);\r\n            }, 0);\r\n        };\r\n        /**\r\n         * Gets the height of a row by index.\r\n         * @memberof canvasDatagrid\r\n         * @name getRowHeight\r\n         * @method\r\n         * @param {number} rowIndex The row index to lookup.\r\n         */\r\n        self.getRowHeight = function (rowIndex) {\r\n            return ((self.sizes.rows[rowIndex]\r\n                    || self.style.cellHeight) * self.scale);\r\n        };\r\n        /**\r\n         * Gets the width of a column by index.\r\n         * @memberof canvasDatagrid\r\n         * @name getColummnWidth\r\n         * @method\r\n         * @param {number} columnIndex The column index to lookup.\r\n         */\r\n        self.getColummnWidth = function (columnIndex) {\r\n            return ((self.sizes.columns[columnIndex]\r\n                    || self.getSchema()[columnIndex].width\r\n                    || self.style.cellWidth) * self.scale);\r\n        };\r\n        self.formatters.string = function cellFormatterString(e) {\r\n            return e.cell.value !== undefined ? e.cell.value : '';\r\n        };\r\n        self.formatters.rowHeaderCell = self.formatters.string;\r\n        self.formatters.headerCell = self.formatters.string;\r\n        self.formatters.number = self.formatters.string;\r\n        self.formatters.int = self.formatters.string;\r\n        self.formatters.html = self.formatters.string;\r\n        self.sorters.string = function (columnName, direction) {\r\n            var asc = direction === 'asc';\r\n            return function (a, b) {\r\n                if (a[columnName] === undefined || a[columnName] === null) {\r\n                    return 1;\r\n                }\r\n                if (b[columnName] === undefined || b[columnName] === null) {\r\n                    return 0;\r\n                }\r\n                if (asc) {\r\n                    if (!a[columnName].localeCompare) { return 1; }\r\n                    return a[columnName].localeCompare(b[columnName]);\r\n                }\r\n                if (!b[columnName].localeCompare) { return 1; }\r\n                return b[columnName].localeCompare(a[columnName]);\r\n            };\r\n        };\r\n        self.sorters.number = function (columnName, direction) {\r\n            var asc = direction === 'asc';\r\n            return function (a, b) {\r\n                if (asc) {\r\n                    return a[columnName] - b[columnName];\r\n                }\r\n                return b[columnName] - a[columnName];\r\n            };\r\n        };\r\n        self.sorters.date = function (columnName, direction) {\r\n            var asc = direction === 'asc';\r\n            return function (a, b) {\r\n                if (asc) {\r\n                    return new Date(a[columnName]).getTime()\r\n                        - new Date(b[columnName]).getTime();\r\n                }\r\n                return new Date(b[columnName]).getTime()\r\n                        - new Date(a[columnName]).getTime();\r\n            };\r\n        };\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/publicMethods.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}